<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: string_constraint_generatort Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classstring__constraint__generatort.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classstring__constraint__generatort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">string_constraint_generatort Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for string_constraint_generatort:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classstring__constraint__generatort__coll__graph.svg" width="1926" height="404"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstring__constraint__generatort_1_1parseint__argumentst.html">parseint_argumentst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument block for parseInt and cousins, common to parseInt itself and CProverString.isValidInt.  <a href="structstring__constraint__generatort_1_1parseint__argumentst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d76d526657f0ac5c6117abb0505180e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a9d76d526657f0ac5c6117abb0505180e">string_constraint_generatort</a> (const <a class="el" href="classnamespacet.html">namespacet</a> &amp;<a class="el" href="classstring__constraint__generatort.html#a3d98127ced7c40a9d10b4bb00b3b78dd">ns</a>, <a class="el" href="classmessage__handlert.html">message_handlert</a> &amp;<a class="el" href="classstring__constraint__generatort.html#a6068a48416be18eb0a6737fad1f34d66">message_handler</a>)</td></tr>
<tr class="separator:a9d76d526657f0ac5c6117abb0505180e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c001afbc2aff0e1b11dda5e2fdc930"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a52c001afbc2aff0e1b11dda5e2fdc930">add_axioms_for_function_application</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;expr)</td></tr>
<tr class="memdesc:a52c001afbc2aff0e1b11dda5e2fdc930"><td class="mdescLeft">&#160;</td><td class="mdescRight">strings contained in this call are converted to objects of type <code>string_exprt</code>, through adding axioms.  <a href="classstring__constraint__generatort.html#a52c001afbc2aff0e1b11dda5e2fdc930">More...</a><br /></td></tr>
<tr class="separator:a52c001afbc2aff0e1b11dda5e2fdc930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b8f9696f68ccd9c50b5a6da6a8f8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a44b8f9696f68ccd9c50b5a6da6a8f8ce">make_array_pointer_association</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;return_code, const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;expr)</td></tr>
<tr class="memdesc:a44b8f9696f68ccd9c50b5a6da6a8f8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate array to pointer, and array to length.  <a href="classstring__constraint__generatort.html#a44b8f9696f68ccd9c50b5a6da6a8f8ce">More...</a><br /></td></tr>
<tr class="separator:a44b8f9696f68ccd9c50b5a6da6a8f8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3674489dd834809a99bb80f9a0e731ee"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a3674489dd834809a99bb80f9a0e731ee">add_axioms_for_concat</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;<a class="el" href="bytecode__info_8h.html#a3b6653c9d2fc6aa11ec16b971883b82a">s1</a>, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;<a class="el" href="bytecode__info_8h.html#a1ad7643875e80af295454566f9d548d8">s2</a>)</td></tr>
<tr class="memdesc:a3674489dd834809a99bb80f9a0e731ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms enforcing that <code>res</code> is equal to the concatenation of <code>s1</code> and <code>s2</code>.  <a href="classstring__constraint__generatort.html#a3674489dd834809a99bb80f9a0e731ee">More...</a><br /></td></tr>
<tr class="separator:a3674489dd834809a99bb80f9a0e731ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c7629d729b29589df03b07506f8b6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a402c7629d729b29589df03b07506f8b6">add_axioms_for_concat_substr</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;<a class="el" href="bytecode__info_8h.html#a3b6653c9d2fc6aa11ec16b971883b82a">s1</a>, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;<a class="el" href="bytecode__info_8h.html#a1ad7643875e80af295454566f9d548d8">s2</a>, const <a class="el" href="classexprt.html">exprt</a> &amp;start_index, const <a class="el" href="classexprt.html">exprt</a> &amp;end_index)</td></tr>
<tr class="memdesc:a402c7629d729b29589df03b07506f8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms enforcing that <code>res</code> is the concatenation of <code>s1</code> with the substring of <code>s2</code> starting at index &lsquo;start_index&rsquo;<code>and ending at index</code>end_index'&lsquo;.  <a href="classstring__constraint__generatort.html#a402c7629d729b29589df03b07506f8b6">More...</a><br /></td></tr>
<tr class="separator:a402c7629d729b29589df03b07506f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da1f040a145ff7802642dc6d9a90732"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a0da1f040a145ff7802642dc6d9a90732">add_axioms_for_insert</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;<a class="el" href="bytecode__info_8h.html#a3b6653c9d2fc6aa11ec16b971883b82a">s1</a>, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;<a class="el" href="bytecode__info_8h.html#a1ad7643875e80af295454566f9d548d8">s2</a>, const <a class="el" href="classexprt.html">exprt</a> &amp;offset)</td></tr>
<tr class="separator:a0da1f040a145ff7802642dc6d9a90732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd9990fc5408ebd5a5bde54533c3b53"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a4bd9990fc5408ebd5a5bde54533c3b53">add_axioms_for_string_of_int_with_radix</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;input_int, const <a class="el" href="classexprt.html">exprt</a> &amp;radix, size_t max_size)</td></tr>
<tr class="memdesc:a4bd9990fc5408ebd5a5bde54533c3b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms enforcing that the string corresponds to the result of String.valueOf(II) or String.valueOf(JI) Java functions applied on the integer expression.  <a href="classstring__constraint__generatort.html#a4bd9990fc5408ebd5a5bde54533c3b53">More...</a><br /></td></tr>
<tr class="separator:a4bd9990fc5408ebd5a5bde54533c3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f30b5a42a21de03eaa7cc3f2cea5208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstring__constraintst.html">string_constraintst</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a9f30b5a42a21de03eaa7cc3f2cea5208">add_constraint_on_characters</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;s, const <a class="el" href="classexprt.html">exprt</a> &amp;start, const <a class="el" href="classexprt.html">exprt</a> &amp;end, const std::string &amp;char_set)</td></tr>
<tr class="memdesc:a9f30b5a42a21de03eaa7cc3f2cea5208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraint on characters of a string.  <a href="classstring__constraint__generatort.html#a9f30b5a42a21de03eaa7cc3f2cea5208">More...</a><br /></td></tr>
<tr class="separator:a9f30b5a42a21de03eaa7cc3f2cea5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e22cd1139cd1d5d762e11aa3c7661e9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a4e22cd1139cd1d5d762e11aa3c7661e9">add_axioms_for_constrain_characters</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a4e22cd1139cd1d5d762e11aa3c7661e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms to ensure all characters of a string belong to a given set.  <a href="classstring__constraint__generatort.html#a4e22cd1139cd1d5d762e11aa3c7661e9">More...</a><br /></td></tr>
<tr class="separator:a4e22cd1139cd1d5d762e11aa3c7661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eba61dc98ff9c33d85ddc5db6c8d6e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ad2eba61dc98ff9c33d85ddc5db6c8d6e">add_axioms_for_char_at</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:ad2eba61dc98ff9c33d85ddc5db6c8d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character at a given position.  <a href="classstring__constraint__generatort.html#ad2eba61dc98ff9c33d85ddc5db6c8d6e">More...</a><br /></td></tr>
<tr class="separator:ad2eba61dc98ff9c33d85ddc5db6c8d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c9b66bdab29c6a293eb91b5b2b2fd3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ad2c9b66bdab29c6a293eb91b5b2b2fd3">add_axioms_for_code_point_at</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:ad2c9b66bdab29c6a293eb91b5b2b2fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">add axioms corresponding to the String.codePointAt java function  <a href="classstring__constraint__generatort.html#ad2c9b66bdab29c6a293eb91b5b2b2fd3">More...</a><br /></td></tr>
<tr class="separator:ad2c9b66bdab29c6a293eb91b5b2b2fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc76888dced93da2eb9877f072e2fa06"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#adc76888dced93da2eb9877f072e2fa06">add_axioms_for_code_point_before</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:adc76888dced93da2eb9877f072e2fa06"><td class="mdescLeft">&#160;</td><td class="mdescRight">add axioms corresponding to the String.codePointBefore java function  <a href="classstring__constraint__generatort.html#adc76888dced93da2eb9877f072e2fa06">More...</a><br /></td></tr>
<tr class="separator:adc76888dced93da2eb9877f072e2fa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947bfc18e507ae29f4c9c24c849008da"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a947bfc18e507ae29f4c9c24c849008da">add_axioms_for_contains</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a947bfc18e507ae29f4c9c24c849008da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a string contains another.  <a href="classstring__constraint__generatort.html#a947bfc18e507ae29f4c9c24c849008da">More...</a><br /></td></tr>
<tr class="separator:a947bfc18e507ae29f4c9c24c849008da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2564a8557294c2a97adc17eaac4faaa9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a2564a8557294c2a97adc17eaac4faaa9">add_axioms_for_equals</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a2564a8557294c2a97adc17eaac4faaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of the content of two strings.  <a href="classstring__constraint__generatort.html#a2564a8557294c2a97adc17eaac4faaa9">More...</a><br /></td></tr>
<tr class="separator:a2564a8557294c2a97adc17eaac4faaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098d449152e6871936586b8f3ef911f0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a098d449152e6871936586b8f3ef911f0">add_axioms_for_equals_ignore_case</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a098d449152e6871936586b8f3ef911f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of the content ignoring case of characters.  <a href="classstring__constraint__generatort.html#a098d449152e6871936586b8f3ef911f0">More...</a><br /></td></tr>
<tr class="separator:a098d449152e6871936586b8f3ef911f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350486d5cdf896def32bcd957e4f5167"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a350486d5cdf896def32bcd957e4f5167">add_axioms_for_is_empty</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a350486d5cdf896def32bcd957e4f5167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned value is true exactly when the argument string is empty.  <a href="classstring__constraint__generatort.html#a350486d5cdf896def32bcd957e4f5167">More...</a><br /></td></tr>
<tr class="separator:a350486d5cdf896def32bcd957e4f5167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767cec45b3a581dfab202a481ce5809b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a767cec45b3a581dfab202a481ce5809b">add_axioms_for_is_prefix</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;prefix, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const <a class="el" href="classexprt.html">exprt</a> &amp;offset)</td></tr>
<tr class="memdesc:a767cec45b3a581dfab202a481ce5809b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned expression is true exactly when the offset is greater or equal to 0 and the first string is a prefix of the second one, starting at position offset.  <a href="classstring__constraint__generatort.html#a767cec45b3a581dfab202a481ce5809b">More...</a><br /></td></tr>
<tr class="separator:a767cec45b3a581dfab202a481ce5809b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4538b1dc0117bfc2fb8b6b86d8a9da4b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a4538b1dc0117bfc2fb8b6b86d8a9da4b">add_axioms_for_is_prefix</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f, bool swap_arguments)</td></tr>
<tr class="memdesc:a4538b1dc0117bfc2fb8b6b86d8a9da4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the target is a prefix of the string.  <a href="classstring__constraint__generatort.html#a4538b1dc0117bfc2fb8b6b86d8a9da4b">More...</a><br /></td></tr>
<tr class="separator:a4538b1dc0117bfc2fb8b6b86d8a9da4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebf57bfa784209cffffd40605815658"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a8ebf57bfa784209cffffd40605815658">add_axioms_for_is_suffix</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f, bool swap_arguments)</td></tr>
<tr class="memdesc:a8ebf57bfa784209cffffd40605815658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the target is a suffix of the string.  <a href="classstring__constraint__generatort.html#a8ebf57bfa784209cffffd40605815658">More...</a><br /></td></tr>
<tr class="separator:a8ebf57bfa784209cffffd40605815658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ab1148baaf52c82aeb389c764704ec"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ae0ab1148baaf52c82aeb389c764704ec">add_axioms_for_length</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:ae0ab1148baaf52c82aeb389c764704ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of a string.  <a href="classstring__constraint__generatort.html#ae0ab1148baaf52c82aeb389c764704ec">More...</a><br /></td></tr>
<tr class="separator:ae0ab1148baaf52c82aeb389c764704ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0532aa59baecb3935d1acbb0466639c9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a0532aa59baecb3935d1acbb0466639c9">add_axioms_for_empty_string</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a0532aa59baecb3935d1acbb0466639c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms to say that the returned string expression is empty.  <a href="classstring__constraint__generatort.html#a0532aa59baecb3935d1acbb0466639c9">More...</a><br /></td></tr>
<tr class="separator:a0532aa59baecb3935d1acbb0466639c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abead2cc0925faf55fdd8d52c62006a40"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#abead2cc0925faf55fdd8d52c62006a40">add_axioms_for_copy</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:abead2cc0925faf55fdd8d52c62006a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">add axioms to say that the returned string expression is equal to the argument of the function application  <a href="classstring__constraint__generatort.html#abead2cc0925faf55fdd8d52c62006a40">More...</a><br /></td></tr>
<tr class="separator:abead2cc0925faf55fdd8d52c62006a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda7e47e203283f726a4d156929b6550"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#acda7e47e203283f726a4d156929b6550">add_axioms_for_concat_code_point</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:acda7e47e203283f726a4d156929b6550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding to the StringBuilder.appendCodePoint(I) function.  <a href="classstring__constraint__generatort.html#acda7e47e203283f726a4d156929b6550">More...</a><br /></td></tr>
<tr class="separator:acda7e47e203283f726a4d156929b6550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad994ba02b8abfb1a4943d24a5693301e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ad994ba02b8abfb1a4943d24a5693301e">add_axioms_for_constant</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> sval, const <a class="el" href="classexprt.html">exprt</a> &amp;<a class="el" href="c__safety__checks_8cpp.html#a1675f729dc854238dd23840d004c7c0a">guard</a>=<a class="el" href="classtrue__exprt.html">true_exprt</a>())</td></tr>
<tr class="memdesc:ad994ba02b8abfb1a4943d24a5693301e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms ensuring that the provided string expression and constant are equal.  <a href="classstring__constraint__generatort.html#ad994ba02b8abfb1a4943d24a5693301e">More...</a><br /></td></tr>
<tr class="separator:ad994ba02b8abfb1a4943d24a5693301e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d779359dc86a94838a4294e56a5fc54"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a0d779359dc86a94838a4294e56a5fc54">add_axioms_for_delete</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const <a class="el" href="classexprt.html">exprt</a> &amp;start, const <a class="el" href="classexprt.html">exprt</a> &amp;end)</td></tr>
<tr class="memdesc:a0d779359dc86a94838a4294e56a5fc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that <code>res</code> corresponds to the input <code>str</code> where we removed characters between the positions <code>start</code> (included) and <code>end</code> (not included).  <a href="classstring__constraint__generatort.html#a0d779359dc86a94838a4294e56a5fc54">More...</a><br /></td></tr>
<tr class="separator:a0d779359dc86a94838a4294e56a5fc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ba1c88b61ff22ee4e116b7462b4f13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a75ba1c88b61ff22ee4e116b7462b4f13">add_axioms_for_delete</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a75ba1c88b61ff22ee4e116b7462b4f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a portion of a string.  <a href="classstring__constraint__generatort.html#a75ba1c88b61ff22ee4e116b7462b4f13">More...</a><br /></td></tr>
<tr class="separator:a75ba1c88b61ff22ee4e116b7462b4f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc6adc2f407642a14c8c5ce644572d9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#adfc6adc2f407642a14c8c5ce644572d9">add_axioms_for_delete_char_at</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;expr)</td></tr>
<tr class="memdesc:adfc6adc2f407642a14c8c5ce644572d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">add axioms corresponding to the StringBuilder.deleteCharAt java function  <a href="classstring__constraint__generatort.html#adfc6adc2f407642a14c8c5ce644572d9">More...</a><br /></td></tr>
<tr class="separator:adfc6adc2f407642a14c8c5ce644572d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a0fccb9f643409938e89ae94d4f90"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a416a0fccb9f643409938e89ae94d4f90">add_axioms_for_cprover_string</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;arg, const <a class="el" href="classexprt.html">exprt</a> &amp;<a class="el" href="c__safety__checks_8cpp.html#a1675f729dc854238dd23840d004c7c0a">guard</a>)</td></tr>
<tr class="memdesc:a416a0fccb9f643409938e89ae94d4f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an expression of type <a class="el" href="classstring__typet.html" title="String type.">string_typet</a> to a string_exprt.  <a href="classstring__constraint__generatort.html#a416a0fccb9f643409938e89ae94d4f90">More...</a><br /></td></tr>
<tr class="separator:a416a0fccb9f643409938e89ae94d4f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aab0f9856ebd30a24a8e08214f5c9a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a8aab0f9856ebd30a24a8e08214f5c9a2">add_axioms_from_literal</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a8aab0f9856ebd30a24a8e08214f5c9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">String corresponding to an internal cprover string.  <a href="classstring__constraint__generatort.html#a8aab0f9856ebd30a24a8e08214f5c9a2">More...</a><br /></td></tr>
<tr class="separator:a8aab0f9856ebd30a24a8e08214f5c9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddef0b51489e4b1fb5f2a2d26e23f5f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a5ddef0b51489e4b1fb5f2a2d26e23f5f">add_axioms_for_string_of_int</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;input_int, size_t max_size)</td></tr>
<tr class="memdesc:a5ddef0b51489e4b1fb5f2a2d26e23f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms enforcing that the string corresponds to the result of String.valueOf(I) or String.valueOf(J) Java functions applied on the integer expression.  <a href="classstring__constraint__generatort.html#a5ddef0b51489e4b1fb5f2a2d26e23f5f">More...</a><br /></td></tr>
<tr class="separator:a5ddef0b51489e4b1fb5f2a2d26e23f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a6c4899bb450b7428e1d61ad7fc3a4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a32a6c4899bb450b7428e1d61ad7fc3a4">add_axioms_from_int_hex</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;i)</td></tr>
<tr class="memdesc:a32a6c4899bb450b7428e1d61ad7fc3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the string <code>res</code> corresponds to the integer argument written in hexadecimal.  <a href="classstring__constraint__generatort.html#a32a6c4899bb450b7428e1d61ad7fc3a4">More...</a><br /></td></tr>
<tr class="separator:a32a6c4899bb450b7428e1d61ad7fc3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9549205227b3ca2e68004bccacb99ee"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#aa9549205227b3ca2e68004bccacb99ee">add_axioms_from_int_hex</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:aa9549205227b3ca2e68004bccacb99ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding to the Integer.toHexString(I) java function.  <a href="classstring__constraint__generatort.html#aa9549205227b3ca2e68004bccacb99ee">More...</a><br /></td></tr>
<tr class="separator:aa9549205227b3ca2e68004bccacb99ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77a8d580b71b6b3916b74d0392edc3b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ac77a8d580b71b6b3916b74d0392edc3b">add_axioms_from_long</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:ac77a8d580b71b6b3916b74d0392edc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding to the String.valueOf(J) java function.  <a href="classstring__constraint__generatort.html#ac77a8d580b71b6b3916b74d0392edc3b">More...</a><br /></td></tr>
<tr class="separator:ac77a8d580b71b6b3916b74d0392edc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b8a4d5b208d2ddde4dda64e86de5e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a987b8a4d5b208d2ddde4dda64e86de5e">add_axioms_from_bool</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="separator:a987b8a4d5b208d2ddde4dda64e86de5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e9c75993a489ae8aa6823b201d0d9c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a23e9c75993a489ae8aa6823b201d0d9c">add_axioms_from_bool</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;b)</td></tr>
<tr class="memdesc:a23e9c75993a489ae8aa6823b201d0d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned string equals "true" when the Boolean expression is true and "false" when it is false.  <a href="classstring__constraint__generatort.html#a23e9c75993a489ae8aa6823b201d0d9c">More...</a><br /></td></tr>
<tr class="separator:a23e9c75993a489ae8aa6823b201d0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c2ef64693eafc6bd58b2c0b11154ca"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a24c2ef64693eafc6bd58b2c0b11154ca">add_axioms_from_char</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="separator:a24c2ef64693eafc6bd58b2c0b11154ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c5a88af3afbc33d27254c021b77e1d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ac9c5a88af3afbc33d27254c021b77e1d">add_axioms_from_char</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;c)</td></tr>
<tr class="separator:ac9c5a88af3afbc33d27254c021b77e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be3f98b3ca1c9f53a9cf99050aa16ad"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a4be3f98b3ca1c9f53a9cf99050aa16ad">add_axioms_for_index_of</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const <a class="el" href="classexprt.html">exprt</a> &amp;c, const <a class="el" href="classexprt.html">exprt</a> &amp;from_index)</td></tr>
<tr class="memdesc:a4be3f98b3ca1c9f53a9cf99050aa16ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned value is the index within <code>haystack</code> (<code>str</code>) of the first occurrence of <code>needle</code> (<code>c</code>) starting the search at <code>from_index</code>, or is <code>-1</code> if no such character occurs at or after position <code>from_index</code>.  <a href="classstring__constraint__generatort.html#a4be3f98b3ca1c9f53a9cf99050aa16ad">More...</a><br /></td></tr>
<tr class="separator:a4be3f98b3ca1c9f53a9cf99050aa16ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669615d02a4d7aca9c7c49913bc0975"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a9669615d02a4d7aca9c7c49913bc0975">add_axioms_for_index_of_string</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;haystack, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;needle, const <a class="el" href="classexprt.html">exprt</a> &amp;from_index)</td></tr>
<tr class="memdesc:a9669615d02a4d7aca9c7c49913bc0975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned value <code>index</code> is the index within <code>haystack</code> of the first occurrence of <code>needle</code> starting the search at <code>from_index</code>, or <code>-1</code> if needle does not occur at or after position <code>from_index</code>.  <a href="classstring__constraint__generatort.html#a9669615d02a4d7aca9c7c49913bc0975">More...</a><br /></td></tr>
<tr class="separator:a9669615d02a4d7aca9c7c49913bc0975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef0bfde58d9441a98c748db3107523"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#aceef0bfde58d9441a98c748db3107523">add_axioms_for_index_of</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:aceef0bfde58d9441a98c748db3107523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the first occurence of a target inside the string.  <a href="classstring__constraint__generatort.html#aceef0bfde58d9441a98c748db3107523">More...</a><br /></td></tr>
<tr class="separator:aceef0bfde58d9441a98c748db3107523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c0c86497ba2cfb1665873751bdf971"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a35c0c86497ba2cfb1665873751bdf971">add_axioms_for_last_index_of_string</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;haystack, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;needle, const <a class="el" href="classexprt.html">exprt</a> &amp;from_index)</td></tr>
<tr class="memdesc:a35c0c86497ba2cfb1665873751bdf971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned value is the index within haystack of the last occurrence of needle starting the search backward at from_index (ie the index is smaller or equal to from_index), or -1 if needle does not occur before from_index.  <a href="classstring__constraint__generatort.html#a35c0c86497ba2cfb1665873751bdf971">More...</a><br /></td></tr>
<tr class="separator:a35c0c86497ba2cfb1665873751bdf971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6c1bac62761c6fdab0d5a12f9d3d71"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a0e6c1bac62761c6fdab0d5a12f9d3d71">add_axioms_for_last_index_of</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const <a class="el" href="classexprt.html">exprt</a> &amp;c, const <a class="el" href="classexprt.html">exprt</a> &amp;from_index)</td></tr>
<tr class="memdesc:a0e6c1bac62761c6fdab0d5a12f9d3d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms stating that the returned value is the index within <code>haystack</code> (<code>str</code>) of the last occurrence of <code>needle</code> (<code>c</code>) starting the search backward at <code>from_index</code>, or <code>-1</code> if no such character occurs at or before position <code>from_index</code>.  <a href="classstring__constraint__generatort.html#a0e6c1bac62761c6fdab0d5a12f9d3d71">More...</a><br /></td></tr>
<tr class="separator:a0e6c1bac62761c6fdab0d5a12f9d3d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca07d170bbcfcd740a32f30c16ed005"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#abca07d170bbcfcd740a32f30c16ed005">add_axioms_for_last_index_of</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:abca07d170bbcfcd740a32f30c16ed005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the last occurence of a target inside the string.  <a href="classstring__constraint__generatort.html#abca07d170bbcfcd740a32f30c16ed005">More...</a><br /></td></tr>
<tr class="separator:abca07d170bbcfcd740a32f30c16ed005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac236732228bb23fad6099e9226ec5c3a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ac236732228bb23fad6099e9226ec5c3a">add_axioms_for_string_of_float</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:ac236732228bb23fad6099e9226ec5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of a float value.  <a href="classstring__constraint__generatort.html#ac236732228bb23fad6099e9226ec5c3a">More...</a><br /></td></tr>
<tr class="separator:ac236732228bb23fad6099e9226ec5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a76f3f35923c8136086a03fee1eed3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a33a76f3f35923c8136086a03fee1eed3">add_axioms_for_string_of_float</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a33a76f3f35923c8136086a03fee1eed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding to the integer part of m, in decimal form with no leading zeroes, followed by '.  <a href="classstring__constraint__generatort.html#a33a76f3f35923c8136086a03fee1eed3">More...</a><br /></td></tr>
<tr class="separator:a33a76f3f35923c8136086a03fee1eed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4852b7eda110374dbf24a4efaaa682f9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a4852b7eda110374dbf24a4efaaa682f9">add_axioms_for_fractional_part</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;int_expr, size_t max_size)</td></tr>
<tr class="memdesc:a4852b7eda110374dbf24a4efaaa682f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms for representing the fractional part of a floating point starting with a dot.  <a href="classstring__constraint__generatort.html#a4852b7eda110374dbf24a4efaaa682f9">More...</a><br /></td></tr>
<tr class="separator:a4852b7eda110374dbf24a4efaaa682f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe967436462fe6f89f09ebf821b7e855"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#abe967436462fe6f89f09ebf821b7e855">add_axioms_from_float_scientific_notation</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;f)</td></tr>
<tr class="memdesc:abe967436462fe6f89f09ebf821b7e855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms to write the float in scientific notation.  <a href="classstring__constraint__generatort.html#abe967436462fe6f89f09ebf821b7e855">More...</a><br /></td></tr>
<tr class="separator:abe967436462fe6f89f09ebf821b7e855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3387be3da9e60de90e7c4d5d15fced70"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a3387be3da9e60de90e7c4d5d15fced70">add_axioms_from_float_scientific_notation</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a3387be3da9e60de90e7c4d5d15fced70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a float value in scientific notation.  <a href="classstring__constraint__generatort.html#a3387be3da9e60de90e7c4d5d15fced70">More...</a><br /></td></tr>
<tr class="separator:a3387be3da9e60de90e7c4d5d15fced70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a2c4968d9282839ff169963daf8f7f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a13a2c4968d9282839ff169963daf8f7f">add_axioms_from_double</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a13a2c4968d9282839ff169963daf8f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding to the String.valueOf(D) java function.  <a href="classstring__constraint__generatort.html#a13a2c4968d9282839ff169963daf8f7f">More...</a><br /></td></tr>
<tr class="separator:a13a2c4968d9282839ff169963daf8f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f337a6e1697edc8c6db192243084a0a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a7f337a6e1697edc8c6db192243084a0a">add_axioms_for_replace</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a7f337a6e1697edc8c6db192243084a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a character by another in a string.  <a href="classstring__constraint__generatort.html#a7f337a6e1697edc8c6db192243084a0a">More...</a><br /></td></tr>
<tr class="separator:a7f337a6e1697edc8c6db192243084a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef6ab647296c131587157505d4edbb3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a6ef6ab647296c131587157505d4edbb3">add_axioms_for_set_length</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a6ef6ab647296c131587157505d4edbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce or extend a string to have the given length.  <a href="classstring__constraint__generatort.html#a6ef6ab647296c131587157505d4edbb3">More...</a><br /></td></tr>
<tr class="separator:a6ef6ab647296c131587157505d4edbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2475b77a57063fba2674ab5e5bc70114"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a2475b77a57063fba2674ab5e5bc70114">add_axioms_for_substring</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const <a class="el" href="classexprt.html">exprt</a> &amp;start, const <a class="el" href="classexprt.html">exprt</a> &amp;end)</td></tr>
<tr class="memdesc:a2475b77a57063fba2674ab5e5bc70114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms ensuring that <code>res</code> corresponds to the substring of <code>str</code> between indexes &lsquo;start&rsquo; = max(start, 0)<code>and </code>end' = max(min(end, |str|), start')`.  <a href="classstring__constraint__generatort.html#a2475b77a57063fba2674ab5e5bc70114">More...</a><br /></td></tr>
<tr class="separator:a2475b77a57063fba2674ab5e5bc70114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9251d46e59b15892d46a08224fff35cf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a9251d46e59b15892d46a08224fff35cf">add_axioms_for_substring</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a9251d46e59b15892d46a08224fff35cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substring of a string between two indices.  <a href="classstring__constraint__generatort.html#a9251d46e59b15892d46a08224fff35cf">More...</a><br /></td></tr>
<tr class="separator:a9251d46e59b15892d46a08224fff35cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d74444fe41524a7528a40dad56dc52"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a77d74444fe41524a7528a40dad56dc52">add_axioms_for_trim</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a77d74444fe41524a7528a40dad56dc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove leading and trailing whitespaces.  <a href="classstring__constraint__generatort.html#a77d74444fe41524a7528a40dad56dc52">More...</a><br /></td></tr>
<tr class="separator:a77d74444fe41524a7528a40dad56dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c665dae7800f3087bd551ccdd462db5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a9c665dae7800f3087bd551ccdd462db5">add_axioms_for_code_point</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;res, const <a class="el" href="classexprt.html">exprt</a> &amp;code_point)</td></tr>
<tr class="memdesc:a9c665dae7800f3087bd551ccdd462db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add axioms for the conversion of an integer representing a java code point to a utf-16 string  <a href="classstring__constraint__generatort.html#a9c665dae7800f3087bd551ccdd462db5">More...</a><br /></td></tr>
<tr class="separator:a9c665dae7800f3087bd551ccdd462db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed27a9c357b27ea02f05d842937e0334"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#aed27a9c357b27ea02f05d842937e0334">add_axioms_for_char_literal</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:aed27a9c357b27ea02f05d842937e0334"><td class="mdescLeft">&#160;</td><td class="mdescRight">add axioms stating that the returned value is equal to the argument  <a href="classstring__constraint__generatort.html#aed27a9c357b27ea02f05d842937e0334">More...</a><br /></td></tr>
<tr class="separator:aed27a9c357b27ea02f05d842937e0334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c14c5fa6840e7a00cdd9de3666c904"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ac7c14c5fa6840e7a00cdd9de3666c904">add_axioms_for_code_point_count</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:ac7c14c5fa6840e7a00cdd9de3666c904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding the String.codePointCount java function.  <a href="classstring__constraint__generatort.html#ac7c14c5fa6840e7a00cdd9de3666c904">More...</a><br /></td></tr>
<tr class="separator:ac7c14c5fa6840e7a00cdd9de3666c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730795b5fb627c31d13f238c491af0ca"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a730795b5fb627c31d13f238c491af0ca">add_axioms_for_offset_by_code_point</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a730795b5fb627c31d13f238c491af0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms corresponding the String.offsetByCodePointCount java function.  <a href="classstring__constraint__generatort.html#a730795b5fb627c31d13f238c491af0ca">More...</a><br /></td></tr>
<tr class="separator:a730795b5fb627c31d13f238c491af0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0010264662a24079c3cfd10cc9a63b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstring__constraintst.html">string_constraintst</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a7b0010264662a24079c3cfd10cc9a63b">add_axioms_for_characters_in_integer_string</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;input_int, const <a class="el" href="classtypet.html">typet</a> &amp;type, const bool strict_formatting, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const std::size_t max_string_length, const <a class="el" href="classexprt.html">exprt</a> &amp;radix, const unsigned long radix_ul)</td></tr>
<tr class="memdesc:a7b0010264662a24079c3cfd10cc9a63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms connecting the characters in the input string to the value of the output integer.  <a href="classstring__constraint__generatort.html#a7b0010264662a24079c3cfd10cc9a63b">More...</a><br /></td></tr>
<tr class="separator:a7b0010264662a24079c3cfd10cc9a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acba8d9757a3ffb15d19fb9bbfca00c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a3acba8d9757a3ffb15d19fb9bbfca00c">get_conjuncts_for_correct_number_format</a> (const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;str, const <a class="el" href="classexprt.html">exprt</a> &amp;radix_as_char, const unsigned long radix_ul, const std::size_t max_size, const bool strict_formatting)</td></tr>
<tr class="memdesc:a3acba8d9757a3ffb15d19fb9bbfca00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add axioms making the return value true if the given string is a correct number in the given radix.  <a href="classstring__constraint__generatort.html#a3acba8d9757a3ffb15d19fb9bbfca00c">More...</a><br /></td></tr>
<tr class="separator:a3acba8d9757a3ffb15d19fb9bbfca00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b1ef8ad359acc371c5031f0e6be5e8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a81b1ef8ad359acc371c5031f0e6be5e8">add_axioms_for_parse_int</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a81b1ef8ad359acc371c5031f0e6be5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer value represented by a string.  <a href="classstring__constraint__generatort.html#a81b1ef8ad359acc371c5031f0e6be5e8">More...</a><br /></td></tr>
<tr class="separator:a81b1ef8ad359acc371c5031f0e6be5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8bffd985a8bc295cbec2c0980d9004"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a2a8bffd985a8bc295cbec2c0980d9004">add_axioms_for_is_valid_int</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a2a8bffd985a8bc295cbec2c0980d9004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a string is a valid integer, using the same rules as Java Integer.parseInt.  <a href="classstring__constraint__generatort.html#a2a8bffd985a8bc295cbec2c0980d9004">More...</a><br /></td></tr>
<tr class="separator:a2a8bffd985a8bc295cbec2c0980d9004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094b01404a1528d9d36ff8c9a90789c2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a094b01404a1528d9d36ff8c9a90789c2">add_axioms_for_compare_to</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a094b01404a1528d9d36ff8c9a90789c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of two strings.  <a href="classstring__constraint__generatort.html#a094b01404a1528d9d36ff8c9a90789c2">More...</a><br /></td></tr>
<tr class="separator:a094b01404a1528d9d36ff8c9a90789c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9476478d518d8ada2dfad0637f325d4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#af9476478d518d8ada2dfad0637f325d4">combine_results</a> (std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; result1, std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; result2)</td></tr>
<tr class="memdesc:af9476478d518d8ada2dfad0637f325d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine the results of two <code>add_axioms</code> function by taking the maximum of the return codes and merging the constraints.  <a href="classstring__constraint__generatort.html#af9476478d518d8ada2dfad0637f325d4">More...</a><br /></td></tr>
<tr class="separator:af9476478d518d8ada2dfad0637f325d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463ebb6833f663cff9b328b9a6aa9725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstring__constraint__generatort_1_1parseint__argumentst.html">parseint_argumentst</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a463ebb6833f663cff9b328b9a6aa9725">unpack_parseint_arguments</a> (const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f, const <a class="el" href="classtypet.html">typet</a> &amp;target_int_type)</td></tr>
<tr class="separator:a463ebb6833f663cff9b328b9a6aa9725"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9e82f0132fb041dab8ab0fde8e7d058b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a9e82f0132fb041dab8ab0fde8e7d058b">fresh_symbol</a></td></tr>
<tr class="separator:a9e82f0132fb041dab8ab0fde8e7d058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70d89f9389fcba1081cfbc21ad6bec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray__poolt.html">array_poolt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#ab70d89f9389fcba1081cfbc21ad6bec8">array_pool</a></td></tr>
<tr class="separator:ab70d89f9389fcba1081cfbc21ad6bec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d98127ced7c40a9d10b4bb00b3b78dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classnamespacet.html">namespacet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a3d98127ced7c40a9d10b4bb00b3b78dd">ns</a></td></tr>
<tr class="separator:a3d98127ced7c40a9d10b4bb00b3b78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1995ed885db0f10d2dac7091cc72d1e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a1995ed885db0f10d2dac7091cc72d1e9">associate_array_to_pointer</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;return_code, const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a1995ed885db0f10d2dac7091cc72d1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a char array to a char pointer.  <a href="classstring__constraint__generatort.html#a1995ed885db0f10d2dac7091cc72d1e9">More...</a><br /></td></tr>
<tr class="separator:a1995ed885db0f10d2dac7091cc72d1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601b0ddb1fe77c3664d6ebbdb5438f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a8601b0ddb1fe77c3664d6ebbdb5438f1">associate_length_to_array</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;return_code, const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;f)</td></tr>
<tr class="memdesc:a8601b0ddb1fe77c3664d6ebbdb5438f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an integer length to a char array.  <a href="classstring__constraint__generatort.html#a8601b0ddb1fe77c3664d6ebbdb5438f1">More...</a><br /></td></tr>
<tr class="separator:a8601b0ddb1fe77c3664d6ebbdb5438f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6068a48416be18eb0a6737fad1f34d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmessage__handlert.html">message_handlert</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstring__constraint__generatort.html#a6068a48416be18eb0a6737fad1f34d66">message_handler</a></td></tr>
<tr class="separator:a6068a48416be18eb0a6737fad1f34d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="string__constraint__generator_8h_source.html#l00047">47</a> of file <a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d76d526657f0ac5c6117abb0505180e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d76d526657f0ac5c6117abb0505180e">&#9670;&nbsp;</a></span>string_constraint_generatort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string_constraint_generatort::string_constraint_generatort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessage__handlert.html">message_handlert</a> &amp;&#160;</td>
          <td class="paramname"><em>message_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00033">33</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad2eba61dc98ff9c33d85ddc5db6c8d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eba61dc98ff9c33d85ddc5db6c8d6e">&#9670;&nbsp;</a></span>add_axioms_for_char_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_char_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Character at a given position. </p>
<p>Add axioms stating that the character of the string at position given by second argument is equal to the returned value. This axiom is \( char = str[i] \). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments string <code>str</code> and integer <code>i</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>character expression <code>char</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00386">386</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="aed27a9c357b27ea02f05d842937e0334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed27a9c357b27ea02f05d842937e0334">&#9670;&nbsp;</a></span>add_axioms_for_char_literal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_char_literal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add axioms stating that the returned value is equal to the argument </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with one character argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new character expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00349">349</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a7b0010264662a24079c3cfd10cc9a63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0010264662a24079c3cfd10cc9a63b">&#9670;&nbsp;</a></span>add_axioms_for_characters_in_integer_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstring__constraintst.html">string_constraintst</a> string_constraint_generatort::add_axioms_for_characters_in_integer_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>input_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtypet.html">typet</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict_formatting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>max_string_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>radix_ul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms connecting the characters in the input string to the value of the output integer. </p>
<p>It is constructive because it gives a formula for input_int in terms of the characters in str. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_int</td><td>the integer represented by str </td></tr>
    <tr><td class="paramname">type</td><td>the type for input_int </td></tr>
    <tr><td class="paramname">strict_formatting</td><td>if true, don't allow a leading plus, redundant zeros or upper case letters </td></tr>
    <tr><td class="paramname">str</td><td>input string </td></tr>
    <tr><td class="paramname">max_string_length</td><td>the maximum length str can have </td></tr>
    <tr><td class="paramname">radix</td><td>the radix, with the same type as input_int </td></tr>
    <tr><td class="paramname">radix_ul</td><td>the radix as an unsigned long, or 0 if that can't be determined </td></tr>
  </table>
  </dd>
</dl>
<p>Deal with size==1 case separately. There are axioms from add_axioms_for_correct_number_format which say that the string must contain at least one digit, so we don't have to worry about "+" or "-".</p>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00373">373</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a9c665dae7800f3087bd551ccdd462db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c665dae7800f3087bd551ccdd462db5">&#9670;&nbsp;</a></span>add_axioms_for_code_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_code_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>code_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add axioms for the conversion of an integer representing a java code point to a utf-16 string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>array of characters corresponding to the result fo the function </td></tr>
    <tr><td class="paramname">code_point</td><td>an expression representing a java code point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression equal to zero </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__code__points_8cpp_source.html#l00023">23</a> of file <a class="el" href="string__constraint__generator__code__points_8cpp_source.html">string_constraint_generator_code_points.cpp</a>.</p>

</div>
</div>
<a id="ad2c9b66bdab29c6a293eb91b5b2b2fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c9b66bdab29c6a293eb91b5b2b2fd3">&#9670;&nbsp;</a></span>add_axioms_for_code_point_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_code_point_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add axioms corresponding to the String.codePointAt java function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments a string and an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a integer expression corresponding to a code point </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__code__points_8cpp_source.html#l00124">124</a> of file <a class="el" href="string__constraint__generator__code__points_8cpp_source.html">string_constraint_generator_code_points.cpp</a>.</p>

</div>
</div>
<a id="adc76888dced93da2eb9877f072e2fa06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc76888dced93da2eb9877f072e2fa06">&#9670;&nbsp;</a></span>add_axioms_for_code_point_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_code_point_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add axioms corresponding to the String.codePointBefore java function </p>
<dl class="section user"><dt>parameters: function application with two arguments: a string and an</dt><dd>index </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a integer expression corresponding to a code point </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__code__points_8cpp_source.html#l00156">156</a> of file <a class="el" href="string__constraint__generator__code__points_8cpp_source.html">string_constraint_generator_code_points.cpp</a>.</p>

</div>
</div>
<a id="ac7c14c5fa6840e7a00cdd9de3666c904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c14c5fa6840e7a00cdd9de3666c904">&#9670;&nbsp;</a></span>add_axioms_for_code_point_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_code_point_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding the String.codePointCount java function. </p>
<p>add axioms giving approximate bounds on the result of the String.codePointCount java function</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd><p class="startdd">This is Java specific and should be implemented in Java. </p>
<p class="enddd">"deprecated since " "2017" "-" "10" "-" "5" "; " "Java specific, should be implemented in Java" <br  />
 </p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with three arguments string <code>str</code>, integer <code>begin</code> and integer <code>end</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__code__points_8cpp_source.html#l00191">191</a> of file <a class="el" href="string__constraint__generator__code__points_8cpp_source.html">string_constraint_generator_code_points.cpp</a>.</p>

</div>
</div>
<a id="a094b01404a1528d9d36ff8c9a90789c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094b01404a1528d9d36ff8c9a90789c2">&#9670;&nbsp;</a></span>add_axioms_for_compare_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_compare_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lexicographic comparison of two strings. </p>
<p>Add axioms ensuring the result corresponds to that of the <code>String.compareTo</code> Java function. In the lexicographic comparison, <code>x</code> representing the first point where the two strings differ, we add axioms:</p><ul>
<li>\( res=0 \Rightarrow |s1|=|s2|\)</li>
<li>\( \forall i&lt;|s1|. s1[i]=s2[i] \)</li>
<li>\( \exists x.\ res\ne 0 \Rightarrow x &gt; 0 \land ((|s1| \ge |s2| \land x&lt;|s1|) \lor (|s1| \ge |s2| \land x&lt;|s2|) \land res=s1[x]-s2[x] ) \lor cond2: (|s1|&lt;|s2| \land x=|s1|) \lor (|s1| &gt; |s2| \land x=|s2|) \land res=|s1|-|s2|) \)</li>
<li>\( \forall i&#39;&lt;x. res\ne 0 \Rightarrow s1[i]=s2[i] \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments refined_string <code>s1</code> and refined_string <code>s2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression <code>res</code> </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__comparison_8cpp_source.html#l00209">209</a> of file <a class="el" href="string__constraint__generator__comparison_8cpp_source.html">string_constraint_generator_comparison.cpp</a>.</p>

</div>
</div>
<a id="a3674489dd834809a99bb80f9a0e731ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3674489dd834809a99bb80f9a0e731ee">&#9670;&nbsp;</a></span>add_axioms_for_concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms enforcing that <code>res</code> is equal to the concatenation of <code>s1</code> and <code>s2</code>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>should use concat_substr instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string_expression corresponding to the result </td></tr>
    <tr><td class="paramname">s1</td><td>the string expression to append to </td></tr>
    <tr><td class="paramname">s2</td><td>the string expression to append to the first one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__concatenation__builtin__function_8cpp_source.html#l00160">160</a> of file <a class="el" href="string__concatenation__builtin__function_8cpp_source.html">string_concatenation_builtin_function.cpp</a>.</p>

</div>
</div>
<a id="acda7e47e203283f726a4d156929b6550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda7e47e203283f726a4d156929b6550">&#9670;&nbsp;</a></span>add_axioms_for_concat_code_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_concat_code_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding to the StringBuilder.appendCodePoint(I) function. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>java specific </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with two arguments: a string and a code point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__concatenation__builtin__function_8cpp_source.html#l00175">175</a> of file <a class="el" href="string__concatenation__builtin__function_8cpp_source.html">string_concatenation_builtin_function.cpp</a>.</p>

</div>
</div>
<a id="a402c7629d729b29589df03b07506f8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c7629d729b29589df03b07506f8b6">&#9670;&nbsp;</a></span>add_axioms_for_concat_substr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_concat_substr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms enforcing that <code>res</code> is the concatenation of <code>s1</code> with the substring of <code>s2</code> starting at index &lsquo;start_index&rsquo;<code>and ending at index</code>end_index'&lsquo;. </p>
<p>Where start_index&rsquo; is max(0, start_index) and end_index' is max(min(end_index, s2.length), start_index') If s1.length + end_index' - start_index' is greater than the maximal integer of the type of res.length, then the result gets truncated to the size of this maximal integer.</p>
<p>These axioms are:</p><ol type="1">
<li>\(|res| = overflow ? |s_1| + end\_index&#39; - start\_index&#39; : max_int \)</li>
<li>\(\forall i&lt;|s_1|. res[i]=s_1[i] \)</li>
<li>\(\forall i&lt; |res| - |s_1|.\ res[i+|s_1|] = s_2[start\_index&#39;+i]\)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">s1</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">s2</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">start_index</td><td>integer expression </td></tr>
    <tr><td class="paramname">end_index</td><td>integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression <code>0</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__concatenation__builtin__function_8cpp_source.html#l00053">53</a> of file <a class="el" href="string__concatenation__builtin__function_8cpp_source.html">string_concatenation_builtin_function.cpp</a>.</p>

</div>
</div>
<a id="ad994ba02b8abfb1a4943d24a5693301e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad994ba02b8abfb1a4943d24a5693301e">&#9670;&nbsp;</a></span>add_axioms_for_constant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a>&#160;</td>
          <td class="paramname"><em>sval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>guard</em> = <code><a class="el" href="classtrue__exprt.html">true_exprt</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms ensuring that the provided string expression and constant are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>array of characters for the result </td></tr>
    <tr><td class="paramname">sval</td><td>a string constant </td></tr>
    <tr><td class="paramname">guard</td><td>condition under which the axiom should apply, true by default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression equal to zero </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__constants_8cpp_source.html#l00024">24</a> of file <a class="el" href="string__constraint__generator__constants_8cpp_source.html">string_constraint_generator_constants.cpp</a>.</p>

</div>
</div>
<a id="a4e22cd1139cd1d5d762e11aa3c7661e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e22cd1139cd1d5d762e11aa3c7661e9">&#9670;&nbsp;</a></span>add_axioms_for_constrain_characters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_constrain_characters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms to ensure all characters of a string belong to a given set. </p>
<p>The axiom is: \(\forall i \in [start, end).\ s[i] \in char_set \), where <code>char_set</code> is given by the string <code>char_set_string</code> composed of three characters <code>low_char</code>, <code>-</code> and <code>high_char</code>. Character <code>c</code> belongs to <code>char_set</code> if \(low_char \le c \le high_char\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function application with arguments: integer <code>|s|</code>, character pointer <code>&amp;s[0]</code>, string <code>char_set_string</code>, optional integers <code>start</code> and <code>end</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression whose value is zero </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00163">163</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a947bfc18e507ae29f4c9c24c849008da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947bfc18e507ae29f4c9c24c849008da">&#9670;&nbsp;</a></span>add_axioms_for_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a string contains another. </p>
<p>Add axioms ensuring the returned value is true when the first string contains the second. These axioms are:</p><ol type="1">
<li>\( contains \Rightarrow |s_0| \ge |s_1| \)</li>
<li>\( contains \Rightarrow 0 \le startpos \le |s_0|-|s_1| \)</li>
<li>\( !contains \Rightarrow startpos = -1 \)</li>
<li>\( \forall qvar &lt; |s_1|.\ contains \Rightarrow s_1[qvar] = s_0[startpos + qvar] \)</li>
<li>\( \forall startpos \le |s_0|-|s_1|. \ (!contains \land |s_0| \ge |s_1|) \Rightarrow \exists witness &lt; |s_1|. \ s_1[witness] \ne s_0[startpos+witness] \) <dl class="section warning"><dt>Warning</dt><dd>slow for target longer than one character </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments refined_string <code>s0</code> refined_string <code>s1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean expression <code>contains</code> </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__testing_8cpp_source.html#l00250">250</a> of file <a class="el" href="string__constraint__generator__testing_8cpp_source.html">string_constraint_generator_testing.cpp</a>.</p>

</div>
</div>
<a id="abead2cc0925faf55fdd8d52c62006a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abead2cc0925faf55fdd8d52c62006a40">&#9670;&nbsp;</a></span>add_axioms_for_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add axioms to say that the returned string expression is equal to the argument of the function application </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>should use substring instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with one argument, which is a string, or three arguments: string, integer offset and count </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string expression </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>"deprecated since " "2017" "-" "10" "-" "5" "; " "should use substring instead" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00310">310</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a416a0fccb9f643409938e89ae94d4f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416a0fccb9f643409938e89ae94d4f90">&#9670;&nbsp;</a></span>add_axioms_for_cprover_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_cprover_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>guard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an expression of type <a class="el" href="classstring__typet.html" title="String type.">string_typet</a> to a string_exprt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression for the result </td></tr>
    <tr><td class="paramname">arg</td><td>expression of type string typet </td></tr>
    <tr><td class="paramname">guard</td><td>condition under which <code>res</code> should be equal to arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if constraints were added, 1 if expression could not be handled and no constraint was added. Expression we can handle are of the form \( e := &quot;&lt;string constant&gt;&quot; | (expr)? e : e \) </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__constants_8cpp_source.html#l00083">83</a> of file <a class="el" href="string__constraint__generator__constants_8cpp_source.html">string_constraint_generator_constants.cpp</a>.</p>

</div>
</div>
<a id="a0d779359dc86a94838a4294e56a5fc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d779359dc86a94838a4294e56a5fc54">&#9670;&nbsp;</a></span>add_axioms_for_delete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that <code>res</code> corresponds to the input <code>str</code> where we removed characters between the positions <code>start</code> (included) and <code>end</code> (not included). </p>
<p>These axioms are the same as would be generated for: <code>concat(substring(str, 0, start), substring(end, |str|))</code> (see <a class="el" href="classstring__constraint__generatort.html#a2475b77a57063fba2674ab5e5bc70114">add_axioms_for_substring</a> and <a class="el" href="classstring__constraint__generatort.html#a402c7629d729b29589df03b07506f8b6">add_axioms_for_concat_substr</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>array of characters expression </td></tr>
    <tr><td class="paramname">str</td><td>array of characters expression </td></tr>
    <tr><td class="paramname">start</td><td>integer expression </td></tr>
    <tr><td class="paramname">end</td><td>integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression different from zero to signal an exception </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00383">383</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a75ba1c88b61ff22ee4e116b7462b4f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ba1c88b61ff22ee4e116b7462b4f13">&#9670;&nbsp;</a></span>add_axioms_for_delete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a portion of a string. </p>
<p>Add axioms stating that <code>res</code> corresponds to the input <code>str</code> where we removed characters between the positions <code>start</code> (included) and <code>end</code> (not included). <a class="el" href="classstring__constraint__generatort.html#a0d779359dc86a94838a4294e56a5fc54">(More...) </a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments integer <code>|res|</code>, character pointer <code>&amp;res[0]</code>, refined_string <code>str</code>, integer <code>start</code> and integer <code>end</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression whose value is different from 0 to signal an exception </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00418">418</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="adfc6adc2f407642a14c8c5ce644572d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc6adc2f407642a14c8c5ce644572d9">&#9670;&nbsp;</a></span>add_axioms_for_delete_char_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_delete_char_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add axioms corresponding to the StringBuilder.deleteCharAt java function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with two arguments, the first is a string and the second is an index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression whose value is non null to signal an exception </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00356">356</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a0532aa59baecb3935d1acbb0466639c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0532aa59baecb3935d1acbb0466639c9">&#9670;&nbsp;</a></span>add_axioms_for_empty_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_empty_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms to say that the returned string expression is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments integer <code>length</code> and character pointer <code>ptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression equal to zero </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__constants_8cpp_source.html#l00064">64</a> of file <a class="el" href="string__constraint__generator__constants_8cpp_source.html">string_constraint_generator_constants.cpp</a>.</p>

</div>
</div>
<a id="a2564a8557294c2a97adc17eaac4faaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2564a8557294c2a97adc17eaac4faaa9">&#9670;&nbsp;</a></span>add_axioms_for_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality of the content of two strings. </p>
<p>Add axioms stating that the result is true exactly when the strings represented by the arguments are equal. These axioms are:</p><ol type="1">
<li>\( eq \Rightarrow |s_1|=|s_2|\)</li>
<li>\( \forall i&lt;|s_1|.\ eq \Rightarrow s_1[i]=s_2[i] \)</li>
<li>\( \lnot eq \Rightarrow (|s_1| \ne |s_2| \land witness=-1) \lor (0 \le witness&lt;|s_1| \land s_1[witness] \ne s_2[witness]) \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments refined_string <code>s1</code> and refined_string <code>s2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean expression <code>eq</code> </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__comparison_8cpp_source.html#l00031">31</a> of file <a class="el" href="string__constraint__generator__comparison_8cpp_source.html">string_constraint_generator_comparison.cpp</a>.</p>

</div>
</div>
<a id="a098d449152e6871936586b8f3ef911f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098d449152e6871936586b8f3ef911f0">&#9670;&nbsp;</a></span>add_axioms_for_equals_ignore_case()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_equals_ignore_case </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality of the content ignoring case of characters. </p>
<p>Add axioms ensuring the result is true when the two strings are equal if case is ignored. These axioms are:</p><ol type="1">
<li>\( eq \Rightarrow |s_1|=|s_2|\)</li>
<li>\( \forall i \in [0, |s_1|). \ eq \Rightarrow {\tt equal\_ignore\_case}(s_1[i],s_2[i]) \)</li>
<li>\( \lnot eq \Rightarrow |s_1| \ne |s_2| \lor (0 \le witness&lt;|s_1| \land\lnot {\tt equal\_ignore\_case}(s_1[witness],s_2[witness]) \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments refined_string <code>s1</code> and refined_string <code>s2</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean expression <code>eq</code> </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__comparison_8cpp_source.html#l00136">136</a> of file <a class="el" href="string__constraint__generator__comparison_8cpp_source.html">string_constraint_generator_comparison.cpp</a>.</p>

</div>
</div>
<a id="a4852b7eda110374dbf24a4efaaa682f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4852b7eda110374dbf24a4efaaa682f9">&#9670;&nbsp;</a></span>add_axioms_for_fractional_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_fractional_part </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>int_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms for representing the fractional part of a floating point starting with a dot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression for the result </td></tr>
    <tr><td class="paramname">int_expr</td><td>an integer expression </td></tr>
    <tr><td class="paramname">max_size</td><td>a maximal size for the string, this includes the potential minus sign and therefore should be greater than 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__float_8cpp_source.html#l00245">245</a> of file <a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a>.</p>

</div>
</div>
<a id="a52c001afbc2aff0e1b11dda5e2fdc930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c001afbc2aff0e1b11dda5e2fdc930">&#9670;&nbsp;</a></span>add_axioms_for_function_application()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_function_application </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>strings contained in this call are converted to objects of type <code>string_exprt</code>, through adding axioms. </p>
<p>Axioms are then added to enforce that the result corresponds to the function application. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>an expression containing a function application </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to the result of the function application </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00213">213</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a4be3f98b3ca1c9f53a9cf99050aa16ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be3f98b3ca1c9f53a9cf99050aa16ad">&#9670;&nbsp;</a></span>add_axioms_for_index_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>from_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned value is the index within <code>haystack</code> (<code>str</code>) of the first occurrence of <code>needle</code> (<code>c</code>) starting the search at <code>from_index</code>, or is <code>-1</code> if no such character occurs at or after position <code>from_index</code>. </p>
<p>These axioms are:</p><ol type="1">
<li>\(-1 \le {\tt index} &lt; |{\tt haystack}| \)</li>
<li>\( \lnot contains \Leftrightarrow {\tt index} = -1 \)</li>
<li>\( contains \Rightarrow {\tt from\_index} \le {\tt index} \land {\tt haystack}[{\tt index}] = {\tt needle} \)</li>
<li>\( \forall i \in [{\tt from\_index}, {\tt index}).\ contains \Rightarrow {\tt haystack}[i] \ne {\tt needle} \)</li>
<li>\( \forall m, n \in [{\tt from\_index}, |{\tt haystack}|) .\ \lnot contains \Rightarrow {\tt haystack}[m] \ne {\tt needle} \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">c</td><td>a character expression </td></tr>
    <tr><td class="paramname">from_index</td><td>an integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression <code>index</code> </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__indexof_8cpp_source.html#l00041">41</a> of file <a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a>.</p>

</div>
</div>
<a id="aceef0bfde58d9441a98c748db3107523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceef0bfde58d9441a98c748db3107523">&#9670;&nbsp;</a></span>add_axioms_for_index_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the first occurence of a target inside the string. </p>
<p>If the target is a character: Add axioms stating that the returned value is the index within <code>haystack</code> (<code>str</code>) of the first occurrence of <code>needle</code> (<code>c</code>) starting the search at <code>from_index</code>, or is <code>-1</code> if no such character occurs at or after position <code>from_index</code>. <a class="el" href="classstring__constraint__generatort.html#a4be3f98b3ca1c9f53a9cf99050aa16ad">(More...) </a></p>
<p>If the target is a refined_string: Add axioms stating that the returned value <code>index</code> is the index within <code>haystack</code> of the first occurrence of <code>needle</code> starting the search at <code>from_index</code>, or <code>-1</code> if needle does not occur at or after position <code>from_index</code>. <a class="el" href="classstring__constraint__generatort.html#a9669615d02a4d7aca9c7c49913bc0975">(More...) </a> </p><dl class="section warning"><dt>Warning</dt><dd>slow for string targets </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments refined_string <code>haystack</code>, refined_string or character <code>needle</code>, and optional integer <code>from_index</code> with default value <code>0</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__indexof_8cpp_source.html#l00309">309</a> of file <a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a>.</p>

</div>
</div>
<a id="a9669615d02a4d7aca9c7c49913bc0975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9669615d02a4d7aca9c7c49913bc0975">&#9670;&nbsp;</a></span>add_axioms_for_index_of_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_index_of_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>from_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned value <code>index</code> is the index within <code>haystack</code> of the first occurrence of <code>needle</code> starting the search at <code>from_index</code>, or <code>-1</code> if needle does not occur at or after position <code>from_index</code>. </p>
<p>If needle is an empty string then the result is <code>from_index</code>.</p>
<p>These axioms are:</p><ol type="1">
<li>\( contains \Rightarrow {\tt from\_index} \le \tt{index} \le |{\tt haystack}|-|{\tt needle} | \)</li>
<li>\( \lnot contains \Leftrightarrow {\tt index} = -1 \)</li>
<li>\( \forall n \in [0,|{\tt needle}|).\ contains \Rightarrow {\tt haystack}[n + {\tt index}] = {\tt needle}[n] \)</li>
<li>\( \forall n \in [{\tt from\_index}, {\tt index}).\ contains \Rightarrow (\exists m \in [0,|{\tt needle}|).\ {\tt haystack}[m+n] \ne {\tt needle}[m]]) \)</li>
<li>\( \forall n \in [{\tt from\_index},|{\tt haystack}|-|{\tt needle}|] .\ \lnot contains \Rightarrow (\exists m \in [0,|{\tt needle}|) .\ {\tt haystack}[m+n] \ne {\tt needle}[m]) \)</li>
<li>\( |{\tt needle}| = 0 \Rightarrow \tt{index} = from_index \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>an array of character expression </td></tr>
    <tr><td class="paramname">needle</td><td>an array of character expression </td></tr>
    <tr><td class="paramname">from_index</td><td>an integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression <code>index</code> representing the first index of <code>needle</code> in <code>haystack</code> </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__indexof_8cpp_source.html#l00115">115</a> of file <a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a>.</p>

</div>
</div>
<a id="a0da1f040a145ff7802642dc6d9a90732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da1f040a145ff7802642dc6d9a90732">&#9670;&nbsp;</a></span>add_axioms_for_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a>&gt; string_constraint_generatort::add_axioms_for_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a350486d5cdf896def32bcd957e4f5167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350486d5cdf896def32bcd957e4f5167">&#9670;&nbsp;</a></span>add_axioms_for_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned value is true exactly when the argument string is empty. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>should use <code>string_length(s)==0</code> instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with a string argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Boolean expression </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>"deprecated since " "2017" "-" "10" "-" "5" "; " "should use `string_length s == 0` instead" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__testing_8cpp_source.html#l00130">130</a> of file <a class="el" href="string__constraint__generator__testing_8cpp_source.html">string_constraint_generator_testing.cpp</a>.</p>

</div>
</div>
<a id="a767cec45b3a581dfab202a481ce5809b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767cec45b3a581dfab202a481ce5809b">&#9670;&nbsp;</a></span>add_axioms_for_is_prefix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_is_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned expression is true exactly when the offset is greater or equal to 0 and the first string is a prefix of the second one, starting at position offset. </p>
<p>These axioms are:</p><ol type="1">
<li>isprefix =&gt; offset_within_bounds</li>
<li>forall qvar in [0, |prefix|). isprefix =&gt; str[qvar + offset] = prefix[qvar]</li>
<li>!isprefix =&gt; !offset_within_bounds || 0 &lt;= witness &lt; |prefix| &amp;&amp; str[witness+offset] != prefix[witness]</li>
</ol>
<p>where offset_within_bounds is: offset &gt;= 0 &amp;&amp; offset &lt;= |str| &amp;&amp; |str| - offset &gt;= |prefix|</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>an array of characters </td></tr>
    <tr><td class="paramname">str</td><td>an array of characters </td></tr>
    <tr><td class="paramname">offset</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean expression <code>isprefix</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__testing_8cpp_source.html#l00038">38</a> of file <a class="el" href="string__constraint__generator__testing_8cpp_source.html">string_constraint_generator_testing.cpp</a>.</p>

</div>
</div>
<a id="a4538b1dc0117bfc2fb8b6b86d8a9da4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4538b1dc0117bfc2fb8b6b86d8a9da4b">&#9670;&nbsp;</a></span>add_axioms_for_is_prefix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_is_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>swap_arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the target is a prefix of the string. </p>
<p>Add axioms ensuring the return value is true when the string starts with the given target. These axioms are detailed here: <a class="el" href="classstring__constraint__generatort.html#a767cec45b3a581dfab202a481ce5809b" title="Add axioms stating that the returned expression is true exactly when the offset is greater or equal t...">string_constraint_generatort::add_axioms_for_is_prefix(const array_string_exprt &amp;prefix, const array_string_exprt &amp;str, const exprt &amp;offset)</a>  </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function application with arguments refined_string <code>s0</code>, refined string <code>s1</code> and optional integer argument <code>offset</code>whose default value is 0 </td></tr>
    <tr><td class="paramname">swap_arguments</td><td>a Boolean telling whether the prefix is the second argument or the first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean expression <code>isprefix</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__testing_8cpp_source.html#l00106">106</a> of file <a class="el" href="string__constraint__generator__testing_8cpp_source.html">string_constraint_generator_testing.cpp</a>.</p>

</div>
</div>
<a id="a8ebf57bfa784209cffffd40605815658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebf57bfa784209cffffd40605815658">&#9670;&nbsp;</a></span>add_axioms_for_is_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_is_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>swap_arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the target is a suffix of the string. </p>
<p>Add axioms ensuring the return value is true when the first string ends with the given target. These axioms are:</p><ol type="1">
<li>\( \texttt{issuffix} \Rightarrow |s_0| \ge |s_1| \)</li>
<li>\( \forall i &lt;|s_1|.\ {\tt issuffix} \Rightarrow s_1[i] = s_0[i + |s_0| - |s_1|] \)</li>
<li>\( \lnot {\tt issuffix} \Rightarrow (|s_1| &gt; |s_0| \land {\tt witness}=-1) \lor (|s_1| &gt; {witness} \ge 0 \land s_1[{witness}] \ne s_0[{witness} + |s_0| - |s_1|] \)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function application with arguments refined_string <code>s0</code> and refined_string <code>s1</code> </td></tr>
    <tr><td class="paramname">swap_arguments</td><td>boolean flag telling whether the suffix is the second argument or the first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean expression <code>issuffix</code> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd><p class="startdd">Should use <code>strings_startwith(s0, s1, s1.length - s0.length)</code>. </p>
<p class="enddd">"deprecated since " "2018" "-" "6" "-" "6" "; " "should use strings_startwith" <br  />
 </p>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__testing_8cpp_source.html#l00171">171</a> of file <a class="el" href="string__constraint__generator__testing_8cpp_source.html">string_constraint_generator_testing.cpp</a>.</p>

</div>
</div>
<a id="a2a8bffd985a8bc295cbec2c0980d9004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8bffd985a8bc295cbec2c0980d9004">&#9670;&nbsp;</a></span>add_axioms_for_is_valid_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_is_valid_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a string is a valid integer, using the same rules as Java Integer.parseInt. </p>
<p>Add axioms relating a boolean return value to being a valid integer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function application with arguments refined_string <code>str</code> and an optional integer for the radix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean expression indicating whether the string is a valid integer </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the only thing stopping us from taking longer strings with many leading zeros is the axioms for correct number format</dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00489">489</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a0e6c1bac62761c6fdab0d5a12f9d3d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6c1bac62761c6fdab0d5a12f9d3d71">&#9670;&nbsp;</a></span>add_axioms_for_last_index_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>from_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned value is the index within <code>haystack</code> (<code>str</code>) of the last occurrence of <code>needle</code> (<code>c</code>) starting the search backward at <code>from_index</code>, or <code>-1</code> if no such character occurs at or before position <code>from_index</code>. </p>
<p>These axioms are :</p><ol type="1">
<li>\( -1 \le {\tt index} \le {\tt from\_index} \land {\tt index} &lt; |{\tt haystack}| \)</li>
<li>\( {\tt index} = -1 \Leftrightarrow \lnot contains\)</li>
<li>\( contains \Rightarrow {\tt haystack}[{\tt index}] = {\tt needle} )\)</li>
<li>\( \forall n \in [{\tt index} +1, min({\tt from\_index}+1, |{\tt haystack}|)) .\ contains \Rightarrow {\tt haystack}[n] \ne {\tt needle} \)</li>
<li>\( \forall m \in [0, min({\tt from\_index}+1, |{\tt haystack}|)) .\ \lnot contains \Rightarrow {\tt haystack}[m] \ne {\tt needle}\) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">c</td><td>a character expression </td></tr>
    <tr><td class="paramname">from_index</td><td>an integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression <code>index</code> representing the last index of <code>needle</code> in <code>haystack</code> before or at <code>from_index</code>, or <code>-1</code> if there is none </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__indexof_8cpp_source.html#l00363">363</a> of file <a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a>.</p>

</div>
</div>
<a id="abca07d170bbcfcd740a32f30c16ed005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca07d170bbcfcd740a32f30c16ed005">&#9670;&nbsp;</a></span>add_axioms_for_last_index_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_last_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the last occurence of a target inside the string. </p>
<p>If the target is a character: Add axioms stating that the returned value is the index within <code>haystack</code> (<code>str</code>) of the last occurrence of <code>needle</code> (<code>c</code>) starting the search backward at <code>from_index</code>, or <code>-1</code> if no such character occurs at or before position <code>from_index</code>. <a class="el" href="classstring__constraint__generatort.html#a0e6c1bac62761c6fdab0d5a12f9d3d71">(More...) </a></p>
<p>If the target is a refined_string: Add axioms stating that the returned value is the index within haystack of the last occurrence of needle starting the search backward at from_index (ie the index is smaller or equal to from_index), or -1 if needle does not occur before from_index. <a class="el" href="classstring__constraint__generatort.html#a35c0c86497ba2cfb1665873751bdf971">(More...) </a> </p><dl class="section warning"><dt>Warning</dt><dd>slow for string targets </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments refined_string <code>haystack</code>, refined_string or character <code>needle</code>, and optional integer <code>from_index</code> with default value <code>|haystack|-1</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__indexof_8cpp_source.html#l00433">433</a> of file <a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a>.</p>

</div>
</div>
<a id="a35c0c86497ba2cfb1665873751bdf971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c0c86497ba2cfb1665873751bdf971">&#9670;&nbsp;</a></span>add_axioms_for_last_index_of_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_last_index_of_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>from_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned value is the index within haystack of the last occurrence of needle starting the search backward at from_index (ie the index is smaller or equal to from_index), or -1 if needle does not occur before from_index. </p>
<p>If <code>needle</code> is the empty string, the result is <code>from_index</code>.</p>
<p>These axioms are:</p><ol type="1">
<li>\( contains \Rightarrow -1 \le {\tt index} \land {\tt index} \le {\tt from\_index} \land {\tt index} \le |{\tt haystack}| - |{\tt needle}| \)</li>
<li>\( \lnot contains \Leftrightarrow {\tt index}= -1 \)</li>
<li>\( \forall n \in [0, |{\tt needle}|).\ contains \Rightarrow {\tt haystack}[n+{\tt index}] = {\tt needle}[n] \)</li>
<li>\( \forall n \in [{\tt index}+1, min({\tt from\_index}, |{\tt haystack}| - |{\tt needle}|)] .\ contains \Rightarrow (\exists m \in [0,|{\tt needle}|) .\ {\tt haystack}[m+n] \ne {\tt needle}[m]]) \)</li>
<li>\( \forall n \in [0, min({\tt from\_index}, |{\tt haystack}| - |{\tt needle}|)] .\ \lnot contains \Rightarrow (\exists m \in [0,|{\tt needle}|) .\ {\tt haystack}[m+n] \ne {\tt needle}[m]) \)</li>
<li>\( |{\tt needle}| = 0 \Rightarrow index = from_index \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">needle</td><td>an array of characters expression </td></tr>
    <tr><td class="paramname">from_index</td><td>integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression <code>index</code> representing the last index of <code>needle</code> in <code>haystack</code> before or at <code>from_index</code>, or -1 if there is none </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__indexof_8cpp_source.html#l00216">216</a> of file <a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a>.</p>

</div>
</div>
<a id="ae0ab1148baaf52c82aeb389c764704ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ab1148baaf52c82aeb389c764704ec">&#9670;&nbsp;</a></span>add_axioms_for_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of a string. </p>
<p>Returns the length of the string argument of the given function application </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with argument string <code>str</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression <code>|str|</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00330">330</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a730795b5fb627c31d13f238c491af0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730795b5fb627c31d13f238c491af0ca">&#9670;&nbsp;</a></span>add_axioms_for_offset_by_code_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_offset_by_code_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding the String.offsetByCodePointCount java function. </p>
<p>add axioms giving approximate bounds on the result of the String.offsetByCodePointCount java function.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd><p class="startdd">This is Java specific and should be implemented in Java. </p>
<p class="enddd">"deprecated since " "2017" "-" "10" "-" "5" "; " "Java specific, should be implemented in Java" <br  />
 </p>
</dd></dl>
<p>We approximate the result by saying the result is between index + offset and index + 2 * offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments string <code>str</code>, integer <code>index</code> and integer <code>offset</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__code__points_8cpp_source.html#l00217">217</a> of file <a class="el" href="string__constraint__generator__code__points_8cpp_source.html">string_constraint_generator_code_points.cpp</a>.</p>

</div>
</div>
<a id="a81b1ef8ad359acc371c5031f0e6be5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b1ef8ad359acc371c5031f0e6be5e8">&#9670;&nbsp;</a></span>add_axioms_for_parse_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_parse_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer value represented by a string. </p>
<p>Add axioms ensuring the value of the returned integer corresponds to the value represented by <code>str</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function application with arguments refined_string <code>str</code> and an optional integer for the radix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression equal to the value represented by <code>str</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00525">525</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a7f337a6e1697edc8c6db192243084a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f337a6e1697edc8c6db192243084a0a">&#9670;&nbsp;</a></span>add_axioms_for_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a character by another in a string. </p>
<p>Add axioms ensuring that <code>res</code> corresponds to <code>str</code> where occurences of <code>old_char</code> have been replaced by <code>new_char</code>. These axioms are:</p><ol type="1">
<li>\( |{\tt res}| = |{\tt str}| \)</li>
<li>\( \forall i \in 0, |{\tt res}|) .\ {\tt str}[i]={\tt old\_char} \Rightarrow {\tt res}[i]={\tt new\_char} \land {\tt str}[i]\ne {\tt old\_char} \Rightarrow {\tt res}[i]={\tt str}[i] \) Only supports String.replace(char, char) and String.replace(String, String) for single-character strings Returns original string in every other case (that behaviour is to be fixed in the future) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments integer <code>|res|</code>, character pointer <code>&amp;res[0]</code>, refined_string <code>str</code>, character <code>old_char</code> and character <code>new_char</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression equal to 0 </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00313">313</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a6ef6ab647296c131587157505d4edbb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef6ab647296c131587157505d4edbb3">&#9670;&nbsp;</a></span>add_axioms_for_set_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_set_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce or extend a string to have the given length. </p>
<p>Add axioms ensuring the returned string expression <code>res</code> has length <code>max(k, 0)</code> and characters at position <code>i</code> in <code>res</code> are equal to the character at position <code>i</code> in <code>s1</code> if <code>i</code> is smaller that the length of <code>s1</code>, otherwise it is the null character <code>\u0000</code>. Note this means if <code>k</code> is negative then the string is truncated to length 0; in practice a wrapper function will usually handle this case.</p>
<p>These axioms are:</p><ol type="1">
<li>\( |{\tt res}|={\tt k} \)</li>
<li>\( \forall i&lt;|{\tt res}|.\ i &lt; |s_1| \Rightarrow {\tt res}[i] = s_1[i] \)</li>
<li>\( \forall i&lt;|{\tt res}|.\ i \ge |s_1| \Rightarrow {\tt res}[i] = 0 \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments integer <code>|res|</code>, character pointer <code>&amp;res[0]</code>, refined_string <code>s1</code>, integer <code>k</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression equal to <code>0</code> </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00039">39</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a33a76f3f35923c8136086a03fee1eed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a76f3f35923c8136086a03fee1eed3">&#9670;&nbsp;</a></span>add_axioms_for_string_of_float() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_string_of_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding to the integer part of m, in decimal form with no leading zeroes, followed by '. </p>
<p>', followed by one or more decimal digits representing the fractional part of m. This specification is correct for inputs that do not exceed 100000 and the function is unspecified for other values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression corresponding to the result </td></tr>
    <tr><td class="paramname">f</td><td>a float expression, which is positive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression, different from zero if an error should be raised </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__float_8cpp_source.html#l00193">193</a> of file <a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a>.</p>

</div>
</div>
<a id="ac236732228bb23fad6099e9226ec5c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac236732228bb23fad6099e9226ec5c3a">&#9670;&nbsp;</a></span>add_axioms_for_string_of_float() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_string_of_float </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String representation of a float value. </p>
<p>We currently only specify that the string for NaN is "NaN", for infinity and minus infinity the string are "Infinity" and "-Infinity respectively otherwise the string contains only characters in [0123456789.] and '-' at the start for negative number</p>
<p>Add axioms corresponding to the String.valueOf(F) java function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with one float argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__float_8cpp_source.html#l00162">162</a> of file <a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a>.</p>

</div>
</div>
<a id="a5ddef0b51489e4b1fb5f2a2d26e23f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddef0b51489e4b1fb5f2a2d26e23f5f">&#9670;&nbsp;</a></span>add_axioms_for_string_of_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_string_of_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>input_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms enforcing that the string corresponds to the result of String.valueOf(I) or String.valueOf(J) Java functions applied on the integer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression for the result </td></tr>
    <tr><td class="paramname">input_int</td><td>a signed integer expression </td></tr>
    <tr><td class="paramname">max_size</td><td>a maximal size for the string representation (default 0, which is interpreted to mean "as large as is needed for this type") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00117">117</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a4bd9990fc5408ebd5a5bde54533c3b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd9990fc5408ebd5a5bde54533c3b53">&#9670;&nbsp;</a></span>add_axioms_for_string_of_int_with_radix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_string_of_int_with_radix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>input_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms enforcing that the string corresponds to the result of String.valueOf(II) or String.valueOf(JI) Java functions applied on the integer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression for the result </td></tr>
    <tr><td class="paramname">input_int</td><td>a signed integer expression </td></tr>
    <tr><td class="paramname">radix</td><td>the radix to use </td></tr>
    <tr><td class="paramname">max_size</td><td>a maximal size for the string representation (default 0, which is interpreted to mean "as large as is needed for this type") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>
<p>Most of the time we can evaluate radix as an integer. The value 0 is used to indicate when we can't tell what the radix is.</p>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00137">137</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a2475b77a57063fba2674ab5e5bc70114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2475b77a57063fba2674ab5e5bc70114">&#9670;&nbsp;</a></span>add_axioms_for_substring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_substring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms ensuring that <code>res</code> corresponds to the substring of <code>str</code> between indexes &lsquo;start&rsquo; = max(start, 0)<code>and </code>end' = max(min(end, |str|), start')`. </p>
<p>An actual java program should throw an exception in that case.</p>
<p>These axioms are:</p><ol type="1">
<li>\( |{\tt res}| = end&#39; - start&#39; \)</li>
<li>\( \forall i&lt;|{\tt res}|.\ {\tt res}[i]={\tt str}[{\tt start&#39;}+i] \) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>array of characters expression </td></tr>
    <tr><td class="paramname">str</td><td>array of characters expression </td></tr>
    <tr><td class="paramname">start</td><td>integer expression </td></tr>
    <tr><td class="paramname">end</td><td>integer expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression equal to zero </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00124">124</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a9251d46e59b15892d46a08224fff35cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9251d46e59b15892d46a08224fff35cf">&#9670;&nbsp;</a></span>add_axioms_for_substring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_substring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substring of a string between two indices. </p>
<p>Add axioms ensuring that <code>res</code> corresponds to the substring of <code>str</code> between indexes &lsquo;start&rsquo; = max(start, 0)<code>and </code>end' = max(min(end, |str|), start')`. <a class="el" href="classstring__constraint__generatort.html#a2475b77a57063fba2674ab5e5bc70114">(More...) </a> </p><dl class="section warning"><dt>Warning</dt><dd>The specification may not be correct for the case where the string is shorter than the end index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments integer <code>|res|</code>, character pointer <code>&amp;res[0]</code>, refined_string <code>str</code>, integer <code>start</code>, optional integer <code>end</code> with default value <code>|str|</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression which is different from 0 when there is an exception to signal </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00096">96</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a77d74444fe41524a7528a40dad56dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d74444fe41524a7528a40dad56dc52">&#9670;&nbsp;</a></span>add_axioms_for_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_for_trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove leading and trailing whitespaces. </p>
<p>Add axioms ensuring <code>res</code> corresponds to <code>str</code> from which leading and trailing whitespaces have been removed. Are considered whitespaces, characters whose ascii code are smaller than that of ' ' (space).</p>
<p>These axioms are:</p><ol type="1">
<li>\( idx + |{\tt res}| \le |{\tt str}| \) where <code>idx</code> represents the index of the first non-space character.</li>
<li>\( idx \ge 0 \)</li>
<li>\( |{\tt str}| \ge idx \)</li>
<li>\( |{\tt res}| \ge 0 \)</li>
<li>\( |{\tt res}| \le |{\tt str}| \) (this is necessary to prevent exceeding the biggest integer)</li>
<li>\( \forall n&lt;m.\ {\tt str}[n] \le \lq~\rq \)</li>
<li>\( \forall n&lt;|{\tt str}|-m-|{\tt res}|.\ {\tt str}[m+|{\tt res}|+n] \le \lq~\rq \)</li>
<li>\( \forall n&lt;|{\tt res}|.\ {\tt str}[idx+n]={\tt res}[n] \)</li>
<li>\( (s[m]&gt;{\tt \lq~\rq} \land s[m+|{\tt res}|-1]&gt;{\tt \lq~\rq}) \lor m=|{\tt res}| \) <dl class="section note"><dt>Note</dt><dd>Some of the constraints among 1, 2, 3, 4 and 5 seems to be redundant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with arguments integer <code>|res|</code>, character pointer <code>&amp;res[0]</code>, refined_string <code>str</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer expression which is different from 0 when there is an exception to signal </dd></dl>
</li>
</ol>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__transformation_8cpp_source.html#l00183">183</a> of file <a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a>.</p>

</div>
</div>
<a id="a23e9c75993a489ae8aa6823b201d0d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e9c75993a489ae8aa6823b201d0d9c">&#9670;&nbsp;</a></span>add_axioms_from_bool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_bool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the returned string equals "true" when the Boolean expression is true and "false" when it is false. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>This is Java specific and should be implemented in Java instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression for the result </td></tr>
    <tr><td class="paramname">b</td><td>Boolean expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>"deprecated since " "2017" "-" "10" "-" "5" "; " "Java specific, should be implemented in Java" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00065">65</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a987b8a4d5b208d2ddde4dda64e86de5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987b8a4d5b208d2ddde4dda64e86de5e">&#9670;&nbsp;</a></span>add_axioms_from_bool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a>&gt; string_constraint_generatort::add_axioms_from_bool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9c5a88af3afbc33d27254c021b77e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c5a88af3afbc33d27254c021b77e1d">&#9670;&nbsp;</a></span>add_axioms_from_char() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a>&gt; string_constraint_generatort::add_axioms_from_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24c2ef64693eafc6bd58b2c0b11154ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c2ef64693eafc6bd58b2c0b11154ca">&#9670;&nbsp;</a></span>add_axioms_from_char() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a>&gt; string_constraint_generatort::add_axioms_from_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13a2c4968d9282839ff169963daf8f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a2c4968d9282839ff169963daf8f7f">&#9670;&nbsp;</a></span>add_axioms_from_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_double </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding to the String.valueOf(D) java function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with one double argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__float_8cpp_source.html#l00174">174</a> of file <a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a>.</p>

</div>
</div>
<a id="abe967436462fe6f89f09ebf821b7e855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe967436462fe6f89f09ebf821b7e855">&#9670;&nbsp;</a></span>add_axioms_from_float_scientific_notation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_float_scientific_notation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>float_expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms to write the float in scientific notation. </p>
<p>A float is represented as \(f = m * 2^e\) where \(0 &lt;= m &lt; 2\) is the significand and \(-126 &lt;= e &lt;= 127\) is the exponent. We want an alternate representation by finding \(n\) and \(d\) such that \(f=n*10^d\). We can estimate \(d\) the following way: \(d ~= log_10(f/n) ~= log_10(m) + log_10(2) * e - log_10(n)\) \(d = floor(log_10(2) * e)\) Then \(n\) can be expressed by the equation: \(log_10(n) = log_10(m) + log_10(2) * e - d\) \(n = f / 10^d = m * 2^e / 10^d = m * 2^e / 10^(floor(log_10(2) * e))\) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression representing the float in scientific notation </td></tr>
    <tr><td class="paramname">float_expr</td><td>a float expression, which is positive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a integer expression different from 0 to signal an exception </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__float_8cpp_source.html#l00338">338</a> of file <a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a>.</p>

</div>
</div>
<a id="a3387be3da9e60de90e7c4d5d15fced70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3387be3da9e60de90e7c4d5d15fced70">&#9670;&nbsp;</a></span>add_axioms_from_float_scientific_notation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_float_scientific_notation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Representation of a float value in scientific notation. </p>
<p>Add axioms corresponding to the scientific representation of floating point values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a function application expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__float_8cpp_source.html#l00528">528</a> of file <a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a>.</p>

</div>
</div>
<a id="a32a6c4899bb450b7428e1d61ad7fc3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a6c4899bb450b7428e1d61ad7fc3a4">&#9670;&nbsp;</a></span>add_axioms_from_int_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_int_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms stating that the string <code>res</code> corresponds to the integer argument written in hexadecimal. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>use add_axioms_from_int_with_radix instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>string expression for the result </td></tr>
    <tr><td class="paramname">i</td><td>an integer argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>"deprecated since " "2017" "-" "10" "-" "5" "; " "use add_axioms_for_string_of_int_with_radix" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00200">200</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="aa9549205227b3ca2e68004bccacb99ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9549205227b3ca2e68004bccacb99ee">&#9670;&nbsp;</a></span>add_axioms_from_int_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_int_hex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding to the Integer.toHexString(I) java function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with an integer argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code 0 on success </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00259">259</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a8aab0f9856ebd30a24a8e08214f5c9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aab0f9856ebd30a24a8e08214f5c9a2">&#9670;&nbsp;</a></span>add_axioms_from_literal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_literal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String corresponding to an internal cprover string. </p>
<p>Add axioms ensuring that the returned string expression is equal to the string literal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with an argument which is a string literal that is a constant with a string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__constants_8cpp_source.html#l00111">111</a> of file <a class="el" href="string__constraint__generator__constants_8cpp_source.html">string_constraint_generator_constants.cpp</a>.</p>

</div>
</div>
<a id="ac77a8d580b71b6b3916b74d0392edc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77a8d580b71b6b3916b74d0392edc3b">&#9670;&nbsp;</a></span>add_axioms_from_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::add_axioms_from_long </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms corresponding to the String.valueOf(J) java function. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>should use add_axioms_from_int instead </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function application with one long argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string expression </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>"deprecated since " "2017" "-" "10" "-" "5" "; " "use add_axioms_for_string_of_int instead" <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00044">44</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a9f30b5a42a21de03eaa7cc3f2cea5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f30b5a42a21de03eaa7cc3f2cea5208">&#9670;&nbsp;</a></span>add_constraint_on_characters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstring__constraintst.html">string_constraintst</a> string_constraint_generatort::add_constraint_on_characters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>char_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraint on characters of a string. </p>
<p>This constraint is \( \forall i \in [start, end), low\_char \le s[i] \le high\_char \) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a string expression </td></tr>
    <tr><td class="paramname">start</td><td>index of the first character to constrain </td></tr>
    <tr><td class="paramname">end</td><td>index at which we stop adding constraints </td></tr>
    <tr><td class="paramname">char_set</td><td>a string of the form "&lt;low_char&gt;-&lt;high_char&gt;" where <code>&lt;low_char&gt;</code> and <code>&lt;high_char&gt;</code> are two characters, which represents the set of characters that are between <code>low_char</code> and <code>high_char</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string expression that is linked to the argument through axioms that are added to the list </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00129">129</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a1995ed885db0f10d2dac7091cc72d1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1995ed885db0f10d2dac7091cc72d1e9">&#9670;&nbsp;</a></span>associate_array_to_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexprt.html">exprt</a> string_constraint_generatort::associate_array_to_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>return_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate a char array to a char pointer. </p>
<p>Insert in <code>array_pool</code> a binding from <code>ptr</code> to <code>arr</code>. If the length of <code>arr</code> is infinite, a new integer symbol is created and stored in <code>array_pool</code>. This also adds the default axioms for <code>arr</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_code</td><td>expression which is assigned the result of the function </td></tr>
    <tr><td class="paramname">f</td><td>a function application with argument a character array <code>arr</code> and a character pointer <code>ptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constraint </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00063">63</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a8601b0ddb1fe77c3664d6ebbdb5438f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8601b0ddb1fe77c3664d6ebbdb5438f1">&#9670;&nbsp;</a></span>associate_length_to_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexprt.html">exprt</a> string_constraint_generatort::associate_length_to_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>return_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate an integer length to a char array. </p>
<p>This adds an axiom ensuring that <code>arr.length</code> and <code>length</code> are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_code</td><td>expression which is assigned the result of the function </td></tr>
    <tr><td class="paramname">f</td><td>a function application with argument a character array <code>arr</code> and an integer <code>length</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constraint </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00087">87</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="af9476478d518d8ada2dfad0637f325d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9476478d518d8ada2dfad0637f325d4">&#9670;&nbsp;</a></span>combine_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt; string_constraint_generatort::combine_results </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td>
          <td class="paramname"><em>result1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="structstring__constraintst.html">string_constraintst</a> &gt;&#160;</td>
          <td class="paramname"><em>result2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine the results of two <code>add_axioms</code> function by taking the maximum of the return codes and merging the constraints. </p>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00419">419</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a3acba8d9757a3ffb15d19fb9bbfca00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acba8d9757a3ffb15d19fb9bbfca00c">&#9670;&nbsp;</a></span>get_conjuncts_for_correct_number_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; string_constraint_generatort::get_conjuncts_for_correct_number_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>radix_as_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>radix_ul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict_formatting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add axioms making the return value true if the given string is a correct number in the given radix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string expression </td></tr>
    <tr><td class="paramname">radix_as_char</td><td>the radix as an expression of the same type as the characters in str </td></tr>
    <tr><td class="paramname">radix_ul</td><td>the radix, which should be between 2 and 36, or 0, in which case the return value will work for any radix </td></tr>
    <tr><td class="paramname">max_size</td><td>maximum number of characters </td></tr>
    <tr><td class="paramname">strict_formatting</td><td>if true, don't allow a leading plus, redundant zeros or upper case letters </td></tr>
  </table>
  </dd>
</dl>
<p>index &lt; length =&gt; is_digit_with_radix(str[index], radix)</p>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00279">279</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<a id="a44b8f9696f68ccd9c50b5a6da6a8f8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b8f9696f68ccd9c50b5a6da6a8f8ce">&#9670;&nbsp;</a></span>make_array_pointer_association()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt; string_constraint_generatort::make_array_pointer_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>return_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate array to pointer, and array to length. </p>
<dl class="section return"><dt>Returns</dt><dd>an expression if the given function application is one of associate pointer and associate length </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__main_8cpp_source.html#l00195">195</a> of file <a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a>.</p>

</div>
</div>
<a id="a463ebb6833f663cff9b328b9a6aa9725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463ebb6833f663cff9b328b9a6aa9725">&#9670;&nbsp;</a></span>unpack_parseint_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstring__constraint__generatort_1_1parseint__argumentst.html">string_constraint_generatort::parseint_argumentst</a> string_constraint_generatort::unpack_parseint_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunction__application__exprt.html">function_application_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtypet.html">typet</a> &amp;&#160;</td>
          <td class="paramname"><em>target_int_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__constraint__generator__valueof_8cpp_source.html#l00458">458</a> of file <a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab70d89f9389fcba1081cfbc21ad6bec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70d89f9389fcba1081cfbc21ad6bec8">&#9670;&nbsp;</a></span>array_pool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray__poolt.html">array_poolt</a> string_constraint_generatort::array_pool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__constraint__generator_8h_source.html#l00063">63</a> of file <a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a>.</p>

</div>
</div>
<a id="a9e82f0132fb041dab8ab0fde8e7d058b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e82f0132fb041dab8ab0fde8e7d058b">&#9670;&nbsp;</a></span>fresh_symbol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a> string_constraint_generatort::fresh_symbol</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__constraint__generator_8h_source.html#l00061">61</a> of file <a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a>.</p>

</div>
</div>
<a id="a6068a48416be18eb0a6737fad1f34d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6068a48416be18eb0a6737fad1f34d66">&#9670;&nbsp;</a></span>message_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmessage__handlert.html">message_handlert</a>&amp; string_constraint_generatort::message_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__constraint__generator_8h_source.html#l00075">75</a> of file <a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a>.</p>

</div>
</div>
<a id="a3d98127ced7c40a9d10b4bb00b3b78dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d98127ced7c40a9d10b4bb00b3b78dd">&#9670;&nbsp;</a></span>ns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classnamespacet.html">namespacet</a> string_constraint_generatort::ns</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__constraint__generator_8h_source.html#l00065">65</a> of file <a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator_8h_source.html">string_constraint_generator.h</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__concatenation__builtin__function_8cpp_source.html">string_concatenation_builtin_function.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__code__points_8cpp_source.html">string_constraint_generator_code_points.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__comparison_8cpp_source.html">string_constraint_generator_comparison.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__constants_8cpp_source.html">string_constraint_generator_constants.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__float_8cpp_source.html">string_constraint_generator_float.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__indexof_8cpp_source.html">string_constraint_generator_indexof.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__main_8cpp_source.html">string_constraint_generator_main.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__testing_8cpp_source.html">string_constraint_generator_testing.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__transformation_8cpp_source.html">string_constraint_generator_transformation.cpp</a></li>
<li>/home/runner/work/cbmc/cbmc/src/solvers/strings/<a class="el" href="string__constraint__generator__valueof_8cpp_source.html">string_constraint_generator_valueof.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
