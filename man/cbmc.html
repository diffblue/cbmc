<h1>NAME</h1>
<p>cbmc - Bounded Model Checker for C/C++ and Java programs</p>
<h1>SYNOPSIS</h1>
<p><strong>cbmc [--property <em>property-id</em><strong>]</strong> <em>file.c</em> ...</strong></p>
<p><strong>cbmc [--show-properties] <em>file.c</em> ...</strong></p>
<p><strong>cbmc [--all-properties] <em>file.c</em> ...</strong></p>
<p><strong>goto-cc [-I <em>include-path</em><strong>]</strong> [-c] <em>file.c</em> [-o <em>outfile.o</em><strong>]</strong></strong></p>
<p><strong>goto-instrument <em>infile</em> <em>outfile</em></strong></p>
<p>Only the most useful options are listed here; see below for the remainder.</p>
<h1>DESCRIPTION</h1>
<p><strong>cbmc</strong> generates traces that demonstrate how an assertion can be violated, or proves that the assertion cannot be violated within a given number of loop iterations. CBMC can read C/C++ source-code directly, or a GOTO binary generated by goto-cc. Java programs are given as class or JAR files. Without any further options, cbmc checks all properties (automatically generated or user-specified) found in the program. If any of the properties can be violated, a counterexample is printed and the analysis is aborted. The analysis can be restricted to a particular property with the --property option. The verification result for all properties can be obtained by means of the --all-properties option.</p>
<p><strong>goto-cc</strong>(1) reads source code, and generates a GOTO binary. Its command-line interface is designed to mimic that of <strong>gcc</strong>(1). Note in particular that <strong>goto-cc</strong>(1) distinguishes between compiling and linking phases, just as gcc does. <strong>cbmc</strong> expects a GOTO binary for which linking has been completed.</p>
<p><strong>goto-instrument</strong>(1) reads a GOTO binary, performs a given program transformation, and then writes the resulting program as GOTO binary on disc.</p>
<p>The usual flow is to (1) translate source into a GOTO binary using goto-cc, then (2) perform instrumentation with goto-instrument, and finally (3) perform the analysis with cbmc.</p>
<h1>OPTIONS</h1>
<h2>Analysis options:</h2>
<dl>
<dt><strong>--show-properties</strong></dt>
<dd><p>show the properties, but don't run analysis</p>
</dd>
<dt><strong>--symex-coverage-report</strong> f</dt>
<dd><p>generate a Cobertura XML coverage report in f</p>
</dd>
<dt><strong>--property</strong> id</dt>
<dd><p>only check one specific property</p>
</dd>
<dt><strong>--trace</strong></dt>
<dd><p>give a counterexample trace for failed properties</p>
</dd>
<dt><strong>--stop-on-fail</strong></dt>
<dd><p>stop analysis once a failed property is detected (implies <strong>--trace</strong>)</p>
</dd>
<dt><strong>--localize-faults</strong></dt>
<dd><p>localize faults (experimental)</p>
</dd>
</dl>
<h2>C/C++ frontend options:</h2>
<dl>
<dt><strong>--preprocess</strong></dt>
<dd><p>stop after preprocessing</p>
</dd>
<dt><strong>--test-preprocessor</strong></dt>
<dd><p>stop after preprocessing, discard output</p>
</dd>
<dt><strong>-I</strong> path</dt>
<dd><p>set include path (C/C++)</p>
</dd>
<dt><strong>--include</strong> file</dt>
<dd><p>set include file (C/C++)</p>
</dd>
<dt><strong>-D</strong> macro</dt>
<dd><p>define preprocessor macro (C/C++)</p>
</dd>
<dt><strong>--c89</strong>, <strong>--c99</strong>, <strong>--c11</strong></dt>
<dd><p>set C language standard (default: c11)</p>
</dd>
<dt><strong>--cpp98</strong>, <strong>--cpp03</strong>, <strong>--cpp11</strong></dt>
<dd><p>set C++ language standard (default: cpp98)</p>
</dd>
<dt><strong>--unsigned-char</strong></dt>
<dd><p>make "char" unsigned by default</p>
</dd>
<dt><strong>--round-to-nearest</strong>, <strong>--round-to-even</strong></dt>
<dd><p>rounding towards nearest even (default)</p>
</dd>
<dt><strong>--round-to-plus-inf</strong></dt>
<dd><p>rounding towards plus infinity</p>
</dd>
<dt><strong>--round-to-minus-inf</strong></dt>
<dd><p>rounding towards minus infinity</p>
</dd>
<dt><strong>--round-to-zero</strong></dt>
<dd><p>rounding towards zero</p>
</dd>
<dt><strong>--no-library</strong></dt>
<dd><p>disable built-in abstract C library</p>
</dd>
<dt><strong>--max-nondet-tree-depth</strong> N</dt>
<dd><p>limit size of nondet (e.g. input) object tree; at level N pointers are set to null</p>
</dd>
<dt><strong>--min-null-tree-depth</strong> N</dt>
<dd><p>minimum level at which a pointer can first be NULL in a recursively nondet initialized struct</p>
</dd>
<dt><strong>--function</strong> name</dt>
<dd><p>set main function name</p>
</dd>
</dl>
<h2>Platform options:</h2>
<dl>
<dt><strong>--arch</strong> <em>arch</em></dt>
<dd><p>Set analysis architecture, which defaults to the host architecture. Use one of: <strong>alpha</strong>, <strong>arm</strong>, <strong>arm64</strong>, <strong>armel</strong>, <strong>armhf</strong>, <strong>hppa</strong>, <strong>i386</strong>, <strong>ia64</strong>, <strong>mips</strong>, <strong>mips64</strong>, <strong>mips64el</strong>, <strong>mipsel</strong>, <strong>mipsn32</strong>, <strong>mipsn32el</strong>, <strong>powerpc</strong>, <strong>ppc64</strong>, <strong>ppc64le</strong>, <strong>riscv64</strong>, <strong>s390</strong>, <strong>s390x</strong>, <strong>sh4</strong>, <strong>sparc</strong>, <strong>sparc64</strong>, <strong>v850</strong>, <strong>x32</strong>, <strong>x86_64</strong>, or <strong>none</strong>.</p>
</dd>
<dt><strong>--os</strong> <em>os</em></dt>
<dd><p>Set analysis operating system, which defaults to the host operating system. Use one of: <strong>freebsd</strong>, <strong>linux</strong>, <strong>macos</strong>, <strong>solaris</strong>, or <strong>windows</strong>.</p>
</dd>
<dt><strong>--i386-linux</strong>, <strong>--i386-win32</strong>, <strong>--i386-macos</strong>, <strong>--ppc-macos</strong>, <strong>--win32</strong>, <strong>--winx64</strong></dt>
<dd><p>Set analysis architecture and operating system.</p>
</dd>
<dt><strong>--LP64</strong>, <strong>--ILP64</strong>, <strong>--LLP64</strong>, <strong>--ILP32</strong>, <strong>--LP32</strong></dt>
<dd><p>Set width of int, long and pointers, but don't override default architecture and operating system.</p>
</dd>
<dt><strong>--16</strong>, <strong>--32</strong>, <strong>--64</strong></dt>
<dd><p>Equivalent to <strong>--LP32</strong>, <strong>--ILP32</strong>, <strong>--LP64</strong> (on Windows: <strong>--LLP64</strong>).</p>
</dd>
<dt><strong>--little-endian</strong></dt>
<dd><p>allow little-endian word-byte conversions</p>
</dd>
<dt><strong>--big-endian</strong></dt>
<dd><p>allow big-endian word-byte conversions</p>
</dd>
<dt><strong>--gcc</strong></dt>
<dd><p>use GCC as preprocessor</p>
</dd>
</dl>
<h2>Program representations:</h2>
<dl>
<dt><strong>--show-parse-tree</strong></dt>
<dd><p>show parse tree</p>
</dd>
<dt><strong>--show-symbol-table</strong></dt>
<dd><p>show loaded symbol table</p>
</dd>
<dt><strong>--show-goto-functions</strong></dt>
<dd><p>show loaded goto program</p>
</dd>
<dt><strong>--list-goto-functions</strong></dt>
<dd><p>list loaded goto functions</p>
</dd>
<dt><strong>--validate-goto-model</strong></dt>
<dd><p>enable additional well-formedness checks on the goto program</p>
</dd>
<dt><strong>--validate-ssa-equation</strong></dt>
<dd><p>enable additional well-formedness checks on the SSA representation</p>
</dd>
</dl>
<h2>Program instrumentation options:</h2>
<dl>
<dt><strong>--bounds-check</strong></dt>
<dd><p>enable array bounds checks</p>
</dd>
<dt><strong>--pointer-check</strong></dt>
<dd><p>enable pointer checks</p>
</dd>
<dt><strong>--memory-leak-check</strong></dt>
<dd><p>enable memory leak checks</p>
</dd>
<dt><strong>--memory-cleanup-check</strong></dt>
<dd><p>Enable memory cleanup checks: assert that all dynamically allocated memory is explicitly freed before terminating the program.</p>
</dd>
<dt><strong>--div-by-zero-check</strong></dt>
<dd><p>enable division by zero checks</p>
</dd>
<dt><strong>--signed-overflow-check</strong></dt>
<dd><p>enable signed arithmetic over- and underflow checks</p>
</dd>
<dt><strong>--unsigned-overflow-check</strong></dt>
<dd><p>enable arithmetic over- and underflow checks</p>
</dd>
<dt><strong>--pointer-overflow-check</strong></dt>
<dd><p>enable pointer arithmetic over- and underflow checks</p>
</dd>
<dt><strong>--conversion-check</strong></dt>
<dd><p>check whether values can be represented after type cast</p>
</dd>
<dt><strong>--undefined-shift-check</strong></dt>
<dd><p>check shift greater than bit-width</p>
</dd>
<dt><strong>--float-overflow-check</strong></dt>
<dd><p>check floating-point for +/-Inf</p>
</dd>
<dt><strong>--nan-check</strong></dt>
<dd><p>check floating-point for NaN</p>
</dd>
<dt><strong>--enum-range-check</strong></dt>
<dd><p>checks that all enum type expressions have values in the enum range</p>
</dd>
<dt><strong>--pointer-primitive-check</strong></dt>
<dd><p>checks that all pointers in pointer primitives are valid or null</p>
</dd>
<dt><strong>--retain-trivial-checks</strong></dt>
<dd><p>include checks that are trivially true</p>
</dd>
<dt><strong>--error-label</strong> label</dt>
<dd><p>check that label is unreachable</p>
</dd>
<dt><strong>--no-built-in-assertions</strong></dt>
<dd><p>ignore assertions in built-in library</p>
</dd>
<dt><strong>--no-assertions</strong></dt>
<dd><p>ignore user assertions</p>
</dd>
<dt><strong>--no-assumptions</strong></dt>
<dd><p>ignore user assumptions</p>
</dd>
<dt><strong>--assert-to-assume</strong></dt>
<dd><p>convert user assertions to assumptions</p>
</dd>
<dt><strong>--cover</strong> CC</dt>
<dd><p>create test-suite with coverage criterion CC, where CC is one of assertion[s], assume[s], branch[es], condition[s], cover, decision[s], location[s], or mcdc</p>
</dd>
<dt><strong>--cover-failed-assertions</strong></dt>
<dd><p>do not stop coverage checking at failed assertions (this is the default for <strong>--cover</strong> assertions)</p>
</dd>
<dt><strong>--show-test-suite</strong></dt>
<dd><p>print test suite for coverage criterion (requires <strong>--cover</strong>)</p>
</dd>
<dt><strong>--mm</strong> MM</dt>
<dd><p>memory consistency model for concurrent programs (default: sc)</p>
</dd>
<dt><strong>--malloc-may-fail</strong></dt>
<dd><p>allow malloc calls to return a null pointer</p>
</dd>
<dt><strong>--malloc-fail-assert</strong></dt>
<dd><p>set malloc failure mode to assert-then-assume</p>
</dd>
<dt><strong>--malloc-fail-null</strong></dt>
<dd><p>set malloc failure mode to return null</p>
</dd>
<dt><strong>--string-abstraction</strong></dt>
<dd><p>track C string lengths and zero-termination</p>
</dd>
<dt><strong>--fp-reachability-slice</strong> f</dt>
<dd><p>remove instructions that cannot appear on a trace that visits all given functions. The list of functions has to be given as a comma separated list f.</p>
</dd>
<dt><strong>--reachability-slice</strong></dt>
<dd><p>remove instructions that cannot appear on a trace from entry point to a property</p>
</dd>
<dt><strong>--reachability-slice-fb</strong></dt>
<dd><p>remove instructions that cannot appear on a trace from entry point through a property</p>
</dd>
<dt><strong>--full-slice</strong></dt>
<dd><p>run full slicer (experimental)</p>
</dd>
<dt><strong>--drop-unused-functions</strong></dt>
<dd><p>drop functions trivially unreachable from main function</p>
</dd>
<dt><strong>--havoc-undefined-functions</strong></dt>
<dd><p>for any function that has no body, assign non-deterministic values to any parameters passed as non-const pointers and the return value</p>
</dd>
</dl>
<h2>Semantic transformations:</h2>
<dl>
<dt><strong>--nondet-static</strong></dt>
<dd><p>add nondeterministic initialization of variables with static lifetime</p>
</dd>
</dl>
<h2>BMC options:</h2>
<dl>
<dt><strong>--paths</strong> [strategy]</dt>
<dd><p>explore paths one at a time</p>
</dd>
<dt><strong>--show-symex-strategies</strong></dt>
<dd><p>list strategies for use with <strong>--paths</strong></p>
</dd>
<dt><strong>--show-goto-symex-steps</strong></dt>
<dd><p>show which steps symex travels, includes diagnostic information</p>
</dd>
<dt><strong>--show-points-to-sets</strong></dt>
<dd><p>show points-to sets for pointer dereference. Requires <strong>--json-ui</strong>.</p>
</dd>
<dt><strong>--program-only</strong></dt>
<dd><p>only show program expression</p>
</dd>
<dt><strong>--show-byte-ops</strong></dt>
<dd><p>show all byte extracts and updates</p>
</dd>
<dt><strong>--depth</strong> nr</dt>
<dd><p>limit search depth</p>
</dd>
<dt><strong>--max-field-sensitivity-array-size</strong> M</dt>
<dd><p>maximum size M of arrays for which field sensitivity will be applied to array, the default is 64</p>
</dd>
<dt><strong>--no-array-field-sensitivity</strong></dt>
<dd><p>deactivate field sensitivity for arrays, this is equivalent to setting the maximum field sensitivity size for arrays to 0</p>
</dd>
<dt><strong>--show-loops</strong></dt>
<dd><p>show the loops in the program</p>
</dd>
<dt><strong>--unwind</strong> nr</dt>
<dd><p>unwind nr times</p>
</dd>
<dt><strong>--unwindset</strong> [T:]L:B,...</dt>
<dd><p>unwind loop L with a bound of B (optionally restricted to thread T) (use <strong>--show-loops</strong> to get the loop IDs)</p>
</dd>
<dt><strong>--incremental-loop</strong> L</dt>
<dd><p>check properties after each unwinding of loop L (use <strong>--show-loops</strong> to get the loop IDs)</p>
</dd>
<dt><strong>--unwind-min</strong> nr</dt>
<dd><p>start incremental-loop after nr unwindings but before solving that iteration. If for example it is 1, then the loop will be unwound once, and immediately checked. Note: this means for min-unwind 1 or 0 all properties are checked.</p>
</dd>
<dt><strong>--unwind-max</strong> nr</dt>
<dd><p>stop incremental-loop after nr unwindings</p>
</dd>
<dt><strong>--ignore-properties-before-unwind-min</strong></dt>
<dd><p>do not check properties before unwind-min when using incremental-loop</p>
</dd>
<dt><strong>--show-vcc</strong></dt>
<dd><p>show the verification conditions</p>
</dd>
<dt><strong>--slice-formula</strong></dt>
<dd><p>remove assignments unrelated to property</p>
</dd>
<dt><strong>--unwinding-assertions</strong></dt>
<dd><p>generate unwinding assertions (cannot be used with <strong>--cover</strong>)</p>
</dd>
<dt><strong>--partial-loops</strong></dt>
<dd><p>permit paths with partial loops</p>
</dd>
<dt><strong>--no-self-loops-to-assumptions</strong></dt>
<dd><p>do not simplify while(1){} to assume(0)</p>
</dd>
<dt><strong>--symex-complexity-limit</strong> N</dt>
<dd><p>how complex (N) a path can become before symex abandons it. Currently uses guard size to calculate complexity.</p>
</dd>
<dt><strong>--symex-complexity-failed-child-loops-limit</strong> N</dt>
<dd><p>how many child branches (N) in an iteration are allowed to fail due to complexity violations before the loop gets blacklisted</p>
</dd>
<dt><strong>--graphml-witness</strong> filename</dt>
<dd><p>write the witness in GraphML format to filename</p>
</dd>
<dt><strong>--symex-cache-dereferences</strong></dt>
<dd><p>enable caching of repeated dereferences</p>
</dd>
</dl>
<h2>Backend options:</h2>
<dl>
<dt><strong>--object-bits</strong> n</dt>
<dd><p>number of bits used for object addresses</p>
</dd>
<dt><strong>--external-sat-solver</strong> cmd</dt>
<dd><p>command to invoke SAT solver process</p>
</dd>
<dt><strong>--no-sat-preprocessor</strong></dt>
<dd><p>disable the SAT solver's simplifier</p>
</dd>
<dt><strong>--dimacs</strong></dt>
<dd><p>generate CNF in DIMACS format</p>
</dd>
<dt><strong>--beautify</strong></dt>
<dd><p>beautify the counterexample (greedy heuristic)</p>
</dd>
<dt><strong>--smt1</strong></dt>
<dd><p>use default SMT1 solver (obsolete)</p>
</dd>
<dt><strong>--smt2</strong></dt>
<dd><p>use default SMT2 solver (Z3)</p>
</dd>
<dt><strong>--boolector</strong></dt>
<dd><p>use Boolector</p>
</dd>
<dt><strong>--cprover-smt2</strong></dt>
<dd><p>use CPROVER SMT2 solver</p>
</dd>
<dt><strong>--cvc3</strong></dt>
<dd><p>use CVC3</p>
</dd>
<dt><strong>--cvc4</strong></dt>
<dd><p>use CVC4</p>
</dd>
<dt><strong>--mathsat</strong></dt>
<dd><p>use MathSAT</p>
</dd>
<dt><strong>--yices</strong></dt>
<dd><p>use Yices</p>
</dd>
<dt><strong>--z3</strong></dt>
<dd><p>use Z3</p>
</dd>
<dt><strong>--fpa</strong></dt>
<dd><p>use theory of floating-point arithmetic</p>
</dd>
<dt><strong>--refine</strong></dt>
<dd><p>use refinement procedure (experimental)</p>
</dd>
<dt><strong>--refine-arrays</strong></dt>
<dd><p>use refinement for arrays only</p>
</dd>
<dt><strong>--refine-arithmetic</strong></dt>
<dd><p>refinement of arithmetic expressions only</p>
</dd>
<dt><strong>--max-node-refinement</strong></dt>
<dd><p>maximum refinement iterations for arithmetic expressions</p>
</dd>
<dt><strong>--incremental-smt2-solver</strong> <em>cmd</em></dt>
<dd><p>Use the incremental SMT backend where <em>cmd</em> is the command to invoke the SMT solver of choice.<br />
Example invocations:<br />
--incremental-smt2-solver 'z3 -smt2 -in' (use the Z3 solver).<br />
--incremental-smt2-solver 'cvc5 --lang=smtlib2.6 --incremental' (use the CVC5 solver).</p>
</dd>
</dl>
<p>Note that:<br />
The solver name must be in the "PATH" or be an executable with full path.<br />
The SMT solver should accept incremental SMTlib v2.6 formatted input from the stdin.<br />
The SMT solver should support the QF_AUFBV logic.</p>
<dl>
<dt><strong>--outfile</strong> filename</dt>
<dd><p>output formula to given file</p>
</dd>
<dt><strong>--dump-smt-formula</strong> filename</dt>
<dd><p>output smt incremental formula to the given file</p>
</dd>
<dt><strong>--write-solver-stats-to</strong> json-file</dt>
<dd><p>collect the solver query complexity</p>
</dd>
<dt><strong>--refine-strings</strong></dt>
<dd><p>use string refinement (experimental)</p>
</dd>
<dt><strong>--string-printable</strong></dt>
<dd><p>restrict to printable strings (experimental)</p>
</dd>
<dt><strong>--arrays-uf-never</strong></dt>
<dd><p>never turn arrays into uninterpreted functions</p>
</dd>
<dt><strong>--arrays-uf-always</strong></dt>
<dd><p>always turn arrays into uninterpreted functions</p>
</dd>
<dt><strong>--show-array-constraints</strong></dt>
<dd><p>show array theory constraints added during post processing. Requires <strong>--json-ui</strong>.</p>
</dd>
</dl>
<h2>User-interface options:</h2>
<dl>
<dt><strong>--xml-ui</strong></dt>
<dd><p>use XML-formatted output</p>
</dd>
<dt><strong>--xml-interface</strong></dt>
<dd><p>bi-directional XML interface</p>
</dd>
<dt><strong>--json-ui</strong></dt>
<dd><p>use JSON-formatted output</p>
</dd>
<dt><strong>--json-interface</strong></dt>
<dd><p>bi-directional JSON interface</p>
</dd>
<dt><strong>--trace-json-extended</strong></dt>
<dd><p>add rawLhs property to trace</p>
</dd>
<dt><strong>--trace-show-function-calls</strong></dt>
<dd><p>show function calls in plain trace</p>
</dd>
<dt><strong>--trace-show-code</strong></dt>
<dd><p>show original code in plain trace</p>
</dd>
<dt><strong>--trace-hex</strong></dt>
<dd><p>represent plain trace values in hex</p>
</dd>
<dt><strong>--compact-trace</strong></dt>
<dd><p>give a compact trace</p>
</dd>
<dt><strong>--stack-trace</strong></dt>
<dd><p>give a stack trace only</p>
</dd>
<dt><strong>--flush</strong></dt>
<dd><p>flush every line of output</p>
</dd>
<dt><strong>--verbosity</strong> #</dt>
<dd><p>verbosity level</p>
</dd>
<dt><strong>--timestamp</strong> [<strong>monotonic</strong>|<strong>wall</strong>]</dt>
<dd><p>Print microsecond-precision timestamps. <strong>monotonic</strong>: stamps increase monotonically. <strong>wall</strong>: ISO-8601 wall clock timestamps.</p>
</dd>
</dl>
<h1>ENVIRONMENT</h1>
<p>All tools honor the TMPDIR environment variable when generating temporary files and directories. Furthermore note that the preprocessor used by <strong>cbmc will use environment variables to locate</strong> header files.</p>
<h1>BUGS</h1>
<p>If you encounter a problem please create an issue at <strong>https://github.com/diffblue/cbmc/issues</strong></p>
<h1>SEE ALSO</h1>
<p><strong>goto-cc</strong>(1), <strong>goto-instrument</strong>(1)</p>
<h1>COPYRIGHT</h1>
<p>2001-2016, Daniel Kroening, Edmund Clarke</p>
