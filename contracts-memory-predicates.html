<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: Memory Predicates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('contracts-memory-predicates.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Memory Predicates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md103">The __CPROVER_is_fresh predicate</a><ul><li class="level2"><a href="#autotoc_md104">Syntax</a><ul><li class="level3"><a href="#autotoc_md105">Parameters</a></li>
<li class="level3"><a href="#autotoc_md106">Return Value</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md107">Semantics</a><ul><li class="level3"><a href="#autotoc_md108">Enforcement</a></li>
<li class="level3"><a href="#autotoc_md109">Replacement</a></li>
<li class="level3"><a href="#autotoc_md110">Influence of memory allocation failure modes flags in assumption contexts</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md111">The __CPROVER_pointer_in_range_dfcc predicate</a><ul><li class="level2"><a href="#autotoc_md112">Syntax</a></li>
<li class="level2"><a href="#autotoc_md113">Semantics</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md114">User defined memory predicates</a><ul><li class="level2"><a href="#autotoc_md115">Limitations</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md116">Additional Resources</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_cbmc_cbmc_src_goto_instrument_contracts_doc_user_contracts_memory_predicates"></a> Back to <a class="el" href="contracts-user.html">Code Contracts User Documentation</a></p>
<p>The built-in and user-defined predicates discussed in this section are meant to let users describe the shape of the memory accessed through pointers in <em>requires clauses</em> and <em>ensures clauses</em>. Attempting to call these predicates outside of a requires or ensures clause context will result in a verification error. </p>
<h1><a class="anchor" id="autotoc_md103"></a>
The __CPROVER_is_fresh predicate</h1>
<h2><a class="anchor" id="autotoc_md104"></a>
Syntax</h2>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<span class="keywordtype">void</span> *p, <span class="keywordtype">size_t</span> size);</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ad4e9673ed79a6d8ff4af6cf12d95c29f"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_is_fresh(const void *mem, __CPROVER_size_t size)</div></div>
</div><!-- fragment --><p>To specify memory footprint we use a special function called <code>__CPROVER_is_fresh</code>. The meaning of <code>__CPROVER_is_fresh</code> is that we are borrowing a pointer from the external environment (in a precondition), or returning it to the calling context (in a postcondition).</p>
<h3><a class="anchor" id="autotoc_md105"></a>
Parameters</h3>
<p><code>__CPROVER_is_fresh</code> takes two arguments: a pointer and an allocation size. The first argument is the pointer to be checked for "freshness" (i.e., not previously allocated), and the second is the expected size in bytes for the memory available at the pointer.</p>
<h3><a class="anchor" id="autotoc_md106"></a>
Return Value</h3>
<p>It returns a <code>bool</code> value, indicating whether the pointer is fresh.</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Semantics</h2>
<p>To illustrate the semantics for <code>__CPROVER_is_fresh</code>, consider the following implementation of <code>sum</code> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *err_signal; <span class="comment">// Global variable</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line">__CPROVER_requires(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <span class="keyword">sizeof</span>(*out)))</div>
<div class="line">__CPROVER_ensures(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(err_signal, <span class="keyword">sizeof</span>(*err_signal)))</div>
<div class="line">__CPROVER_assigns(*out, err_signal)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  err_signal = <a class="code" href="stdlib_8c.html#a53a0f3908528e9d382f76b87e2b8a76b">malloc</a>(<span class="keyword">sizeof</span>(*err_signal));</div>
<div class="line">  <span class="keywordflow">if</span> (!err_signal) <span class="keywordflow">return</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (result &gt; UINT32_MAX) *err_signal = FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  *err_signal = SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="astdlib_8c_html_a53a0f3908528e9d382f76b87e2b8a76b"><div class="ttname"><a href="stdlib_8c.html#a53a0f3908528e9d382f76b87e2b8a76b">malloc</a></div><div class="ttdeci">void * malloc(__CPROVER_size_t malloc_size)</div><div class="ttdef"><b>Definition:</b> <a href="stdlib_8c_source.html#l00179">stdlib.c:179</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md108"></a>
Enforcement</h3>
<p>When checking the contract abstracts a function a <code>__CPROVER_is_fresh</code> in a <em>requires</em> clause will cause fresh memory to be allocated. In an <em>ensures</em> clause it will check that memory was freshly allocated.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *err_signal; <span class="comment">// Global variable</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> __CPROVER_contracts_original_sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  err_signal = <a class="code" href="stdlib_8c.html#a53a0f3908528e9d382f76b87e2b8a76b">malloc</a>(<span class="keyword">sizeof</span>(*err_signal));</div>
<div class="line">  <span class="keywordflow">if</span> (!err_signal) <span class="keywordflow">return</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (result &gt; UINT32_MAX) *err_signal = FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  *err_signal = SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Function Contract Enforcement */</span></div>
<div class="line"><span class="keywordtype">int</span> sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#ae5af07e274b573cd0f23ffb9d332bef2">__CPROVER_assume</a>(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <span class="keyword">sizeof</span>(*out))); <span class="comment">// Assumes out is freshly allocated</span></div>
<div class="line">  <span class="keywordtype">int</span> return_value_sum = __CPROVER_contracts_original_sum(a, b, out);</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(err_signal, <span class="keyword">sizeof</span>(*err_signal)), <span class="stringliteral">&quot;Check ensures clause&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> return_value_sum;</div>
<div class="line">}</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a564e8a5a7bebea04fdd5ee1277832478"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a></div><div class="ttdeci">void __CPROVER_assert(__CPROVER_bool assertion, const char *description)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ae5af07e274b573cd0f23ffb9d332bef2"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ae5af07e274b573cd0f23ffb9d332bef2">__CPROVER_assume</a></div><div class="ttdeci">void __CPROVER_assume(__CPROVER_bool assumption)</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md109"></a>
Replacement</h3>
<p>In our example, consider that a function <code>foo</code> may call <code>sum</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *err_signal; <span class="comment">// Global variable</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line">  sum(a, b, &amp;out);</div>
<div class="line">  <span class="keywordflow">return</span> *err_signal;</div>
<div class="line">}</div>
</div><!-- fragment --><p>When using a contract as an abstraction in place of a call to the function a <code>__CPROVER_is_fresh</code> in a <em>requires</em> clause will check that the argument supplied is fresh and <code>__CPROVER_is_fresh</code> in an <em>ensures</em> clause will result in a fresh malloc.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *err_signal; <span class="comment">// Global variable</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Function Contract Replacement */</span></div>
<div class="line">  <span class="comment">/* Precondition */</span></div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <span class="keyword">sizeof</span>(*out)), <span class="stringliteral">&quot;Check requires clause&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Writable Set */</span></div>
<div class="line">  *(&amp;out) = nondet_uint32_t();</div>
<div class="line">  err_signal = nondet_int_pointer();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Postconditions */</span></div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#ae5af07e274b573cd0f23ffb9d332bef2">__CPROVER_assume</a>(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(err_signal, <span class="keyword">sizeof</span>(*err_signal))); <span class="comment">// Assumes out is allocated</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> *err_signal;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md110"></a>
Influence of memory allocation failure modes flags in assumption contexts</h3>
<p>CBMC models <a href="https://github.com/diffblue/cbmc/blob/develop/doc/cprover-manual/memory-primitives.md#malloc-modelling">memory allocation failure modes</a>. When activated, these modesl result in different behaviours for <code>__CPROVER_is_fresh</code> in assumption contexts (i.e. when used in a requires clause of a contract being checked against a function, or in an ensures clause of a contract being used to abstract a function call).</p>
<ol type="1">
<li><b>No failure mode</b> (no flags): In this mode, <code>malloc</code> and <code>__CPROVER_is_fresh</code> never fail and will accept a size parameter up to <code>SIZE_MAX</code> without triggerring errors. However, pointer overflow and assigns clause checking errors will happen any time one tries to access such objects beyond an offset of <code>__CPROVER_max_malloc_size</code> (in bytes), by executing <code>ptr[size-1]</code> or <code>ptr[size]</code> in user-code, or by writing <code>__CPROVER_assigns(__CPROVER_object_from(ptr))</code> in a contract;</li>
</ol>
<ol type="1">
<li><b>Fail with NULL</b> (flags: <code>--malloc-may-fail --malloc-fail-null</code>): In this mode, if <code>size</code> is larger than <code>__CPROVER_max_malloc_size</code>, <code>malloc</code> returns a NULL pointer, and imposes an implicit assumption that size is less than <code>__CPROVER_max_malloc_size</code> when returning a non-NULL pointer. <code>__CPROVER_is_fresh</code> never fails in assumption contexts, so it adds an implicit assumption that <code>size</code> is less than <code>__CPROVER_max_malloc_size</code>.</li>
</ol>
<ol type="1">
<li><b>Fail assert</b> (flags: <code>--malloc-may-fail --malloc-fail-assert</code>): In this mode, if <code>size</code> is larger than <code>__CPROVER_max_malloc_size</code>, an <code>max allocation size exceeded</code> assertion is triggered in <code>malloc</code> and execution continues under the assumption that <code>size</code> is less than <code>__CPROVER_max_malloc_size</code>, with <code>malloc</code> returning a non-NULL pointer. <code>__CPROVER_is_fresh</code> never fails in assumption contexts, so it will trigger a <code>max allocation size exceeded</code> assertion and continue execution under the implicit assumption that <code>size</code> is less than <code>__CPROVER_max_malloc_size</code>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md111"></a>
The __CPROVER_pointer_in_range_dfcc predicate</h1>
<h2><a class="anchor" id="autotoc_md112"></a>
Syntax</h2>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="cprover__builtin__headers_8h.html#a33926c3f831d23353ac2baf02eeb063a">__CPROVER_pointer_in_range_dfcc</a>(<span class="keywordtype">void</span> *lb, <span class="keywordtype">void</span> *p, <span class="keywordtype">void</span> *ub);</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a33926c3f831d23353ac2baf02eeb063a"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a33926c3f831d23353ac2baf02eeb063a">__CPROVER_pointer_in_range_dfcc</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_pointer_in_range_dfcc(void *lb, void *ptr, void *ub)</div></div>
</div><!-- fragment --><p>This predicate holds if <code>lb</code>, <code>p</code> and <code>ub</code> are valid pointers within the same object and the pointers are ordered such that <code>lb &lt;= p &amp;&amp; p &lt;= ub</code> holds.</p>
<h2><a class="anchor" id="autotoc_md113"></a>
Semantics</h2>
<p>In assertion contexts, the predicate checks the conditions described above. In assumption contexts, the predicate checks that <code>lb</code> and <code>ub</code> are valid pointers into the same object, and updates <code>p</code> using a side effect to be a non-deterministic pointer ranging between <code>lb</code> and <code>ub</code>.</p>
<h1><a class="anchor" id="autotoc_md114"></a>
User defined memory predicates</h1>
<p>Users can write their own memory predicates based on the core predicates described above. <code>__CPROVER_is_fresh</code> allows to specify pointer validity and separation. <code>__CPROVER_pointer_in_range</code> allows to specify aliasing constraints.</p>
<p>For instance, one could write a predicate defining linked lists of at most <code>len</code> elements as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>list_t</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> value;</div>
<div class="line">  <span class="keyword">struct </span>list_t *next;</div>
<div class="line">} list_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// true iff list of len nodes with values in [-10,10]</span></div>
<div class="line"><span class="keywordtype">bool</span> is_list(list_t *l, <span class="keywordtype">size_t</span> len)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(len == 0)</div>
<div class="line">    <span class="keywordflow">return</span> l == NULL;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(l, <span class="keyword">sizeof</span>(*l)) &amp;&amp; -10 &lt;= l-&gt;value &amp;&amp;</div>
<div class="line">           l-&gt;value &lt;= 10 &amp;&amp; is_list(l-&gt;next, len - 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>One can also simply describe finite nested structures:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>buffer_t</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">char</span> *arr;</div>
<div class="line">  <span class="keywordtype">char</span> *cursor;</div>
<div class="line">} buffer_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>double_buffer_t</div>
<div class="line">{</div>
<div class="line">  buffer_t *first;</div>
<div class="line">  buffer_t *second;</div>
<div class="line">} double_buffer_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_sized_array(<span class="keywordtype">char</span> *arr, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(arr, size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_buffer(buffer_t *b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(b, <span class="keyword">sizeof</span>(*b)) &amp;&amp; (0 &lt; b-&gt;size &amp;&amp; b-&gt;size &lt;= 10) &amp;&amp;</div>
<div class="line">         is_sized_array(b-&gt;arr, b-&gt;size) &amp;&amp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_double_buffer(double_buffer_t *b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(b, <span class="keyword">sizeof</span>(*b)) &amp;&amp; is_buffer(b-&gt;first) &amp;&amp;</div>
<div class="line">         is_buffer(b-&gt;second);</div>
<div class="line">}</div>
</div><!-- fragment --><p>And one can then use these predicates in requires or ensures clauses for function contracts.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> foo(list_t *l, double_buffer_t *b)</div>
<div class="line">  <span class="comment">// clang-format off</span></div>
<div class="line">  __CPROVER_requires(is_list(l, 3))</div>
<div class="line">  __CPROVER_requires(is_double_buffer(b))</div>
<div class="line">  __CPROVER_ensures(-28 &lt;= __CPROVER_return_value &amp;&amp;</div>
<div class="line">                    __CPROVER_return_value &lt;= 50)</div>
<div class="line"><span class="comment">// clang-format on</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// access the assumed data structure</span></div>
<div class="line">  <span class="keywordflow">return</span> l-&gt;value + l-&gt;next-&gt;value + l-&gt;next-&gt;next-&gt;value + b-&gt;first-&gt;size +</div>
<div class="line">         b-&gt;second-&gt;size;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md115"></a>
Limitations</h2>
<p>The main limitation with user defined predicates are:</p><ul>
<li>their evaluation must terminate;</li>
<li>self-recursive predicates are supported, but mutually recursive predicates are not supported for the moment.</li>
</ul>
<p>For instance, in the <code>is_list</code> example above, recursion is bounded by the use of the explicit <code>len</code> parameter. The <code>is_double_buffer</code> predicate also describes a bounded structure.</p>
<h1><a class="anchor" id="autotoc_md116"></a>
Additional Resources</h1>
<ul>
<li><a class="el" href="contracts-functions.html">Function Contracts</a><ul>
<li><a class="el" href="contracts-requires-ensures.html">Requires and Ensures Clauses</a></li>
<li><a class="el" href="contracts-assigns.html">Assigns Clauses</a></li>
<li><a class="el" href="contracts-frees.html">Frees Clauses</a></li>
</ul>
</li>
<li><a class="el" href="contracts-loops.html">Loop Contracts</a><ul>
<li><a class="el" href="contracts-loop-invariants.html">Loop Invariant Clauses</a></li>
<li><a class="el" href="contracts-decreases.html">Decreases Clauses</a></li>
<li><a class="el" href="contracts-assigns.html">Assigns Clauses</a></li>
<li><a class="el" href="contracts-frees.html">Frees Clauses</a></li>
</ul>
</li>
<li><a class="el" href="contracts-memory-predicates.html">Memory Predicates</a></li>
<li><a class="el" href="contracts-function-pointer-predicates.html">Function Pointer Predicates</a></li>
<li><a class="el" href="contracts-history-variables.html">History Variables</a></li>
<li><a class="el" href="contracts-quantifiers.html">Quantifiers</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="contracts-mainpage.html">Code Contracts in CBMC</a></li><li class="navelem"><a class="el" href="contracts-user.html">Code Contracts User Documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
