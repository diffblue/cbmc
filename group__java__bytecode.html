<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: java_bytecode</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__java__bytecode.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">java_bytecode</div>  </div>
</div><!--header-->
<div class="contents">
<p>This module provides a front end for Java.</p>
<h1><a class="anchor" id="java-bytecode-conversion-section"></a>
Overview of conversion from bytecode to codet</h1>
<p>To be documented. </p>
<h2><a class="anchor" id="java-bytecode-lowering-to-goto"></a>
Lowering to GOTO</h2>
<p>The Java language contains high-level programming concepts like virtual functions and throw/catch semantics. These need to be rewritten in terms of other, more fundamental operations in order to analyse the Java program. This operation is referred to as "lowering". See Background Concepts for more information.</p>
<p>The following lowering operations are done on Java bytecode after converting into a basic <code>codet</code> representation.</p>
<ul>
<li><a class="el" href="group__java__bytecode.html#java-bytecode-runtime-exceptions">Add runtime exceptions</a></li>
<li><a class="el" href="group__java__bytecode.html#java-bytecode-remove-java-new">Remove `new` calls</a></li>
<li><a class="el" href="group__java__bytecode.html#java-bytecode-remove-exceptions">Remove thrown exceptions</a></li>
<li><a class="el" href="group__java__bytecode.html#java-bytecode-remove-instanceof">Remove instanceof</a></li>
<li>As well as other non-Java specific transformations (see <a class="el" href="group__goto-programs.html">goto-programs</a> for details on these)</li>
</ul>
<p>These are performed in <code>process_goto_function</code> for example <a class="el" href="classjbmc__parse__optionst.html#a849e4b7d760ab9f6b340908c145fd35e">jbmc_parse_optionst::process_goto_function</a></p>
<p>Once these lowerings have been completed, you have a GOTO model that can be handled by <a class="el" href="group__goto-symex.html">goto-symex</a>.</p>
<h1><a class="anchor" id="java-bytecode-array-representation"></a>
How are Java arrays represented in GOTO</h1>
<p>To be documented.</p>
<h1><a class="anchor" id="java-bytecode-object-factory"></a>
Object Factory</h1>
<p>To be documented.</p>
<h2><a class="anchor" id="java-bytecode-pointer-type-selection"></a>
Pointer type selection</h2>
<p>In Java, all variables that are of a non-primitive type are pointers to an object. When initializing such variables using <a class="el" href="classjava__object__factoryt.html">java_object_factoryt</a>, e.g., as input arguments for the method under test, we may need to select the correct pointer type. For example, abstract classes can be replaced with their concrete implementations and type parameters in generic types can be replaced with their specialized types.</p>
<p>The class <a class="el" href="classselect__pointer__typet.html">select_pointer_typet</a> offers the basic interface for this functionality, in particular see <a class="el" href="classselect__pointer__typet.html#adc9bd66f2da912fc57705ef0b8b34fe0">select_pointer_typet::convert_pointer_type</a>. Note that this class only implements generic specialization (see <a class="el" href="group__java__bytecode.html#java-bytecode-generic-specialization">Generic specialization</a>), derived classes can override this behavior to provide more sophisticated type selection.</p>
<h2><a class="anchor" id="java-bytecode-generic-specialization"></a>
Generic specialization</h2>
<p>In Java, generics are checked at compile-time for type-correctness. The generic type information is then removed in a process called type erasure. However, throwing away all this type information would be very inconvenient for our analysis. Therefore, when we initialize variables that have generic type we dynamically replace the generic parameters with their specialized types rather than using only the raw type. For example, consider a generic class <code>MyGeneric&lt;T&gt;</code> with a field <code>T myField</code>. When initializing a variable <code>MyGeneric&lt;Integer&gt; mg</code> we change the type of its field <code>mg.myField</code> from <code>MyGeneric::T</code> to <code>Integer</code>. Generic specialization is applied during pointer type selection (see <a class="el" href="group__java__bytecode.html#java-bytecode-pointer-type-selection">Pointer type selection</a>).</p>
<p>The generic specialization relies on a map that stores the concrete types of all generic parameters in the current scope. The map is maintained in <a class="el" href="classjava__object__factoryt.html#a16ad36ac9c2d3314644fc024ca47b303">java_object_factoryt::generic_parameter_specialization_map</a>. Note that not all generic parameters need to have a concrete type, e.g., when the method under test is generic. The types are removed from the map when the scope changes. In different depths of the scope the parameters can be specialized with different types so we keep a stack of types for each parameter.</p>
<p>We use the map in <a class="el" href="classselect__pointer__typet.html#aacdcb1b19ed462b7afa152410653663a">select_pointer_typet::specialize_generics</a> to retrieve the concrete type of generic parameters such as <code>MyGeneric::T</code> and of arrays of generic parameters such as <code>MyGeneric::T[]</code>. More complicated generic types such as <code>MyGeneric&lt;T&gt;</code> are specialized indirectly within <a class="el" href="classjava__object__factoryt.html">java_object_factoryt</a>. Their concrete types are already stored in the map and are retrieved when needed, e.g., to initialize their fields.</p>
<h1><a class="anchor" id="java-bytecode-parsing"></a>
Java bytecode parsing (parser, convert_class, convert_method)</h1>
<p>To be documented.</p>
<h2><a class="anchor" id="java-class-section"></a>
How a java program / class is represented in a .class</h2>
<p>Every Java class is compiled into a .class file. Inner classes, anonymous classes or classes for tableswitches are also compiled into their own .class files.</p>
<p>There exists an <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">official specification</a></p>
<p>Each class files contains information about its version, the constant pool, information about the contained class, its super-class, its implemented interfaces, its fields, methods and finally additional attributes, such as information about lambda functions used in the methods of the class or inner classes the it contains.</p>
<p>The content of a .class file can be inspected via the <code>javap</code> tool which is part of the JDK installation. Useful options are <code>-c</code> for code, <code>-p</code> to display protected / private methods <code>-l</code> for line numbers and local variable information, as well as <code>-verbose</code> which prints a lot of additional information.</p>
<p>In general, all variable length entries in a class file are represented by first having an integer <code>n</code> that specifies the number of entries and then an array of <code>n</code> such entries in the file. All variable length attribute also contain information about their length in bytes.</p>
<p>The integer format used in class files are unsigned integers of size 8/16/32 bit, which are named as <code>u1</code>/<code>u2</code>/<code>u4</code>.</p>
<h2><a class="anchor" id="java-class-access-flags"></a>
Access Flags</h2>
<p>The JVM specification defines different access flags, e.g., <code>final</code>, <code>static</code>, <code>protected</code>, <code>private</code> etc. where different ones are applicable to the class itself, its fields or methods. All access flags are represented as bits, the set of bits that are defined for one entity is represented as disjunction of those values. Each of these values is defined as a constant with a name prefixed with <code>ACC_</code> in JBMC, e.g., as </p><div class="fragment"><div class="line">#define ACC_PUBLIC 0x0001</div>
<div class="line">#define ACC_ENUM 0x4000</div>
</div><!-- fragment --><h2><a class="anchor" id="java-class-constant-pool"></a>
Constant Pool</h2>
<p>The constant pool contains all strings and referred values that are used in the .class. This includes the names of the class itself and its super-class, as well as the names and signatures of all fields and methods. All strings in the constant pool are in UTF-16 format.</p>
<h2><a class="anchor" id="java-class-fields"></a>
Fields</h2>
<p>Each member variable of a class has a field entry with a corresponding field information structure. This contains the name of the field, its raw JVM type (called the descriptor) and an optional signature.</p>
<p>A signature is an extension to the Java raw types and contains information about the generic type of an object if applicable.</p>
<p>The name of the field, the descriptor and the signature are all represented as indices into the constant pool of the class file.</p>
<h2><a class="anchor" id="java-class-methods"></a>
Methods</h2>
<p>Methods are represented in a similar way as fields. Each method has an associated name, descriptor and optional signature entry in the constant pool table.</p>
<p>An implemented method also has several attributes. One is the <code>Code</code> attribute that stores the actual bytecode instructions. There is also an optional <code>LocalVariableTable</code> which contains the names of local variables and parameters. In addition to this there is also an optional <code>LocalVariableTypeTable</code> that contains information about generic local variables and parameters. Finally the exception table is defined as entries in the <code>Exceptions</code> attribute.</p>
<p>Note: most information about generic types is optional and exists mainly as debugger information. This is because the Java compiler ensures that typing is correct and creates code accordingly. The same holds true for information on local variables. It is therefore advisable to compile Java projects with the <code>-g</code> option that adds debugging information in all cases.</p>
<h2><a class="anchor" id="java-class-attributes"></a>
Attributes</h2>
<p>The last section contains additional attributes, e.g., <code>SourceFile</code> which specified from which source file the .class was compiled, <code>BootstrapMethods</code> which is used for lambda functions or <code>InnerClasses</code> which refers to inner classes of the class in question.</p>
<h1><a class="anchor" id="java-bytecode-runtime-exceptions"></a>
Adding runtime exceptions (java_bytecode_instrument)</h1>
<p>To be documented.</p>
<h1><a class="anchor" id="java-bytecode-concurrency-instrumentation"></a>
Concurrency instrumentation</h1>
<p>Relevant code:</p>
<ul>
<li><a class="el" href="java__bytecode__concurrency__instrumentation_8h.html">java_bytecode_concurrency_instrumentation.h</a></li>
<li><a class="el" href="java__bytecode__concurrency__instrumentation_8cpp.html">java_bytecode_concurrency_instrumentation.cpp</a></li>
<li><a class="el" href="java__static__initializers_8h.html">java_static_initializers.h</a></li>
<li><a class="el" href="java__static__initializers_8cpp.html">java_static_initializers.cpp</a></li>
<li><a class="el" href="java__bytecode__convert__method_8cpp.html">java_bytecode_convert_method.cpp</a></li>
</ul>
<p>Concurrency instrumentation for Java programs is disabled by default. It can be enabled by specifying the <code>--java-threading</code> command line flag.</p>
<p>Thread-blocks have special semantics, in the sense that unlike basic blocks they can be executed independently. JBMC treats a sequence of codet's surrounded with calls to <code>CProver.startThread:(I)V</code> and <code>CProver.endThread:(I)V</code> as a thread-block. These functions take one argument, an integer, that is used to associate the start of a thread (i.e: calls to <code>CProver.startThread:(I)V</code>) to the end of the thread (i.e: calls to <code>CProver.endThread:(I)V</code>). JBMC assumes that calls to the these functions are well-formed, more specifically, each call to <code>CProver.startThread:(I)V</code> must have an associated call to <code>CProver.endThread:(I)V</code>.</p>
<p>The instrumentation process (described here) will transform the aforementioned function calls, synchronized blocks/methods and calls to <code>java.lang.Thread.getCurrentThreadId:()I</code> into appropriate codet. As part of this process a new variable per thread is created along with a single global variable that is used keep track of thread identifiers. These variables are needed to handle calls to <code>java.lang.Thread.getCurrentThreadId:()I</code>.</p>
<p>Hold on, how do we go from Java threads to <code>CProver.startThread:(I)V</code> and <code>CProver.endThread:(I)V</code>? Well, two ways</p>
<ul>
<li>You are free to use the CProver API and manually and insert calls to the <code>CProver.startThread:(I)V</code> and <code>CProver.endThread:(I)V</code>.</li>
<li>Models! Which provide a mock implementation of the <code>java.lang.Thread</code> class.</li>
</ul>
<p>Note: instrumentation of Java static initializers changes when the <code>--java-threading</code> flag is specified, this is because the static initializer of every class needs to be carefully synchronized to prevent superfluous interleavings.</p>
<p>Note': conversation of synchronized methods (<code>void synchronized test(){ ... }</code>) and synchronized blocks (<code>synchronized(lock) { ... }</code>) are dealt with differently as they are represented differently in bytecode. One is a flag, while the other has explicit instructions.</p>
<h2><a class="anchor" id="converting-thread-blocks"></a>
Converting Thread Blocks</h2>
<p>JBMC will iterate through the symbol table to find and instrument thread-blocks. Specifically, function calls to <code>CProver.startThread:(I)V</code> are transformed into a <code>codet(id=ID_start_thread, destination=I)</code>, which carries a target label in the field <code>destination</code>. Similarly <code>CProver.endThread(I)V</code> is transformed into a <code>codet(id=ID_end_thread)</code>.</p>
<p>For each new thread a thread local variable <code>__CPROVER__thread_id</code> is created. The new id is obtained by incrementing a global variable <code>__CPROVER__next_thread_id</code>.</p>
<p>The semantics of <code>codet(id=ID_start_thread, destination=I)</code> roughly corresponds to: spawn the current thread, continue the execution of the current thread in the next line, and continue the execution of the new thread at the destination.</p>
<p>Example, the following Java code:</p>
<div class="fragment"><div class="line">CProver.startThread(333);</div>
<div class="line">...  <span class="comment">// thread body</span></div>
<div class="line">CProver.endThread(333);</div>
</div><!-- fragment --><p>is transformed into the following codet:</p>
<div class="fragment"><div class="line"><a class="code" href="classcodet.html">codet</a>(<span class="keywordtype">id</span>=ID_start_thread, destination=__CPROVER_THREAD_ENTRY_333)</div>
<div class="line"><a class="code" href="classcodet.html">codet</a>(<span class="keywordtype">id</span>=ID_goto, destination=__CPROVER_THREAD_EXIT_333)</div>
<div class="line"><a class="code" href="classcodet.html">codet</a>(<span class="keywordtype">id</span>=ID_label, label=__CPROVER_THREAD_ENTRY_333)</div>
<div class="line"><a class="code" href="classcodet.html">codet</a>(<span class="keywordtype">id</span>=ID_atomic_begin)</div>
<div class="line">__CPROVER__next_thread_id += 1;</div>
<div class="line">__CPROVER__thread_id = __CPROVER__next_thread_id;</div>
<div class="line">... <span class="comment">// thread body</span></div>
<div class="line"><a class="code" href="classcodet.html">codet</a>(<span class="keywordtype">id</span>=ID_end_thread)</div>
<div class="line"><a class="code" href="classcodet.html">codet</a>(<span class="keywordtype">id</span>=ID_label, label=__CPROVER_THREAD_EXIT_333)</div>
<div class="ttc" id="aclasscodet_html"><div class="ttname"><a href="classcodet.html">codet</a></div><div class="ttdoc">Data structure for representing an arbitrary statement in a program.</div><div class="ttdef"><b>Definition:</b> <a href="std__code__base_8h_source.html#l00028">std_code_base.h:29</a></div></div>
</div><!-- fragment --><p>The ID of the thread is made accessible to the Java program by having calls to the function <code>CProver.getCurrentThreadId()I</code> replaced by the variable <code>__CPROVER__thread_id</code>.</p>
<p>Example, the following Java code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> g = java.lang.thead.getCurrentThreadId();</div>
</div><!-- fragment --><p>is transformed into the following codet:</p>
<div class="fragment"><div class="line"><a class="code" href="classcode__assignt.html">code_assignt</a>(lhs=g, rhs=__CPROVER__thread_id)</div>
<div class="ttc" id="aclasscode__assignt_html"><div class="ttname"><a href="classcode__assignt.html">code_assignt</a></div><div class="ttdoc">A goto_instruction_codet representing an assignment in the program.</div><div class="ttdef"><b>Definition:</b> <a href="goto__instruction__code_8h_source.html#l00021">goto_instruction_code.h:22</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="converting-synchronized-blocks"></a>
Converting Synchronized Blocks</h2>
<p>Synchronized blocks make it impossible for two synchronized blocks on the same object to interleave.</p>
<p>Converting synchronized blocks is rather straightforward as there is a specific bytecode instruction to indicate the start (<code>monitorenter</code>) and end (<code>monitorexit</code>) of a synchronized block.</p>
<p><code>monitorenter</code> is converted to a call to <code>java::java.lang.Object.monitorenter:(Ljava/lang/Object;)V</code>.</p>
<p><code>monitorexit</code> is converted to a call to <code>java::java.lang.Object.monitorexit:(Ljava/lang/Object;)V</code>.</p>
<h2><a class="anchor" id="converting-synchronized-methods"></a>
Converting Synchronized Methods</h2>
<p>Synchronized methods make it impossible for two invocations of the same method on the same object to interleave.</p>
<p>A method is considered to be synchronized and thus subject to the following process, if the symbol that represents it has the irep_id <code>is_synchronized</code> specified. In Java this corresponds to the <code>synchronized</code> keyword in the declaration of a method.</p>
<p>Unlike synchronized blocks Java synchronized methods do not have explicit calls to the instructions <code>monitorenter</code> and <code>monitorexit</code> (or equivalents), instead the JVM interprets the synchronized flag and internally implements locking/unlocking on the object.</p>
<p>To emulate this behaviour JBMC will iterate through the symbol table to find synchronized methods. It will then insert a call to our model of <code>monitorenter</code> (<code>java::java.lang.Object.monitorenter:(Ljava/lang/Object;)V</code>) at the beginning of the method and calls to our model of <code>monitorexit</code> (<code>java::java.lang.Object.monitorexit:(Ljava/lang/Object;)V</code>) is instrumented at each return instruction. We wrap the entire body of the method with an exception handler that will call our model of <code>monitorexit</code> if the method returns exceptionally.</p>
<p>Example, the following Java code:</p>
<div class="fragment"><div class="line"><span class="keyword">synchronized</span> <span class="keywordtype">int</span> amethod(<span class="keywordtype">int</span> p)</div>
<div class="line"> {</div>
<div class="line">   <span class="keywordtype">int</span> x = 0;</div>
<div class="line">   <span class="keywordflow">if</span>(p == 0)</div>
<div class="line">     <span class="keywordflow">return</span> -1;</div>
<div class="line">   x = p / 10</div>
<div class="line">   <span class="keywordflow">return</span> x</div>
<div class="line"> }</div>
</div><!-- fragment --><p>The codet version of the above is too verbose be shown here. Instead the following code depicts our equivalent Java code interpretation of the above:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> amethod(<span class="keywordtype">int</span> p)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">try</span></div>
<div class="line"> {</div>
<div class="line">   java::java.lang.Object.monitorenter(<span class="keyword">this</span>);</div>
<div class="line">   <span class="keywordtype">int</span> x = 0;</div>
<div class="line">   <span class="keywordflow">if</span>(p == 0)</div>
<div class="line">   {</div>
<div class="line">     java::java.lang.Object.monitorexit(<span class="keyword">this</span>);</div>
<div class="line">     <span class="keywordflow">return</span> -1;</div>
<div class="line">   }</div>
<div class="line">   java::java.lang.Object.monitorexit(<span class="keyword">this</span>);</div>
<div class="line">   <span class="keywordflow">return</span> x</div>
<div class="line"> }</div>
<div class="line"> <span class="keywordflow">catch</span>(java::java.lang.Throwable e)</div>
<div class="line"> {</div>
<div class="line">   <span class="comment">// catch every exception, including errors!</span></div>
<div class="line">   java::java.lang.Object.monitorexit(<span class="keyword">this</span>);</div>
<div class="line">   <span class="keywordflow">throw</span> e;</div>
<div class="line"> }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="java-bytecode-remove-java-new"></a>
Remove &lt;tt&gt;new&lt;/tt&gt;, &lt;tt&gt;newarray&lt;/tt&gt; and &lt;tt&gt;multianewarray&lt;/tt&gt; bytecode operators</h1>
<p><a class="el" href="remove__java__new_8h.html">remove_java_new.h</a> is responsible for converting the <code>new</code>, <code>newarray</code> and <code>multianewarray</code> Java bytecode operation into <a class="el" href="classcodet.html">codet</a>. Specifically it converts the bytecode instruction into: - An ALLOCATE with the size of the object being created - An assignment to the value zeroing its contents - If an array, initializing the size and data components - If a multi-dimensional array, recursively calling <code>java_new</code> on each sub array</p>
<p>An ALLOCATE is a <a class="el" href="classside__effect__exprt.html">side_effect_exprt</a> that is interpreted by <a class="el" href="classgoto__symext.html#a5eba5ba896c78fb2e11afa1344bbf1e5">goto_symext::symex_allocate</a></p>
<p><em>Note: it does not call the constructor as this is done by a separate java_bytecode operation.</em></p>
<h2><a class="anchor" id="java_objects"></a>
Java Objects (&lt;tt&gt;new&lt;/tt&gt;)</h2>
<p>The basic <code>new</code> operation is represented in Java bytecode by the <code>new</code> op</p>
<p>These are converted by <a class="el" href="classremove__java__newt.html#a6482d7c5ae0cf63b8c35cc20845cd1e3">remove_java_newt::lower_java_new</a></p>
<p>For example, the following Java code:</p>
<div class="fragment"><div class="line">TestClass f = <span class="keyword">new</span> TestClass();</div>
</div><!-- fragment --><p>Which is represented as the following Java bytecode:</p>
<div class="fragment"><div class="line">0: new           #2                  // class TestClass</div>
<div class="line">3: dup</div>
<div class="line">4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</div>
</div><!-- fragment --><p>The first instruction only is translated into the following <code>codet</code>s:</p>
<div class="fragment"><div class="line">tmp_object1 = <a class="code" href="classside__effect__exprt.html">side_effect_exprt</a>(ALLOCATE, <span class="keyword">sizeof</span>(TestClass))</div>
<div class="line">*tmp_object1 = <a class="code" href="classstruct__exprt.html">struct_exprt</a>{.<a class="code" href="classstruct__exprt.html#a31bbeb32ef0ebec348684214818fabe0">component</a> = 0, ... }</div>
<div class="ttc" id="aclassside__effect__exprt_html"><div class="ttname"><a href="classside__effect__exprt.html">side_effect_exprt</a></div><div class="ttdoc">An expression containing a side effect.</div><div class="ttdef"><b>Definition:</b> <a href="std__code_8h_source.html#l01449">std_code.h:1450</a></div></div>
<div class="ttc" id="aclassstruct__exprt_html"><div class="ttname"><a href="classstruct__exprt.html">struct_exprt</a></div><div class="ttdoc">Struct constructor from list of elements.</div><div class="ttdef"><b>Definition:</b> <a href="std__expr_8h_source.html#l01839">std_expr.h:1840</a></div></div>
<div class="ttc" id="aclassstruct__exprt_html_a31bbeb32ef0ebec348684214818fabe0"><div class="ttname"><a href="classstruct__exprt.html#a31bbeb32ef0ebec348684214818fabe0">struct_exprt::component</a></div><div class="ttdeci">exprt &amp; component(const irep_idt &amp;name, const namespacet &amp;ns)</div><div class="ttdef"><b>Definition:</b> <a href="std__expr_8cpp_source.html#l00094">std_expr.cpp:94</a></div></div>
</div><!-- fragment --><p>For more details about the zero expression see <a class="el" href="classexpr__initializert.html">expr_initializert</a></p>
<h2><a class="anchor" id="oned_arrays"></a>
Single Dimensional Arrays (&lt;tt&gt;newarray&lt;/tt&gt;)</h2>
<p>The new Java array operation is represented in Java bytecode by the <code>newarray</code> operation.</p>
<p>These are converted by <a class="el" href="classremove__java__newt.html#ac7095d73d760cea5dbb9c19c31d6d232">remove_java_newt::lower_java_new_array</a></p>
<p>See <a class="el" href="group__java__bytecode.html#java-bytecode-array-representation">How are Java arrays represented in GOTO</a> for details on how arrays are represented in codet.</p>
<p>A <code>newarray</code> is represented as:</p><ul>
<li>an allocation of the array object (the same as with a regular Java object).</li>
<li>Initialize the size component</li>
<li>Initialize the data component</li>
</ul>
<p>For example the following Java:</p>
<div class="fragment"><div class="line">TestClass[] tArray = <span class="keyword">new</span> TestClass[5];</div>
</div><!-- fragment --><p>Which is compiled into the following Java bytecode:</p>
<div class="fragment"><div class="line">8: iconst_5</div>
<div class="line">9: anewarray     #2                  // class TestClass</div>
</div><!-- fragment --><p>Is translated into the following <code>codet</code>s:</p>
<div class="fragment"><div class="line">tmp_object1 = <a class="code" href="classside__effect__exprt.html">side_effect_exprt</a>(ALLOCATE, <span class="keyword">sizeof</span>(java::array[referenence]))</div>
<div class="line">*tmp_object1 = <a class="code" href="classstruct__exprt.html">struct_exprt</a>{.size = 0, .<a class="code" href="classsharing__treet.html#a2fc74ffd034e6bbf6b03921d4014c648">data</a> = <span class="keyword">null</span>}</div>
<div class="line">tmp_object1-&gt;length = length</div>
<div class="line">tmp_new_data_array1 = <a class="code" href="classside__effect__exprt.html">side_effect_exprt</a>(java_new_array_data, TestClass)</div>
<div class="line">tmp_object1-&gt;<a class="code" href="classsharing__treet.html#a2fc74ffd034e6bbf6b03921d4014c648">data</a> = tmp_new_data_array1</div>
<div class="line">ARRAY_SET(tmp_new_data_array1, NULL)</div>
<div class="ttc" id="aclasssharing__treet_html_a2fc74ffd034e6bbf6b03921d4014c648"><div class="ttname"><a href="classsharing__treet.html#a2fc74ffd034e6bbf6b03921d4014c648">sharing_treet::data</a></div><div class="ttdeci">dt * data</div><div class="ttdef"><b>Definition:</b> <a href="irep_8h_source.html#l00228">irep.h:228</a></div></div>
</div><!-- fragment --><p>The <code>ARRAY_SET</code> <code>codet</code> sets all the values to null.</p>
<h2><a class="anchor" id="multidarrays"></a>
Multi Dimensional Arrays (&lt;tt&gt;newmultiarray&lt;/tt&gt;)</h2>
<p>The new Java multi dimensional array operation is represented in bytecode by <code>multianewarray</code></p>
<p>These are also by <a class="el" href="classremove__java__newt.html#ac7095d73d760cea5dbb9c19c31d6d232">remove_java_newt::lower_java_new_array</a></p>
<p>They work the same as single dimensional arrays but create a for loop for each element in the array since these start initialized.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(tmp_index = 0; tmp_index &lt; dim_size; ++tmp_index)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">struct </span>java::array[reference] *subarray_init;</div>
<div class="line">  subarray_init = java_new_array</div>
<div class="line">  newarray_tmp1-&gt;data[tmp_index] = (<span class="keywordtype">void</span> *)subarray_init;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>remove_java_new</code> is then recursively applied to the new <code>subarray</code>.</p>
<h1><a class="anchor" id="java-bytecode-remove-exceptions"></a>
Remove exceptions</h1>
<p>When <a class="el" href="remove__exceptions_8h.html#a5568ca6f6111c67d830a9c8961e54bd5">remove_exceptions</a> is called on the <a class="el" href="classgoto__modelt.html">goto_modelt</a>, the goto model contains complex instructions (<a class="el" href="goto__program_8h.html#a9e03d66cd12c59d9d3daad1ec6296beb">goto_program_instruction_typet</a>) such as <code>CATCH-POP</code>, <code>CATCH-PUSH</code> and <code>THROW</code>. In order to analyze the goto model, the instructions must be simplified to use more basic instructions - this is called "lowering". This class lowers the <code>CATCH</code> and <code>THROW</code> instructions.</p>
<p><code>THROW</code> instructions are replaced by assigning to <code>@inflight_exception</code> and a goto to end of the function. <code>CATCH</code> instructions are replaced by a check of the <code>@inflight_exception</code> and setting it to null.</p>
<h2><a class="anchor" id="throw"></a>
THROW</h2>
<p>Consider a simple method <code>testException(I)V</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>TestExceptions {</div>
<div class="line">    <span class="keywordtype">int</span> field;</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> testException(<span class="keywordtype">int</span> i) <span class="keywordflow">throws</span> Exception {</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception();</div>
<div class="line">        }</div>
<div class="line">        field = i;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The goto for <code>testException(I)V</code> before <code>remove_exceptions</code> (removing comments and replacing irrelevant parts with <code>...</code>) is:</p>
<div class="fragment"><div class="line">TestExceptions.testException(int) /* java::TestExceptions.testException:(I)V */</div>
<div class="line">  IF i &gt;= 0 THEN GOTO 3</div>
<div class="line">  struct java.lang.Exception *new_tmp0;</div>
<div class="line">  new_tmp0 = new struct java.lang.Exception;</div>
<div class="line">  IF !(new_tmp0 == null) THEN GOTO 1</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">1: SKIP</div>
<div class="line">  new_tmp0 . java.lang.Exception.&lt;init&gt;:()V();</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">2: SKIP</div>
<div class="line">  THROW: throw(new_tmp0)</div>
<div class="line">  dead new_tmp0;</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --><p> where there is a <code>THROW</code> instruction to be replaced.</p>
<p>After passing the goto model through <code>remove_exceptions</code>, it is:</p>
<div class="fragment"><div class="line">TestExceptions.testException(int) /* java::TestExceptions.testException:(I)V */</div>
<div class="line">  IF i &gt;= 0 THEN GOTO 4</div>
<div class="line">  struct java.lang.Exception *new_tmp0;</div>
<div class="line">  new_tmp0 = new struct java.lang.Exception;</div>
<div class="line">  IF !(new_tmp0 == null) THEN GOTO 1</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">1: new_tmp0 . java.lang.Exception.&lt;init&gt;:()V();</div>
<div class="line">  IF @inflight_exception == null THEN GOTO 2 // it is because we&#39;ve not used it yet</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">2: IF !(new_tmp0 == null) THEN GOTO 3</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">3: @inflight_exception = (void *)new_tmp0;</div>
<div class="line">  dead new_tmp0;</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --><p> where now instead of the instruction <code>THROW</code>, the global variable <code>@inflight_exception</code> holds the thrown exception in a separate goto statement.</p>
<h2><a class="anchor" id="catch"></a>
CATCH-PUSH, CATCH-POP and EXCEPTION LANDING PAD</h2>
<p>Consider the method <code>catchSomething(I)V</code> that tries the above method <code>testException(I)V</code> and catches the exception:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>TestExceptions {</div>
<div class="line">    <span class="keywordtype">int</span> field;</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> testException(<span class="keywordtype">int</span> i) <span class="keywordflow">throws</span> Exception {</div>
<div class="line">        <span class="keywordflow">if</span> (i &lt; 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception();</div>
<div class="line">        }</div>
<div class="line">        field = i;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> catchSomething(<span class="keywordtype">int</span> i) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            testException(i);</div>
<div class="line">        } <span class="keywordflow">catch</span> (Exception e) {</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The goto model before <code>remove_exceptions</code> is: </p><div class="fragment"><div class="line">TestExceptions.catchSomething(int) /* java::TestExceptions.catchSomething:(I)V */</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">  CATCH-PUSH -&gt;2</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">1: SKIP</div>
<div class="line">  this . com.diffblue.regression.TestExceptions.testException:(I)V(i);</div>
<div class="line">  CATCH-POP</div>
<div class="line">  GOTO 3</div>
<div class="line">2: void *anonlocal::2a;</div>
<div class="line">  struct java.lang.Exception *caught_exception_tmp0;</div>
<div class="line">  EXCEPTION LANDING PAD (struct java.lang.Exception * caught_exception_tmp0)</div>
<div class="line">  anonlocal::2a = (void *)caught_exception_tmp0;</div>
<div class="line">  dead caught_exception_tmp0;</div>
<div class="line">  dead anonlocal::2a;</div>
<div class="line"> </div>
<div class="line">...</div>
</div><!-- fragment --><p> The <code>CATCH-PUSH</code> instruction signifies the start of the try block, the <code>CATCH-POP</code> instruction signifies the end of the try block, and the <code>EXCEPTION LANDING PAD</code> signifies beginning of the catch block.</p>
<p>After <code>remove_exceptions</code> the goto model is:</p>
<div class="fragment"><div class="line">TestExceptions.catchSomething(int) /* java::TestExceptions.catchSomething:(I)V */</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">  this . com.diffblue.regression.TestExceptions.testException:(I)V(i);</div>
<div class="line">  IF @inflight_exception == null THEN GOTO 3 // true if testException does not throw, method terminates normally</div>
<div class="line">  IF !(@inflight_exception == null) THEN GOTO 1 // true if testException throws, enters catch block</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">1: __CPROVER_string class_identifier_tmp;</div>
<div class="line">  class_identifier_tmp = ((struct java.lang.Object *)@inflight_exception)-&gt;@class_identifier;</div>
<div class="line">  instanceof_result_tmp = class_identifier_tmp == &quot;java::java.lang.Exception&quot; || ... ; // TRUE</div>
<div class="line">  dead class_identifier_tmp;</div>
<div class="line">2: IF instanceof_result_tmp THEN GOTO 4</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">3: ASSERT false // block 3</div>
<div class="line">  GOTO 5</div>
<div class="line">4: void *anonlocal::2a; // The catch block</div>
<div class="line">  struct java.lang.Exception *caught_exception_tmp0;</div>
<div class="line">  ASSERT false // block 4</div>
<div class="line">  caught_exception_tmp0 = (struct java.lang.Exception *)@inflight_exception;</div>
<div class="line">  @inflight_exception = null;</div>
<div class="line">  anonlocal::2a = (void *)caught_exception_tmp0;</div>
<div class="line">  dead caught_exception_tmp0;</div>
<div class="line">  dead anonlocal::2a;</div>
<div class="line">5: ASSERT false // block 5</div>
<div class="line">6: END_FUNCTION</div>
</div><!-- fragment --><p> where the <code>CATCH-PUSH</code> has been replaced by a check on the <code>@inflight_exception</code> variable and goto statements, the <code>CATCH-POP</code> replaced by a check on the class of the exception and a goto statement, and the <code>EXCEPTION LANDING PAD</code> replaced by a section that assigns the exception to a local variable and sets the <code>@inflight_exception</code> back to null.</p>
<h1><a class="anchor" id="java-bytecode-remove-instanceof"></a>
Remove instanceof</h1>
<p><a class="el" href="remove__instanceof_8h.html">remove_instanceof.h</a> removes the bytecode instruction <code>instanceof</code> and replaces it with two instructions:</p><ul>
<li>check whether the pointer is null</li>
<li>if not null, does the class identifier match the type of any of its subtypes</li>
</ul>
<h1><a class="anchor" id="java-bytecode-method-stubbing"></a>
Method stubbing</h1>
<p>To be documented.</p>
<h1><a class="anchor" id="loading-strategies"></a>
Loading strategies</h1>
<p>Loading strategies are policies that determine what classes and method bodies are loaded. On an initial pass, the symbols for all classes in all paths on the Java classpath are loaded. Eager loading is a policy that then loads all the method bodies for every one of these classes. Lazy loading strategies are policies that only load class symbols and/or method bodies when they are in some way requested.</p>
<p>The mechanism used to achieve this is initially common to both eager and context-insensitive lazy loading. <a class="el" href="classjava__bytecode__languaget.html#ace19f032818c3c7e1de1361bc3650a8d">java_bytecode_languaget::typecheck</a> calls <a class="el" href="java__bytecode__convert__class_8h.html#af7a3fe36ba52d36981e6246210f47002">java_bytecode_convert_class</a> (for each class loaded by the class loader) to create symbols for all classes and the methods in them. The methods, along with their parsed representation (including bytecode) are also added to a map called <a class="el" href="classjava__bytecode__languaget.html#a5a546388c7120a31b02644110daa23f9">java_bytecode_languaget::method_bytecode</a> via a reference held in <a class="el" href="classjava__bytecode__convert__classt.html#a11734079bc5b012ce1fddf1f27d4e819">java_bytecode_convert_classt::method_bytecode</a>. typecheck then performs a switch over the value of <a class="el" href="structjava__bytecode__language__optionst.html#a775163efddaa5612d85a82122ee16888">lazy_methods_mode</a> to determine which loading strategy to use.</p>
<h2><a class="anchor" id="eager-loading"></a>
Eager loading</h2>
<p>If <a class="el" href="structjava__bytecode__language__optionst.html#a775163efddaa5612d85a82122ee16888">lazy_methods_mode</a> is <a class="el" href="java__bytecode__language_8h.html#a7ef72f294370e16463f94f040fe5bf8dad636f05d2c80aa7f717378dc7d6dfc5a">LAZY_METHODS_MODE_EAGER</a> then eager loading is used. Under eager loading <a class="el" href="classjava__bytecode__languaget.html#ac343289545e9ac9f1a0d7e3955241f1d">java_bytecode_languaget::convert_single_method(const irep_idt &amp;, symbol_table_baset &amp;, lazy_class_to_declared_symbols_mapt &amp;, message_handlert &amp;)</a> is called once for each method listed in method_bytecode (described above). This then calls <a class="el" href="classjava__bytecode__languaget.html#aef3549a65270ee75427996f9e26e262c">java_bytecode_languaget::convert_single_method(const irep_idt &amp;, symbol_table_baset &amp;, std::optional&lt;ci_lazy_methods_neededt&gt;, lazy_class_to_declared_symbols_mapt &amp;, message_handlert &amp;)</a>;</p>
<p>without a <a class="el" href="classci__lazy__methods__neededt.html">ci_lazy_methods_neededt</a> object, which calls <a class="el" href="java__bytecode__convert__method_8h.html#ae122c953df99a08d8ad8c1b1d770e909">java_bytecode_convert_method</a>, passing in the method parse tree. This in turn uses <a class="el" href="classjava__bytecode__convert__methodt.html">java_bytecode_convert_methodt</a> to turn the bytecode into symbols for the parameters and local variables and finish populating the symbol for the method, including converting the instructions to a codet.</p>
<h2><a class="anchor" id="java-bytecode-lazy-methods-v1"></a>
Context-Insensitive lazy methods (aka lazy methods v1)</h2>
<p>Context-insensitive lazy loading is an alternative method body loading strategy to eager loading that has been used in Deeptest for a while. Context-insensitive lazy loading starts at the method given by the <code>--function</code> argument and follows type references (e.g. in the definitions of fields and method parameters) and function references (at function call sites) to locate further classes and methods to load. The following paragraph describes the mechanism used.</p>
<p>If <a class="el" href="structjava__bytecode__language__optionst.html#a775163efddaa5612d85a82122ee16888">lazy_methods_mode</a> is <a class="el" href="java__bytecode__language_8h.html#a7ef72f294370e16463f94f040fe5bf8dafe4cb54de489dc520dfda5455f406cd0">LAZY_METHODS_MODE_CONTEXT_INSENSITIVE</a> then context-insensitive lazy loading is used. Under this stragegy <a class="el" href="classjava__bytecode__languaget.html#af3c3d0b2602e396881ae4ca9e156cbbc">java_bytecode_languaget::do_ci_lazy_method_conversion</a> is called to do all conversion. This calls <code>operator()</code> of <a class="el" href="classci__lazy__methodst.html">ci_lazy_methodst</a>, which creates a work list of methods to check, starting with the entry point, and classes, starting with the types of any class-typed parameters to the entry point. For each method in the work list it calls <a class="el" href="classci__lazy__methodst.html#a072ea53ae2629e4b51528f0c2f5896a8">ci_lazy_methodst::convert_and_analyze_method</a>, which calls the same <a class="el" href="classjava__bytecode__languaget.html#ac343289545e9ac9f1a0d7e3955241f1d">java_bytecode_languaget::convert_single_method</a> used by eager loading to do the conversion (via a <code>std::function</code> object passed in via parameter method_converter) and then calls <a class="el" href="classci__lazy__methodst.html#a7167a33904ceee4f98770ac8544bc701">ci_lazy_methodst::gather_virtual_callsites</a> to locate virtual calls. Any classes that may implement an override of the virtual function called are added to the work list. Finally the symbol table is iterated over and methods that have been converted, their parameters and local variables, globals accessed from these methods and classes are kept, everything else is thrown away. This leaves a symbol table that contains reachable symbols fully populated, including the instructions for methods converted to a <a class="el" href="classcodet.html">codet</a>.</p>
<h1><a class="anchor" id="java-bytecode-core-models-library"></a>
Core Models Library</h1>
<p>To be documented.</p>
<h1><a class="anchor" id="java-bytecode-java-types"></a>
java_types</h1>
<p>To be documented.</p>
<h1><a class="anchor" id="java-bytecode-string-library"></a>
String library</h1>
<p>To be documented.</p>
<p>See also <a class="el" href="group__solvers.html#string-solver-interface">String Solver Interface</a>.</p>
<h1><a class="anchor" id="java-bytecode-conversion-example-section"></a>
A worked example of converting java bytecode to codet</h1>
<p>To be documented.</p>
<h1><a class="anchor" id="java-trace"></a>
Java Trace Assumptions</h1>
<p>For high-level documentation about goto traces, see <a class="el" href="group__goto-programs.html#goto-trace-structure">Goto Trace Structure</a>.</p>
<p>There are three types of assignments to construct all types of Java objects:</p><ul>
<li>variable assignments (<a class="el" href="classsymbol__exprt.html">symbol_exprt</a>)</li>
<li>member assignments (<a class="el" href="classmember__exprt.html">member_exprt</a>)</li>
<li>index assignments (<a class="el" href="classindex__exprt.html">index_exprt</a>)</li>
</ul>
<p>We use the convention left-hand side (LHS) = right-hand side (RHS) to represent assignments in this document.</p>
<p>The expressions on each side vary depending on the type, whether its a member assignment, whether its an assignment by reference, etc. Some examples:</p><ul>
<li>A global variable assignment will have a LHS <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> containing the type information and an identifier that does not include a function identifier, e.g. <code>java::SomeClass.someGlobalField</code>, and a RHS expression containing the value, e.g. a <a class="el" href="classconstant__exprt.html">constant_exprt</a>, a <a class="el" href="classstruct__exprt.html">struct_exprt</a> or an <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a>. See <a class="el" href="group__java__bytecode.html#java-trace-variable-assignment">Variable assignments</a>.</li>
<li>A local variable assignment will have a LHS <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> containing the type information and an identifier that includes a function identifier, e.g. a parameter assignment like <code>java::SomeClass.&lt;init&gt;:()V::this</code> which corresponds to a symbol with <code>is_static_lifetime</code> set to true. See <a class="el" href="group__java__bytecode.html#java-trace-variable-assignment">Variable assignments</a>.</li>
<li>A member assignment will have a LHS <a class="el" href="classmember__exprt.html">member_exprt</a> containing the type information for the member, the component name (member name), and an operand for the containing class which contains an identifier for the containing class, a RHS expression containing the value. Inherited members have a nested member structure. Members of members are assigned using a series of single member assignments. See <a class="el" href="group__java__bytecode.html#java-trace-member-assignments">Member assignments</a>.</li>
<li>An array assignment consists of first assigning to a LHS <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> a RHS of type <code>java::array</code>, then if the array is non-empty it is followed by a series of <a class="el" href="classindex__exprt.html">index_exprt</a> assignments to assign elements to the array of the required type. A notable exception to this assignment structure is when arrays are created non-deterministically for primitive types - these are created by assigning an entire array to the <code>java::array</code> symbol instead of being built using index assignments. See <a class="el" href="group__java__bytecode.html#java-trace-array-assignments">Array assignments</a>.</li>
</ul>
<h2><a class="anchor" id="java-trace-variable-assignment"></a>
Variable assignments</h2>
<p>Variable assignments have LHS <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> with an identifier that reflects the variable name and scope and a RHS that is one of the following (noting that Strings are an exception, see <a class="el" href="group__java__bytecode.html#java-trace-string-assignments">String assignments</a>):</p><ul>
<li><a class="el" href="classconstant__exprt.html">constant_exprt</a> (primitives and addresses)</li>
<li><a class="el" href="classstruct__exprt.html">struct_exprt</a> (reference types, including Java arrays)</li>
<li><a class="el" href="classarray__exprt.html">array_exprt</a> (data within Java arrays)</li>
</ul>
<p>A primitive variable assignment has the form:</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with a value representing the primitive</li>
</ul>
<p>An assignment of a non-primitive (struct) variable can have the following forms:</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> = <a class="el" href="classstruct__exprt.html">struct_exprt</a></li>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with an <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to a symbol that has a <a class="el" href="classstruct__exprt.html">struct_exprt</a> value</li>
</ul>
<h2><a class="anchor" id="java-trace-member-assignments"></a>
Member assignments</h2>
<p><a class="el" href="classstruct__exprt.html">struct_exprt</a> that have members are constructed first by an assignment of the form</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> = <a class="el" href="classstruct__exprt.html">struct_exprt</a></li>
</ul>
<p>where the members of the <a class="el" href="classstruct__exprt.html">struct_exprt</a> are zero-initialized (null for <a class="el" href="classstruct__exprt.html">struct_exprt</a> and 0 for <a class="el" href="classconstant__exprt.html">constant_exprt</a>) then members can be assigned. For primitive members, this is a simple assignment to the member:</p><ul>
<li><a class="el" href="classmember__exprt.html">member_exprt</a> of the <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> containing the member = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with a value representing the primitive</li>
</ul>
<p>For members of reference type, the object to be assigned must first be created, then assigned by address, e.g.</p><ul>
<li><a class="el" href="classmember__exprt.html">member_exprt</a> of the <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> containing the member = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with an <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to a symbol that has a <a class="el" href="classstruct__exprt.html">struct_exprt</a> value.</li>
</ul>
<p>This concept becomes clearer with an example.</p>
<h2><a class="anchor" id="java-trace-member-assignment-example"></a>
Worked example for member assignments</h2>
<p>Consider the trace for the function call to <code>Example.assignReferenceTypes()</code>, which assigns a value to the static field <code>globalReferenceTypeReferenceField</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Example {</div>
<div class="line">  <span class="keyword">static</span> ReferenceTypeReferenceField globalReferenceTypeReferenceField;</div>
<div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> assignReferenceTypes() {</div>
<div class="line">    globalReferenceTypeReferenceField =</div>
<div class="line">        <span class="keyword">new</span> ReferenceTypeReferenceField(<span class="keyword">new</span> ReferenceTypePrimitiveField(5));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ReferenceTypeReferenceField {</div>
<div class="line">  ReferenceTypePrimitiveField referenceField;</div>
<div class="line">  <span class="keyword">public</span> ReferenceTypeReferenceField(ReferenceTypePrimitiveField <a class="code" href="irep__hash_8h.html#a6f2aef269e9e7c90182bcb65e01977d3">r</a>) {</div>
<div class="line">    referenceField = <a class="code" href="irep__hash_8h.html#a6f2aef269e9e7c90182bcb65e01977d3">r</a>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ReferenceTypePrimitiveField {</div>
<div class="line">  <span class="keywordtype">int</span> primitiveField;</div>
<div class="line">  <span class="keyword">public</span> ReferenceTypePrimitiveField(<span class="keywordtype">int</span> i) {</div>
<div class="line">    primitiveField = i;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="airep__hash_8h_html_a6f2aef269e9e7c90182bcb65e01977d3"><div class="ttname"><a href="irep__hash_8h.html#a6f2aef269e9e7c90182bcb65e01977d3">r</a></div><div class="ttdeci">static int8_t r</div><div class="ttdef"><b>Definition:</b> <a href="irep__hash_8h_source.html#l00059">irep_hash.h:60</a></div></div>
</div><!-- fragment --><p>There are 54 non-trivial steps in the trace to make this assignment. This example will give detail of the assignment steps only, filling in other steps with description.</p>
<p>CProver initialize initializes the instance of the class containing the function under test, Example, to have <code>null</code> static field:</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::ObjectReference.globalReferenceTypeReferenceField</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <code>null</code> value</li>
</ul>
<p>Objects are empty-initialized to build the assignment to <code>globalReferenceTypeReferenceField</code>. <code>symex_dynamic::dynamic_object1</code> represents <code>globalReferenceTypeReferenceField</code> and <code>symex_dynamic::dynamic_object2</code> represents <code>referenceField</code>.</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>symex_dynamic::dynamic_object1</code> = <a class="el" href="classstruct__exprt.html">struct_exprt</a> with <code>referenceField</code> set to <code>null</code> value</li>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>symex_dynamic::dynamic_object2</code> = <a class="el" href="classstruct__exprt.html">struct_exprt</a> with <code>primitiveField</code> set to <code>0</code></li>
</ul>
<p>Call to the constructor of <code>ReferenceTypePrimitiveField</code>, initializing the parameters <code>this</code> and <code>i</code></p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::ReferenceTypePrimitiveField.&lt;init&gt;:(I)V::this</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object2</code></li>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::ReferenceTypePrimitiveField.&lt;init&gt;:(I)V::i</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with value <code>5</code></li>
</ul>
<p>Call to the super constructor (Object). The <code>to_construct</code> parameter is internal</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::java.lang.Object.&lt;init&gt;:()V::this</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object2</code></li>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::java.lang.Object.&lt;init&gt;:()V::to_construct</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object2</code></li>
</ul>
<p>Setting the member of symex_dynamic::dynamic_object2, primitiveField. Note that primitives are always assigned using constant expressions with values.</p><ul>
<li><a class="el" href="classmember__exprt.html">member_exprt</a> <code>symex_dynamic::dynamic_object2.primitiveField</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with value <code>5</code></li>
</ul>
<p>Call to the constructor of ReferenceTypeReferenceField, initializing the parameters <code>this</code> and <code>r</code></p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::ReferenceTypeReferenceField.&lt;init&gt;:(LReferenceTypePrimitiveField;)V::this</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object1</code></li>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::ReferenceTypeReferenceField.&lt;init&gt;:(LReferenceTypePrimitiveField;)V::r</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object2</code></li>
</ul>
<p>Call to the super constructor (Object). The <code>to_construct</code> parameter is internal</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::java.lang.Object.&lt;init&gt;:()V::this</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object1</code></li>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::java.lang.Object.&lt;init&gt;:()V::to_construct</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object1</code></li>
</ul>
<p>Setting the member of symex_dynamic::dynamic_object1, referenceField. Note that this because referenceField is of struct type, it is assigned by reference.</p><ul>
<li><a class="el" href="classmember__exprt.html">member_exprt</a> <code>symex_dynamic::dynamic_object1.referenceField</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object2</code></li>
</ul>
<p>Finally, the actual assignment to globalReferenceTypeReferenceField is done by reference to the object we built symex_dynamic::dynamic_object1</p><ul>
<li><a class="el" href="classsymbol__exprt.html">symbol_exprt</a> <code>java::ObjectReference.globalReferenceTypeReferenceField</code> = <a class="el" href="classconstant__exprt.html">constant_exprt</a> with <a class="el" href="classaddress__of__exprt.html">address_of_exprt</a> pointing to <code>symex_dynamic::dynamic_object1</code></li>
</ul>
<h2><a class="anchor" id="java-trace-validation"></a>
Java trace validation</h2>
<p>Using the flag "--validate-trace" will call the function <a class="el" href="java__trace__validation_8h.html#a7c42b8bd008f03ba967065117064b137">check_trace_assumptions</a>, which will throw an error when these assumptions are not met.</p>
<h2><a class="anchor" id="java-trace-array-assignments"></a>
Array assignments</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="java-trace-string-assignments"></a>
String assignments</h2>
<p>To be documented. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
