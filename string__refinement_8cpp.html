<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: /home/runner/work/cbmc/cbmc/src/solvers/strings/string_refinement.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('string__refinement_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">string_refinement.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="string__refinement_8h_source.html">string_refinement.h</a>&quot;</code><br />
<code>#include &lt;<a class="el" href="satcheck_8h_source.html">solvers/sat/satcheck.h</a>&gt;</code><br />
<code>#include &lt;stack&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;<a class="el" href="expr__iterator_8h_source.html">util/expr_iterator.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="expr__util_8h_source.html">util/expr_util.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="format__type_8h_source.html">util/format_type.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="magic_8h_source.html">util/magic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="range_8h_source.html">util/range.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="simplify__expr_8h_source.html">util/simplify_expr.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="equation__symbol__mapping_8h_source.html">equation_symbol_mapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="string__constraint__instantiation_8h_source.html">string_constraint_instantiation.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="string__dependencies_8h_source.html">string_dependencies.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="string__refinement__invariant_8h_source.html">string_refinement_invariant.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for string_refinement.cpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="string__refinement_8cpp__incl.svg" width="2514" height="932"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="string__refinement_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0e03ce13d9c646a358ddb197f2d5fe9c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a0e03ce13d9c646a358ddb197f2d5fe9c">is_valid_string_constraint</a> (<a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="classstring__constraintt.html">string_constraintt</a> &amp;constraint)</td></tr>
<tr class="separator:a0e03ce13d9c646a358ddb197f2d5fe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec101bc8d654848c24932ff0e29d58"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#abbec101bc8d654848c24932ff0e29d58">find_counter_example</a> (const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="classexprt.html">exprt</a> &amp;axiom, const <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &amp;var, <a class="el" href="classmessage__handlert.html">message_handlert</a> &amp;message_handler)</td></tr>
<tr class="memdesc:abbec101bc8d654848c24932ff0e29d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a solver with <code>axiom</code> as the only formula added and runs it.  <a href="string__refinement_8cpp.html#abbec101bc8d654848c24932ff0e29d58">More...</a><br /></td></tr>
<tr class="separator:abbec101bc8d654848c24932ff0e29d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479ec7cdc1b70d68eefdc14deaaabfab"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; bool, std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a479ec7cdc1b70d68eefdc14deaaabfab">check_axioms</a> (const <a class="el" href="structstring__axiomst.html">string_axiomst</a> &amp;axioms, <a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a> &amp;generator, const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;get, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, bool use_counter_example, const <a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;symbol_resolve, const std::unordered_map&lt; <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a>, <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;not_contain_witnesses)</td></tr>
<tr class="memdesc:a479ec7cdc1b70d68eefdc14deaaabfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check axioms takes the model given by the underlying solver and answers whether it satisfies the string constraints.  <a href="string__refinement_8cpp.html#a479ec7cdc1b70d68eefdc14deaaabfab">More...</a><br /></td></tr>
<tr class="separator:a479ec7cdc1b70d68eefdc14deaaabfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01af496995e4473ade1505ec78db6fc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a01af496995e4473ade1505ec78db6fc1">initial_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="classstring__constraintt.html">string_constraintt</a> &amp;axiom)</td></tr>
<tr class="separator:a01af496995e4473ade1505ec78db6fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7cc64774c0f85bbc970c876407f594"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#aae7cc64774c0f85bbc970c876407f594">initial_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a> &amp;axiom)</td></tr>
<tr class="separator:aae7cc64774c0f85bbc970c876407f594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991d4e4c1957ba0deac23a69c3530be4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a991d4e4c1957ba0deac23a69c3530be4">initial_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="structstring__axiomst.html">string_axiomst</a> &amp;axioms)</td></tr>
<tr class="memdesc:a991d4e4c1957ba0deac23a69c3530be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the index set all the indices that appear in the formulas and the upper bound minus one.  <a href="string__refinement_8cpp.html#a991d4e4c1957ba0deac23a69c3530be4">More...</a><br /></td></tr>
<tr class="separator:a991d4e4c1957ba0deac23a69c3530be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846b09be0c9a450cf6bfe67b8894fc9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a846b09be0c9a450cf6bfe67b8894fc9f">simplify_sum</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;f)</td></tr>
<tr class="separator:a846b09be0c9a450cf6bfe67b8894fc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129aff44f6131c8a0e2ac21ee44eb5cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a129aff44f6131c8a0e2ac21ee44eb5cd">update_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &amp;current_constraints)</td></tr>
<tr class="memdesc:a129aff44f6131c8a0e2ac21ee44eb5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the index set all the indices that appear in the formulas.  <a href="string__refinement_8cpp.html#a129aff44f6131c8a0e2ac21ee44eb5cd">More...</a><br /></td></tr>
<tr class="separator:a129aff44f6131c8a0e2ac21ee44eb5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546fcdd903f84c2bc8c952399f5666b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a546fcdd903f84c2bc8c952399f5666b5">update_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="classexprt.html">exprt</a> &amp;formula)</td></tr>
<tr class="memdesc:a546fcdd903f84c2bc8c952399f5666b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the index set all the indices that appear in the formula.  <a href="string__refinement_8cpp.html#a546fcdd903f84c2bc8c952399f5666b5">More...</a><br /></td></tr>
<tr class="separator:a546fcdd903f84c2bc8c952399f5666b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf78f45de76eb13e6ad4569b9ab902da"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#acf78f45de76eb13e6ad4569b9ab902da">instantiate</a> (const <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a> &amp;axiom, const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const std::unordered_map&lt; <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a>, <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;witnesses)</td></tr>
<tr class="memdesc:acf78f45de76eb13e6ad4569b9ab902da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a quantified formula representing <code>not_contains</code> by substituting the quantifiers and generating axioms.  <a href="string__refinement_8cpp.html#acf78f45de76eb13e6ad4569b9ab902da">More...</a><br /></td></tr>
<tr class="separator:acf78f45de76eb13e6ad4569b9ab902da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169dbd85bda1139fdb38b1a6fb4d6cb7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a169dbd85bda1139fdb38b1a6fb4d6cb7">get_array</a> (const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;super_get, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;arr, const <a class="el" href="classarray__poolt.html">array_poolt</a> &amp;array_pool)</td></tr>
<tr class="memdesc:a169dbd85bda1139fdb38b1a6fb4d6cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a model of an array and put it in a certain form.  <a href="string__refinement_8cpp.html#a169dbd85bda1139fdb38b1a6fb4d6cb7">More...</a><br /></td></tr>
<tr class="separator:a169dbd85bda1139fdb38b1a6fb4d6cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77798cfbe8e41299c308e4ea68ea7e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#ad77798cfbe8e41299c308e4ea68ea7e9">substitute_array_access</a> (const <a class="el" href="classindex__exprt.html">index_exprt</a> &amp;index_expr, <a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;symbol_generator, const bool left_propagate)</td></tr>
<tr class="separator:ad77798cfbe8e41299c308e4ea68ea7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396e1c449e28ad3cd8bee9a157a36fa7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a396e1c449e28ad3cd8bee9a157a36fa7"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a396e1c449e28ad3cd8bee9a157a36fa7">fill_in_map_as_vector</a> (const std::map&lt; std::size_t, T &gt; &amp;index_value)</td></tr>
<tr class="memdesc:a396e1c449e28ad3cd8bee9a157a36fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert index-value map to a vector of values.  <a href="string__refinement_8cpp.html#a396e1c449e28ad3cd8bee9a157a36fa7">More...</a><br /></td></tr>
<tr class="separator:a396e1c449e28ad3cd8bee9a157a36fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ae9f77f37e8c92133b2f8a09a138a1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a72ae9f77f37e8c92133b2f8a09a138a1">validate</a> (const <a class="el" href="structstring__refinementt_1_1infot.html">string_refinementt::infot</a> &amp;info)</td></tr>
<tr class="separator:a72ae9f77f37e8c92133b2f8a09a138a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21a130d97489a6b2752b728a2608de7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#ab21a130d97489a6b2752b728a2608de7">display_index_set</a> (<a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set)</td></tr>
<tr class="memdesc:ab21a130d97489a6b2752b728a2608de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write index set to the given stream, use for debugging.  <a href="string__refinement_8cpp.html#ab21a130d97489a6b2752b728a2608de7">More...</a><br /></td></tr>
<tr class="separator:ab21a130d97489a6b2752b728a2608de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c296f3d6eae2764f28bf45efc96583"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a41c296f3d6eae2764f28bf45efc96583">generate_instantiations</a> (const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="structstring__axiomst.html">string_axiomst</a> &amp;axioms, const std::unordered_map&lt; <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a>, <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;not_contain_witnesses)</td></tr>
<tr class="memdesc:a41c296f3d6eae2764f28bf45efc96583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiation of all constraints.  <a href="string__refinement_8cpp.html#a41c296f3d6eae2764f28bf45efc96583">More...</a><br /></td></tr>
<tr class="separator:a41c296f3d6eae2764f28bf45efc96583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55da349c2aca1bb96d54a6bfbc9519a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a55da349c2aca1bb96d54a6bfbc9519a3">make_char_array_pointer_associations</a> (<a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a> &amp;generator, <a class="el" href="classexprt.html">exprt</a> &amp;expr)</td></tr>
<tr class="memdesc:a55da349c2aca1bb96d54a6bfbc9519a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>expr</code> is an equation whose right-hand-side is a associate_array_to_pointer call, add the correspondence and replace the call by an expression representing its result.  <a href="string__refinement_8cpp.html#a55da349c2aca1bb96d54a6bfbc9519a3">More...</a><br /></td></tr>
<tr class="separator:a55da349c2aca1bb96d54a6bfbc9519a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4ca87ce96f52665b50685416e276fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#abf4ca87ce96f52665b50685416e276fd">replace_expr_copy</a> (const <a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;symbol_resolve, <a class="el" href="classexprt.html">exprt</a> expr)</td></tr>
<tr class="memdesc:abf4ca87ce96f52665b50685416e276fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute sub-expressions in equation by representative elements of <code>symbol_resolve</code> whenever possible.  <a href="string__refinement_8cpp.html#abf4ca87ce96f52665b50685416e276fd">More...</a><br /></td></tr>
<tr class="separator:abf4ca87ce96f52665b50685416e276fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c3b1ce089bc308eec0b577a8ce4021"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a49c3b1ce089bc308eec0b577a8ce4021">add_equations_for_symbol_resolution</a> (<a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;symbol_solver, const std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &amp;equations, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream)</td></tr>
<tr class="memdesc:a49c3b1ce089bc308eec0b577a8ce4021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add association for each char pointer in the equation.  <a href="string__refinement_8cpp.html#a49c3b1ce089bc308eec0b577a8ce4021">More...</a><br /></td></tr>
<tr class="separator:a49c3b1ce089bc308eec0b577a8ce4021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0d69f0ef04535d468689c3ec4651de"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a0a0d69f0ef04535d468689c3ec4651de">extract_strings_from_lhs</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;lhs, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns)</td></tr>
<tr class="memdesc:a0a0d69f0ef04535d468689c3ec4651de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is meant to be used on the lhs of an equation with string subtype.  <a href="string__refinement_8cpp.html#a0a0d69f0ef04535d468689c3ec4651de">More...</a><br /></td></tr>
<tr class="separator:a0a0d69f0ef04535d468689c3ec4651de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7f12fa04a320094eea1b3b51725214"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a2d7f12fa04a320094eea1b3b51725214">extract_strings</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;expr, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns)</td></tr>
<tr class="separator:a2d7f12fa04a320094eea1b3b51725214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e555c7a9444102f7f994a77afa63fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a62e555c7a9444102f7f994a77afa63fe">add_string_equation_to_symbol_resolution</a> (const <a class="el" href="classequal__exprt.html">equal_exprt</a> &amp;eq, <a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;symbol_resolve, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns)</td></tr>
<tr class="memdesc:a62e555c7a9444102f7f994a77afa63fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an equation on strings, mark these strings as belonging to the same set in the <code>symbol_resolve</code> structure.  <a href="string__refinement_8cpp.html#a62e555c7a9444102f7f994a77afa63fe">More...</a><br /></td></tr>
<tr class="separator:a62e555c7a9444102f7f994a77afa63fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea4a14c3de95dcc0267c6e8ebc4b637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunion__find__replacet.html">union_find_replacet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#aaea4a14c3de95dcc0267c6e8ebc4b637">string_identifiers_resolution_from_equations</a> (const std::vector&lt; <a class="el" href="classequal__exprt.html">equal_exprt</a> &gt; &amp;equations, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream)</td></tr>
<tr class="memdesc:aaea4a14c3de95dcc0267c6e8ebc4b637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol resolution for expressions of type string typet.  <a href="string__refinement_8cpp.html#aaea4a14c3de95dcc0267c6e8ebc4b637">More...</a><br /></td></tr>
<tr class="separator:aaea4a14c3de95dcc0267c6e8ebc4b637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7cf6de41ab8bfb9e14445a59e57d81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#ace7cf6de41ab8bfb9e14445a59e57d81">get_valid_array_size</a> (const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;super_get, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;arr, const <a class="el" href="classarray__poolt.html">array_poolt</a> &amp;array_pool)</td></tr>
<tr class="memdesc:ace7cf6de41ab8bfb9e14445a59e57d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a model of the size of the input string.  <a href="string__refinement_8cpp.html#ace7cf6de41ab8bfb9e14445a59e57d81">More...</a><br /></td></tr>
<tr class="separator:ace7cf6de41ab8bfb9e14445a59e57d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e73fabc25ec14162a8a5302766081d1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a0e73fabc25ec14162a8a5302766081d1">string_of_array</a> (const <a class="el" href="classarray__exprt.html">array_exprt</a> &amp;arr)</td></tr>
<tr class="memdesc:a0e73fabc25ec14162a8a5302766081d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the content of a string to a more readable representation.  <a href="string__refinement_8cpp.html#a0e73fabc25ec14162a8a5302766081d1">More...</a><br /></td></tr>
<tr class="separator:a0e73fabc25ec14162a8a5302766081d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26bca06fe203d2c38f5cfea7b023e95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#af26bca06fe203d2c38f5cfea7b023e95">get_char_array_and_concretize</a> (const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;super_get, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;arr, <a class="el" href="classarray__poolt.html">array_poolt</a> &amp;array_pool)</td></tr>
<tr class="memdesc:af26bca06fe203d2c38f5cfea7b023e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function which finds the valuation of the given array in <code>super_get</code> and concretize unknown characters.  <a href="string__refinement_8cpp.html#af26bca06fe203d2c38f5cfea7b023e95">More...</a><br /></td></tr>
<tr class="separator:af26bca06fe203d2c38f5cfea7b023e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871a1614ff2ca00aeac5dbd91d2369b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#ac871a1614ff2ca00aeac5dbd91d2369b">debug_model</a> (const <a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a> &amp;generator, <a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;super_get, const std::vector&lt; <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;symbols, <a class="el" href="classarray__poolt.html">array_poolt</a> &amp;array_pool)</td></tr>
<tr class="memdesc:ac871a1614ff2ca00aeac5dbd91d2369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display part of the current model by mapping the variables created by the solver to constant expressions given by the current model.  <a href="string__refinement_8cpp.html#ac871a1614ff2ca00aeac5dbd91d2369b">More...</a><br /></td></tr>
<tr class="separator:ac871a1614ff2ca00aeac5dbd91d2369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8e3229c296bfae89e6810d022c550b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#aad8e3229c296bfae89e6810d022c550b">substitute_array_access</a> (const <a class="el" href="classwith__exprt.html">with_exprt</a> &amp;expr, const <a class="el" href="classexprt.html">exprt</a> &amp;index, const bool left_propagate)</td></tr>
<tr class="memdesc:aad8e3229c296bfae89e6810d022c550b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression where 'with' expressions on arrays are replaced by 'if' expressions.  <a href="string__refinement_8cpp.html#aad8e3229c296bfae89e6810d022c550b">More...</a><br /></td></tr>
<tr class="separator:aad8e3229c296bfae89e6810d022c550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0781922cc5aa65dddef7d7b466a89375"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a0781922cc5aa65dddef7d7b466a89375">substitute_array_access</a> (const <a class="el" href="classarray__exprt.html">array_exprt</a> &amp;array_expr, const <a class="el" href="classexprt.html">exprt</a> &amp;index, <a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;symbol_generator)</td></tr>
<tr class="memdesc:a0781922cc5aa65dddef7d7b466a89375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an equivalent expression where array accesses are replaced by 'if' expressions: for instance in array access <code>arr[index]</code>, where: <code>arr := {12, 24, 48}</code> the constructed expression will be: <code>index==0 ? 12 : index==1 ? 24 : 48</code> Avoids repetition so <code>arr := {12, 12, 24, 48}</code> will give <code>index&lt;=1 ? 12 : index==1 ? 24 : 48</code>  <a href="string__refinement_8cpp.html#a0781922cc5aa65dddef7d7b466a89375">More...</a><br /></td></tr>
<tr class="separator:a0781922cc5aa65dddef7d7b466a89375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf58eb79147bd2487ac6225f6fee8687"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#acf58eb79147bd2487ac6225f6fee8687">substitute_array_access</a> (const <a class="el" href="classif__exprt.html">if_exprt</a> &amp;if_expr, const <a class="el" href="classexprt.html">exprt</a> &amp;index, <a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;symbol_generator, const bool left_propagate)</td></tr>
<tr class="separator:acf58eb79147bd2487ac6225f6fee8687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19b40ec64e6315fb050b965fca62e51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#ac19b40ec64e6315fb050b965fca62e51">substitute_array_access_in_place</a> (<a class="el" href="classexprt.html">exprt</a> &amp;expr, <a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;symbol_generator, const bool left_propagate)</td></tr>
<tr class="memdesc:ac19b40ec64e6315fb050b965fca62e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function for substitute_array_access Performs the same operation but modifies the argument instead of returning the resulting expression.  <a href="string__refinement_8cpp.html#ac19b40ec64e6315fb050b965fca62e51">More...</a><br /></td></tr>
<tr class="separator:ac19b40ec64e6315fb050b965fca62e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c39282a58c54b5d804207f121ac88fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a7c39282a58c54b5d804207f121ac88fa">substitute_array_access</a> (<a class="el" href="classexprt.html">exprt</a> expr, <a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;symbol_generator, const bool left_propagate)</td></tr>
<tr class="memdesc:a7c39282a58c54b5d804207f121ac88fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an equivalent expression where array accesses and 'with' expressions are replaced by 'if' expressions, in particular:  <a href="string__refinement_8cpp.html#a7c39282a58c54b5d804207f121ac88fa">More...</a><br /></td></tr>
<tr class="separator:a7c39282a58c54b5d804207f121ac88fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb198cdcba7146f53b39447923ed879"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#abbb198cdcba7146f53b39447923ed879">negation_of_not_contains_constraint</a> (const <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a> &amp;constraint, const <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &amp;univ_var, const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;get)</td></tr>
<tr class="memdesc:abbb198cdcba7146f53b39447923ed879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the constraint to be fed to a solver.  <a href="string__refinement_8cpp.html#abbb198cdcba7146f53b39447923ed879">More...</a><br /></td></tr>
<tr class="separator:abbb198cdcba7146f53b39447923ed879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce00a7ac4a9effc0a4d1151d5d1f7ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adce00a7ac4a9effc0a4d1151d5d1f7ff"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#adce00a7ac4a9effc0a4d1151d5d1f7ff">debug_check_axioms_step</a> (<a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;stream, const T &amp;axiom, const T &amp;axiom_in_model, const <a class="el" href="classexprt.html">exprt</a> &amp;negaxiom, const <a class="el" href="classexprt.html">exprt</a> &amp;with_concretized_arrays)</td></tr>
<tr class="memdesc:adce00a7ac4a9effc0a4d1151d5d1f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function which outputs the different steps an axiom goes through to be checked in check axioms.  <a href="string__refinement_8cpp.html#adce00a7ac4a9effc0a4d1151d5d1f7ff">More...</a><br /></td></tr>
<tr class="separator:adce00a7ac4a9effc0a4d1151d5d1f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d76a2d787e4165df1a39c6772026f0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#ac5d76a2d787e4165df1a39c6772026f0">get_sub_arrays</a> (const <a class="el" href="classexprt.html">exprt</a> &amp;array_expr, std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &amp;accu)</td></tr>
<tr class="memdesc:ac5d76a2d787e4165df1a39c6772026f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression representing an array of characters can be in the form of an if expression for instance <code>cond?array1:(cond2:array2:array3)</code>.  <a href="string__refinement_8cpp.html#ac5d76a2d787e4165df1a39c6772026f0">More...</a><br /></td></tr>
<tr class="separator:ac5d76a2d787e4165df1a39c6772026f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f96fdd4f2958bd8ce2c568774b0bcf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a77f96fdd4f2958bd8ce2c568774b0bcf">add_to_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="classexprt.html">exprt</a> &amp;s, <a class="el" href="classexprt.html">exprt</a> i)</td></tr>
<tr class="memdesc:a77f96fdd4f2958bd8ce2c568774b0bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <code>i</code> to the index set all the indices that appear in the formula.  <a href="string__refinement_8cpp.html#a77f96fdd4f2958bd8ce2c568774b0bcf">More...</a><br /></td></tr>
<tr class="separator:a77f96fdd4f2958bd8ce2c568774b0bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc8b23573f6ea21b43715c62b7a7593"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a3bc8b23573f6ea21b43715c62b7a7593">initial_index_set</a> (<a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;index_set, const <a class="el" href="classnamespacet.html">namespacet</a> &amp;ns, const <a class="el" href="classexprt.html">exprt</a> &amp;qvar, const <a class="el" href="classexprt.html">exprt</a> &amp;upper_bound, const <a class="el" href="classexprt.html">exprt</a> &amp;s, const <a class="el" href="classexprt.html">exprt</a> &amp;i)</td></tr>
<tr class="memdesc:a3bc8b23573f6ea21b43715c62b7a7593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array access of the form <em>s</em>[i] assumed to be part of a formula \( \forall q &lt; u. charconstraint \), initialize the index set of <em>s</em> so that:  <a href="string__refinement_8cpp.html#a3bc8b23573f6ea21b43715c62b7a7593">More...</a><br /></td></tr>
<tr class="separator:a3bc8b23573f6ea21b43715c62b7a7593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328b5b84b55d64e104c2310951efc622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classexprt.html">exprt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="string__refinement_8cpp.html#a328b5b84b55d64e104c2310951efc622">substitute_array_lists</a> (<a class="el" href="classexprt.html">exprt</a> expr, size_t string_max_length)</td></tr>
<tr class="memdesc:a328b5b84b55d64e104c2310951efc622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace array-lists by 'with' expressions.  <a href="string__refinement_8cpp.html#a328b5b84b55d64e104c2310951efc622">More...</a><br /></td></tr>
<tr class="separator:a328b5b84b55d64e104c2310951efc622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>String support via creating string constraints and progressively instantiating the universal constraints as needed. The procedure is described in the PASS paper at HVC'13: "PASS: String Solving with
  Parameterized Array and Interval Automaton" by Guodong Li and Indradeep Ghosh. </p>

<p class="definition">Definition in file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a49c3b1ce089bc308eec0b577a8ce4021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c3b1ce089bc308eec0b577a8ce4021">&#9670;&nbsp;</a></span>add_equations_for_symbol_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_equations_for_symbol_resolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>equations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add association for each char pointer in the equation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">symbol_solver</td><td>a <a class="el" href="classunion__find__replacet.html" title="Similar interface to union-find for expressions, with a function for replacing sub-expressions by the...">union_find_replacet</a> object to keep track of char pointer equations. Char pointers that have been set equal by an equation are associated to the same element. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">equations</td><td>vector of equations </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stream</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00300">300</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a62e555c7a9444102f7f994a77afa63fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e555c7a9444102f7f994a77afa63fe">&#9670;&nbsp;</a></span>add_string_equation_to_symbol_resolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_string_equation_to_symbol_resolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classequal__exprt.html">equal_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_resolve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an equation on strings, mark these strings as belonging to the same set in the <code>symbol_resolve</code> structure. </p>
<p>The lhs and rhs of the equation, should have string type or be struct with string members. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eq</td><td>equation to add </td></tr>
    <tr><td class="paramname">symbol_resolve</td><td>structure to which the equation will be added </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00426">426</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a77f96fdd4f2958bd8ce2c568774b0bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f96fdd4f2958bd8ce2c568774b0bcf">&#9670;&nbsp;</a></span>add_to_index_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void add_to_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classexprt.html">exprt</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <code>i</code> to the index set all the indices that appear in the formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>set of indexes </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">s</td><td>an expression containing strings </td></tr>
    <tr><td class="paramname">i</td><td>an expression representing an index </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01572">1572</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a479ec7cdc1b70d68eefdc14deaaabfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479ec7cdc1b70d68eefdc14deaaabfab">&#9670;&nbsp;</a></span>check_axioms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; bool, std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &gt; check_axioms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstring__axiomst.html">string_axiomst</a> &amp;&#160;</td>
          <td class="paramname"><em>axioms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_counter_example</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_resolve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a>, <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>not_contain_witnesses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check axioms takes the model given by the underlying solver and answers whether it satisfies the string constraints. </p>
<p>For each string_constraint <code>a</code>:</p><ul>
<li>the negation of <code>a</code> is an existential formula <code>b</code>;</li>
<li>we substituted symbols in <code>b</code> by their values found in <code>get</code>;</li>
<li>arrays are concretized, meaning we attribute a value for characters that are unknown to get, for details see substitute_array_access;</li>
<li><code>b</code> is simplified and array accesses are replaced by expressions without arrays;</li>
<li>we give lemma <code>b</code> to a fresh solver;</li>
<li>if no counter-example to <code>b</code> is found, this means the constraint <code>a</code> is satisfied by the valuation given by get. <dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current model satisfies all the axioms, <code>false</code> otherwise with a list of lemmas which are obtained by instantiating constraints at indexes given by counter-examples.</dd>
<dd>
true if the current model satisfies all the axioms </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01350">1350</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="adce00a7ac4a9effc0a4d1151d5d1f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce00a7ac4a9effc0a4d1151d5d1f7ff">&#9670;&nbsp;</a></span>debug_check_axioms_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void debug_check_axioms_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axiom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>axiom_in_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>negaxiom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>with_concretized_arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debugging function which outputs the different steps an axiom goes through to be checked in check axioms. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>can be either <a class="el" href="classstring__constraintt.html">string_constraintt</a> or <a class="el" href="structstring__not__contains__constraintt.html" title="Constraints to encode non containement of strings.">string_not_contains_constraintt</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01330">1330</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="ac871a1614ff2ca00aeac5dbd91d2369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac871a1614ff2ca00aeac5dbd91d2369b">&#9670;&nbsp;</a></span>debug_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debug_model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>super_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarray__poolt.html">array_poolt</a> &amp;&#160;</td>
          <td class="paramname"><em>array_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display part of the current model by mapping the variables created by the solver to constant expressions given by the current model. </p>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01115">1115</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="ab21a130d97489a6b2752b728a2608de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21a130d97489a6b2752b728a2608de7">&#9670;&nbsp;</a></span>display_index_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void display_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write index set to the given stream, use for debugging. </p>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00172">172</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a2d7f12fa04a320094eea1b3b51725214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7f12fa04a320094eea1b3b51725214">&#9670;&nbsp;</a></span>extract_strings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classexprt.html">exprt</a>&gt; extract_strings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>an expression </td></tr>
    <tr><td class="paramname">ns</td><td>namespace to resolve type tags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all subexpressions of type string which are not <a class="el" href="classif__exprt.html" title="The trinary if-then-else operator.">if_exprt</a> expressions this includes expressions of the form <code>e.x</code> if e is a symbol subexpression with a field <code>x</code> of type string </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00398">398</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a0a0d69f0ef04535d468689c3ec4651de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0d69f0ef04535d468689c3ec4651de">&#9670;&nbsp;</a></span>extract_strings_from_lhs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classexprt.html">exprt</a>&gt; extract_strings_from_lhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is meant to be used on the lhs of an equation with string subtype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>expression which is either of string type, or a symbol representing a struct with some string members </td></tr>
    <tr><td class="paramname">ns</td><td>namespace to resolve type tags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if lhs is a string return this string, if it is a struct return the members of the expression that have string type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00373">373</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a396e1c449e28ad3cd8bee9a157a36fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396e1c449e28ad3cd8bee9a157a36fa7">&#9670;&nbsp;</a></span>fill_in_map_as_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;T&gt; fill_in_map_as_vector </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::size_t, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert index-value map to a vector of values. </p>
<p>If a value for an index is not defined, set it to the value referenced by the next higher index. The length of the resulting vector is the key of the map's last element + 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_value</td><td>map containing values of specific vector cells </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing values as described in the map </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00130">130</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="abbec101bc8d654848c24932ff0e29d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbec101bc8d654848c24932ff0e29d58">&#9670;&nbsp;</a></span>find_counter_example()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt; find_counter_example </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>axiom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessage__handlert.html">message_handlert</a> &amp;&#160;</td>
          <td class="paramname"><em>message_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a solver with <code>axiom</code> as the only formula added and runs it. </p>
<p>If it is SAT, then true is returned and the given evaluation of <code>var</code> is stored in <code>witness</code>. If UNSAT, then what witness is is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axiom</td><td>the axiom to be checked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>the variable whose evaluation will be stored in witness </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">message_handler</td><td>message handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the witness of the satisfying assignment if one exists. If UNSAT, then behaviour is undefined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01907">1907</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a41c296f3d6eae2764f28bf45efc96583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c296f3d6eae2764f28bf45efc96583">&#9670;&nbsp;</a></span>generate_instantiations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;<a class="el" href="classexprt.html">exprt</a>&gt; generate_instantiations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstring__axiomst.html">string_axiomst</a> &amp;&#160;</td>
          <td class="paramname"><em>axioms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a>, <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>not_contain_witnesses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiation of all constraints. </p>
<p>The string refinement decision procedure works with two types of quantified axioms, which are of the form \(\forall x.\ P(x)\) (<code><a class="el" href="classstring__constraintt.html">string_constraintt</a></code>) or of the form \(\forall x. P(x) \Rightarrow \exists y .s_0[x+y] \ne s_1[y] \) (<code><a class="el" href="structstring__not__contains__constraintt.html" title="Constraints to encode non containement of strings.">string_not_contains_constraintt</a></code>). They are instantiated in a way which depends on their form:</p><ul>
<li>For formulas of the form \(\forall x.\ P(x)\) if string <code>str</code> appears in <code>P</code> indexed by some <code>f(x)</code> and <code>val</code> is in the index set of <code>str</code> we find <code>y</code> such that <code>f(y)=val</code> and add lemma <code>P(y)</code>. (See <code>instantiate(<a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a>&amp;, const <a class="el" href="classstring__constraintt.html">string_constraintt</a>&amp;, const exprt &amp;, const exprt&amp;)</code> for details.)</li>
<li>For formulas of the form \(\forall x. P(x) \Rightarrow \exists y .s_0[x+y] \ne s_1[y]) \) we need to look at the index set of both <code>s_0</code> and <code>s_1</code>. (See <code>instantiate(const <a class="el" href="structstring__not__contains__constraintt.html" title="Constraints to encode non containement of strings.">string_not_contains_constraintt</a>&amp;, const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a>&amp;, const std::map&lt;string_not_contains_constraintt, symbol_exprt&gt;&amp;)</code> for details.) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00220">220</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a169dbd85bda1139fdb38b1a6fb4d6cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169dbd85bda1139fdb38b1a6fb4d6cb7">&#9670;&nbsp;</a></span>get_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt; get_array </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>super_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__poolt.html">array_poolt</a> &amp;&#160;</td>
          <td class="paramname"><em>array_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a model of an array and put it in a certain form. </p>
<p>If the model is incomplete or if it is too big, return no value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super_get</td><td>function returning the valuation of an expression in a model </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">stream</td><td>output stream for warning messages </td></tr>
    <tr><td class="paramname">arr</td><td>expression of type array representing a string </td></tr>
    <tr><td class="paramname">array_pool</td><td>pool of arrays representing strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optional array expression or <a class="el" href="classarray__of__exprt.html" title="Array constructor from single element.">array_of_exprt</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01001">1001</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="af26bca06fe203d2c38f5cfea7b023e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26bca06fe203d2c38f5cfea7b023e95">&#9670;&nbsp;</a></span>get_char_array_and_concretize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classexprt.html">exprt</a> get_char_array_and_concretize </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>super_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classarray__poolt.html">array_poolt</a> &amp;&#160;</td>
          <td class="paramname"><em>array_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debugging function which finds the valuation of the given array in <code>super_get</code> and concretize unknown characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super_get</td><td>give a valuation to variables </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">stream</td><td>output stream </td></tr>
    <tr><td class="paramname">arr</td><td>array expression </td></tr>
    <tr><td class="paramname">array_pool</td><td>pool of arrays representing strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expression corresponding to <code>arr</code> in the model </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01067">1067</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="ac5d76a2d787e4165df1a39c6772026f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d76a2d787e4165df1a39c6772026f0">&#9670;&nbsp;</a></span>get_sub_arrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void get_sub_arrays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>array_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>accu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An expression representing an array of characters can be in the form of an if expression for instance <code>cond?array1:(cond2:array2:array3)</code>. </p>
<p>We return all the array expressions contained in <code>array_expr</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_expr</td><td>an expression representing an array </td></tr>
    <tr><td class="paramname">accu</td><td>a vector to which symbols and constant arrays contained in the expression will be appended </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01545">1545</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="ace7cf6de41ab8bfb9e14445a59e57d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7cf6de41ab8bfb9e14445a59e57d81">&#9670;&nbsp;</a></span>get_valid_array_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt;<a class="el" href="classexprt.html">exprt</a>&gt; get_valid_array_size </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>super_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__string__exprt.html">array_string_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarray__poolt.html">array_poolt</a> &amp;&#160;</td>
          <td class="paramname"><em>array_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a model of the size of the input string. </p>
<p>First ask the solver for a size value. If the solver has no value, get the size directly from the type. This is the case for string literals that are not part of the decision procedure (e.g. literals in return values). If the size value is not a constant or not a valid integer (size_t), return no value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super_get</td><td>function returning the valuation of an expression in a model </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">stream</td><td>output stream for warning messages </td></tr>
    <tr><td class="paramname">arr</td><td>expression of type array representing a string </td></tr>
    <tr><td class="paramname">array_pool</td><td>pool of arrays representing strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optional expression representing the size of the array that can be cast to size_t </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00957">957</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a3bc8b23573f6ea21b43715c62b7a7593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc8b23573f6ea21b43715c62b7a7593">&#9670;&nbsp;</a></span>initial_index_set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void initial_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>qvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an array access of the form <em>s</em>[i] assumed to be part of a formula \( \forall q &lt; u. charconstraint \), initialize the index set of <em>s</em> so that: </p>
<ul>
<li>\( i[q -&gt; u - 1] \) appears in the index set of <em>s</em> if <em>s&#160;is</em> a symbol</li>
<li>if <em>s</em> is an array expression, all index from <em>0</em> to \( s.length - 1 \) are in the index set</li>
<li>if <em>s</em> is an if expression we apply this procedure to the true and false cases <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>the index_set to initialize </td></tr>
    <tr><td class="paramname">ns</td><td>namespace, used for simplifying indexes </td></tr>
    <tr><td class="paramname">qvar</td><td>the quantified variable <em>q</em> </td></tr>
    <tr><td class="paramname">upper_bound</td><td>bound <em>u</em> on the quantified variable </td></tr>
    <tr><td class="paramname">s</td><td>expression representing a string </td></tr>
    <tr><td class="paramname">i</td><td>expression representing the index at which <em>s</em> is accessed </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01605">1605</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a991d4e4c1957ba0deac23a69c3530be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991d4e4c1957ba0deac23a69c3530be4">&#9670;&nbsp;</a></span>initial_index_set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void initial_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstring__axiomst.html">string_axiomst</a> &amp;&#160;</td>
          <td class="paramname"><em>axioms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add to the index set all the indices that appear in the formulas and the upper bound minus one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>set of indexes to update </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">axioms</td><td>a list of string axioms </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01515">1515</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a01af496995e4473ade1505ec78db6fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01af496995e4473ade1505ec78db6fc1">&#9670;&nbsp;</a></span>initial_index_set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void initial_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstring__constraintt.html">string_constraintt</a> &amp;&#160;</td>
          <td class="paramname"><em>axiom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01634">1634</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="aae7cc64774c0f85bbc970c876407f594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7cc64774c0f85bbc970c876407f594">&#9670;&nbsp;</a></span>initial_index_set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void initial_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a> &amp;&#160;</td>
          <td class="paramname"><em>axiom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01657">1657</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="acf78f45de76eb13e6ad4569b9ab902da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf78f45de76eb13e6ad4569b9ab902da">&#9670;&nbsp;</a></span>instantiate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; instantiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a> &amp;&#160;</td>
          <td class="paramname"><em>axiom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a>, <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>witnesses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiates a quantified formula representing <code>not_contains</code> by substituting the quantifiers and generating axioms. </p>
<p>For a formula of the form \(\phi = \forall x. P(x) \Rightarrow Q(x, f(x))\) let \(instantiate\_not\_contains(\phi) = ( (f(t) = u) \land P(t) ) \Rightarrow Q(t, u)\). Then \(\forall x.\ P(x) \Rightarrow Q(x, f(x)) \models \) Axioms of the form \(\forall x. P(x) \Rightarrow \exists y .Q(x, y) \) can be transformed into the the equisatisfiable formula \(\forall x. P(x) \Rightarrow Q(x, f(x))\) for a new function symbol <code>f</code>. Hence, after transforming axioms of the second type and by the above lemmas, we can create quantifier free formulas that are entailed by a (transformed) axiom. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axiom</td><td>the axiom to instantiate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">index_set</td><td>set of indexes </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">witnesses</td><td><code>axiom's</code> witnesses for non-containment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the lemmas produced through instantiation </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01738">1738</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a0e03ce13d9c646a358ddb197f2d5fe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e03ce13d9c646a358ddb197f2d5fe9c">&#9670;&nbsp;</a></span>is_valid_string_constraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool is_valid_string_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classstring__constraintt.html">string_constraintt</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55da349c2aca1bb96d54a6bfbc9519a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55da349c2aca1bb96d54a6bfbc9519a3">&#9670;&nbsp;</a></span>make_char_array_pointer_associations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void make_char_array_pointer_associations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>expr</code> is an equation whose right-hand-side is a associate_array_to_pointer call, add the correspondence and replace the call by an expression representing its result. </p>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00247">247</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="abbb198cdcba7146f53b39447923ed879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb198cdcba7146f53b39447923ed879">&#9670;&nbsp;</a></span>negation_of_not_contains_constraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classexprt.html">exprt</a> negation_of_not_contains_constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstring__not__contains__constraintt.html">string_not_contains_constraintt</a> &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsymbol__exprt.html">symbol_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>univ_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classexprt.html">exprt</a>(const <a class="el" href="classexprt.html">exprt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates the constraint to be fed to a solver. </p>
<p>The intended usage is to find an assignment of the universal variable that would violate the axiom. To avoid false positives, the symbols other than the universal variable should have been replaced by their valuation in the current model. </p><dl class="section pre"><dt>Precondition</dt><dd>Symbols other than the universal variable should have been replaced by their valuation in the current model. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>the not_contains constraint to add the negation of </td></tr>
    <tr><td class="paramname">univ_var</td><td>the universal variable for the negation of the axiom </td></tr>
    <tr><td class="paramname">get</td><td>valuation function, the result should have been simplified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the negation of the axiom under the current evaluation </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01289">1289</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="abf4ca87ce96f52665b50685416e276fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4ca87ce96f52665b50685416e276fd">&#9670;&nbsp;</a></span>replace_expr_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classexprt.html">exprt</a> replace_expr_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classunion__find__replacet.html">union_find_replacet</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_resolve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classexprt.html">exprt</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitute sub-expressions in equation by representative elements of <code>symbol_resolve</code> whenever possible. </p>
<p>Similar to <code>symbol_resolve.replace_expr</code> but doesn't mutate the expression and returns the transformed expression instead. </p>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00273">273</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a846b09be0c9a450cf6bfe67b8894fc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846b09be0c9a450cf6bfe67b8894fc9f">&#9670;&nbsp;</a></span>simplify_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexprt.html">exprt</a> simplify_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>an expression with only plus and minus expr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an equivalent expression in a canonical form </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01505">1505</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="aaea4a14c3de95dcc0267c6e8ebc4b637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea4a14c3de95dcc0267c6e8ebc4b637">&#9670;&nbsp;</a></span>string_identifiers_resolution_from_equations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunion__find__replacet.html">union_find_replacet</a> string_identifiers_resolution_from_equations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classequal__exprt.html">equal_exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>equations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbol resolution for expressions of type string typet. </p>
<p>We record equality between these expressions in the output if one of the function calls depends on them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equations</td><td>list of equations </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">stream</td><td>output stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classunion__find__replacet.html" title="Similar interface to union-find for expressions, with a function for replacing sub-expressions by the...">union_find_replacet</a> structure containing the correspondences. </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00462">462</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a0e73fabc25ec14162a8a5302766081d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e73fabc25ec14162a8a5302766081d1">&#9670;&nbsp;</a></span>string_of_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string string_of_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__exprt.html">array_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the content of a string to a more readable representation. </p>
<p>This should only be used for debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>a constant array expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01049">1049</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a0781922cc5aa65dddef7d7b466a89375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0781922cc5aa65dddef7d7b466a89375">&#9670;&nbsp;</a></span>substitute_array_access() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classexprt.html">exprt</a> substitute_array_access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray__exprt.html">array_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>array_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an equivalent expression where array accesses are replaced by 'if' expressions: for instance in array access <code>arr[index]</code>, where: <code>arr := {12, 24, 48}</code> the constructed expression will be: <code>index==0 ? 12 : index==1 ? 24 : 48</code> Avoids repetition so <code>arr := {12, 12, 24, 48}</code> will give <code>index&lt;=1 ? 12 : index==1 ? 24 : 48</code> </p>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01170">1170</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="acf58eb79147bd2487ac6225f6fee8687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf58eb79147bd2487ac6225f6fee8687">&#9670;&nbsp;</a></span>substitute_array_access() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classexprt.html">exprt</a> substitute_array_access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classif__exprt.html">if_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>if_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>left_propagate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01181">1181</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="ad77798cfbe8e41299c308e4ea68ea7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77798cfbe8e41299c308e4ea68ea7e9">&#9670;&nbsp;</a></span>substitute_array_access() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="optional_8h.html#ad5436a839660990c49c85e1b84723a69">optionalt</a>&lt; <a class="el" href="classexprt.html">exprt</a> &gt; substitute_array_access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classindex__exprt.html">index_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>left_propagate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01202">1202</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="aad8e3229c296bfae89e6810d022c550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8e3229c296bfae89e6810d022c550b">&#9670;&nbsp;</a></span>substitute_array_access() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classexprt.html">exprt</a> substitute_array_access </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwith__exprt.html">with_exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>left_propagate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new expression where 'with' expressions on arrays are replaced by 'if' expressions. </p>
<p>e.g. for an array access arr[index], where: <code>arr := array_of(12) with {0:=24} with {2:=42}</code> the constructed expression will be: <code>index==0 ? 24 : index==2 ? 42 : 12</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>A (possibly nested) 'with' expression on an <code>array_of</code> expression. The function checks that the expression is of the form <code>with_expr(with_expr(...(array_of(...)))</code>. This is the form in which array valuations coming from the underlying solver are given. </td></tr>
    <tr><td class="paramname">index</td><td>An index with which to build the equality condition </td></tr>
    <tr><td class="paramname">left_propagate</td><td>If set to true, the expression will look like <code>index&lt;=0 ? 24 : index&lt;=2 ? 42 : 12</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression containing no 'with' expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01155">1155</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a7c39282a58c54b5d804207f121ac88fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c39282a58c54b5d804207f121ac88fa">&#9670;&nbsp;</a></span>substitute_array_access() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexprt.html">exprt</a> substitute_array_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classexprt.html">exprt</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>left_propagate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an equivalent expression where array accesses and 'with' expressions are replaced by 'if' expressions, in particular: </p>
<ul>
<li>for an array access <code>arr[index]</code>, where: <code>arr := {12, 24, 48}</code> the constructed expression will be: <code>index==0 ? 12 : index==1 ? 24 : 48</code></li>
<li>for an array access <code>arr[index]</code>, where: <code>arr := array_of(12) with {0:=24} with {2:=42}</code> the constructed expression will be: <code>index==0 ? 24 : index==2 ? 42 : 12</code></li>
<li>for an array access <code>(g1?arr1:arr2)[x]</code> where <code>arr1 := {12}</code> and <code>arr2 := {34}</code>, the constructed expression will be: <code>g1 ? 12 : 34</code></li>
<li>for an access in an empty array <code>{ }[x]</code> returns a fresh symbol, this corresponds to a non-deterministic result Note that if left_propagate is set to true, the <code>with</code> case will result in something like: <code>index &lt;= 0 ? 24 : index &lt;= 2 ? 42 : 12</code> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>an expression containing array accesses </td></tr>
    <tr><td class="paramname">symbol_generator</td><td>a symbol generator </td></tr>
    <tr><td class="paramname">left_propagate</td><td>should values be propagated to the left in with expressions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression containing no array access </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01270">1270</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="ac19b40ec64e6315fb050b965fca62e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19b40ec64e6315fb050b965fca62e51">&#9670;&nbsp;</a></span>substitute_array_access_in_place()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void substitute_array_access_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsymbol__generatort.html">symbol_generatort</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>left_propagate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function for substitute_array_access Performs the same operation but modifies the argument instead of returning the resulting expression. </p>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01231">1231</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a328b5b84b55d64e104c2310951efc622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328b5b84b55d64e104c2310951efc622">&#9670;&nbsp;</a></span>substitute_array_lists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexprt.html">exprt</a> substitute_array_lists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classexprt.html">exprt</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>string_max_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace array-lists by 'with' expressions. </p>
<p>For instance <code>array-list [ 0 , x , 1 , y ]</code> is replaced by <code>ARRAYOF(0) WITH [0:=x] WITH [1:=y]</code>. Indexes exceeding the maximal string length are ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>an expression containing array-list expressions </td></tr>
    <tr><td class="paramname">string_max_length</td><td>maximum length allowed for strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression containing no array-list </dd></dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01780">1780</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a546fcdd903f84c2bc8c952399f5666b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546fcdd903f84c2bc8c952399f5666b5">&#9670;&nbsp;</a></span>update_index_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classexprt.html">exprt</a> &amp;&#160;</td>
          <td class="paramname"><em>formula</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add to the index set all the indices that appear in the formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>set of indexes </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">formula</td><td>a string constraint </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01689">1689</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a129aff44f6131c8a0e2ac21ee44eb5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129aff44f6131c8a0e2ac21ee44eb5cd">&#9670;&nbsp;</a></span>update_index_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void update_index_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structindex__set__pairt.html">index_set_pairt</a> &amp;&#160;</td>
          <td class="paramname"><em>index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnamespacet.html">namespacet</a> &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classexprt.html">exprt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>current_constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add to the index set all the indices that appear in the formulas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_set</td><td>set of indexes to update </td></tr>
    <tr><td class="paramname">ns</td><td>namespace </td></tr>
    <tr><td class="paramname">current_constraints</td><td>a vector of string constraints </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l01530">1530</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
<a id="a72ae9f77f37e8c92133b2f8a09a138a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ae9f77f37e8c92133b2f8a09a138a1">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structstring__refinementt_1_1infot.html">string_refinementt::infot</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__refinement_8cpp_source.html#l00150">150</a> of file <a class="el" href="string__refinement_8cpp_source.html">string_refinement.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_19373f467389307dc54ab8a6e9e19559.html">solvers</a></li><li class="navelem"><a class="el" href="dir_fb43b298f453a3e0e36cbec7baf05559.html">strings</a></li><li class="navelem"><a class="el" href="string__refinement_8cpp.html">string_refinement.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
