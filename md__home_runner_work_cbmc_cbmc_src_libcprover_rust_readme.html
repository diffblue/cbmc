<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: Libcprover-rust</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_cbmc_cbmc_src_libcprover_rust_readme.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Libcprover-rust </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A Rust interface for convenient interaction with the CProver tools.</p>
<h1><a class="anchor" id="autotoc_md155"></a>
Building instructions</h1>
<p>To build the Rust project you need the Rust language toolchain installed (you can install from <a href="https://rustup.rs">rustup.rs</a>).</p>
<p>With that instaled, you can execute <code>cargo build</code> under this (<code>src/libcprover-rust</code>) directory.</p>
<p>For this to work, you need to supply two environment variables to the project:</p>
<ul>
<li><code>CBMC_LIB_DIR</code>, for selecting where the <code>libcprover-x.y.z.a</code> is located (say, if you have downloaded a pre-packaged release which contains the static library),</li>
<li><code>CBMC_INCLUDE_DIR</code>, for selecting where the <code>cprover/api.h</code> is located, and</li>
<li><code>CBMC_VERSION</code>, for selecting the version of the library to link against (this is useful if you have multiple versions of the library in the same location and you want to control which version you compile against).</li>
</ul>
<p>As an example, a command sequence to build the API through <code>cargo</code> would look like this (assuming you're executing these instructions from the root level directory of the CBMC project.)</p>
<div class="fragment"><div class="line">$ cd src/libcprover-rust</div>
<div class="line">$ cargo clean</div>
<div class="line">$ CBMC_INCLUDE_DIR=../../build/include CBMC_LIB_DIR=../../build/lib CBMC_VERSION=5.78.0 cargo build</div>
</div><!-- fragment --><p>To build the project and run its associated tests, the command sequence would look like this:</p>
<div class="fragment"><div class="line">$ cd src/libcprover-rust</div>
<div class="line">$ cargo clean</div>
<div class="line">$ CBMC_INCLUDE_DIR=../../build/include CBMC_LIB_DIR=../../build/lib CBMC_VERSION=5.78.0 cargo test -- --test-threads=1 --nocapture</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md156"></a>
Basic Usage</h1>
<p>This file will guide through a sample interaction with the API, under a basic scenario: <em>loading a file and verifying the model contained within</em>.</p>
<p>To begin, we will assume that you have a file under <code>/tmp/api_example.c</code>, with the following contents:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> arr[] = {0, 1, 2, 3};</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>(arr[3] != 3, <span class="stringliteral">&quot;expected failure: arr[3] == 3&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a564e8a5a7bebea04fdd5ee1277832478"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a></div><div class="ttdeci">void __CPROVER_assert(__CPROVER_bool assertion, const char *description)</div></div>
<div class="ttc" id="afile__converter_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="file__converter_8cpp_source.html#l00041">file_converter.cpp:41</a></div></div>
</div><!-- fragment --><p>The first thing we need to do to initiate any interaction with the API itself is to create a new <code><a class="el" href="structapi__sessiont.html">api_sessiont</a></code> handle by using the function <code>new_api_session</code>:</p>
<div class="fragment"><div class="line">let client = cprover_api::new_api_session();</div>
</div><!-- fragment --><p>Then, we need to add the file to a vector with filenames that indicate which files we want the verification engine to load the models of:</p>
<div class="fragment"><div class="line">let vec: Vec&lt;String&gt; = vec![&quot;/tmp/api_example.c&quot;.to_owned()];</div>
<div class="line"> </div>
<div class="line">let vect = ffi_util::translate_rust_vector_to_cpp(vec);</div>
</div><!-- fragment --><p>In the above code example, we created a Rust language Vector of Strings (<code>vec</code>). In the next line, we called a utility function from the module <code>ffi_util</code> to translate the Rust <code>Vec&lt;String&gt;</code> into the C++ equivalent <code>std::vector&lt;std::string&gt;</code> - this step is essential, as we need to translate the type into something that the C++ end understands.</p>
<p>These operations are <em>explicit</em>: we have opted to force users to translate between types at the FFI level in order to reduce the "magic" and instill mental models more compatible with the nature of the language-border (FFI) work. If we didn't, and we assumed the labour of translating these types transparently at the API level, we risked mistakes from our end or from the user end frustrating debugging efforts.</p>
<p>At this point, we have a handle of a C++ vector containing the filenames of the files we want the CProver verification engine to load. To do so, we're going to use the following piece of code:</p>
<div class="fragment"><div class="line">// Invoke load_model_from_files and see if the model has been loaded.</div>
<div class="line">if let Err(_) = client.load_model_from_files(vect) {</div>
<div class="line">    eprintln!(&quot;Failed to load model from files: {:?}&quot;, vect);</div>
<div class="line">    process::exit(1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above is an example of a Rust idiom known as a <code>if let</code> - it's effectively a pattern match with just one pattern - we don't match any other case.</p>
<p>What we we do above is two-fold:</p>
<ul>
<li>We call the function <code>load_model_from_files</code> with the C++ vector (<code>vect</code>) we prepared before. It's worth noting that this function is being called with <code>client.</code> - what this does is that it passes the <code>api_session</code> handle we initialised at the beginning as the first argument to the <code>load_model_from_files</code> on the C++ API's end.</li>
<li>We handled the case where the model loading failed for whatever reason from the C++ end by catching the error on the Rust side and printing a suitable error message and exiting the process gracefully.</li>
</ul>
<hr  />
<p><em>Interlude</em>: <b>Error Handling</b></p>
<p><code>cxx.rs</code> (the FFI bridge we're using to build the Rust API) allows for a mechanism wherein exceptions from the C++ program can be translated into Rust <code>Result&lt;&gt;</code> types provided suitable infrastructure has been built.</p>
<p>Our Rust API contains a C++ shim which (among other things) intercepts CProver exceptions (from <code>cbmc</code>, etc.) and translates them into a form that the bridge can then translate to appropriate <code>Result</code> types that the Rust clients can use.</p>
<p>This means that, as above, we can use the same Rust idioms and types as we would use on a purely Rust based codebase to interact with the API.</p>
<p><em>All of the API calls</em> are returning <code>Result</code> types such as above.</p>
<hr  />
<p>After we have loaded the model, we can proceed to then engage the verification engine for an analysis run:</p>
<div class="fragment"><div class="line">if let Err(_) = client.verify_model() {</div>
<div class="line">    eprintln!(&quot;Failed to verify model from files: {:?}&quot;, vect);</div>
<div class="line">    process::exit(1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>While all this is happening, we are collecting the output of the various phases into a message buffer. We can go forward and print any messages from that buffer into <code>stdout</code>:</p>
<div class="fragment"><div class="line">let msgs_cpp = cprover_api::get_messages();</div>
<div class="line">let msgs_rust = ffi_util::translate_cpp_vector_to_rust(msgs_cpp);</div>
<div class="line">ffi_util::print_response(msgs_rust);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md159"></a>
Notes</h1>
<ul>
<li>The functions supported by the Rust API are catalogued within the <code>ffi</code> module within <code>lib.rs</code>.</li>
<li>The API supports exception handling from inside CBMC by catching the exceptions in a C++ shim, and then translating the exception into the Rust <code>Result</code> type.</li>
<li>Because of limitations from the C++ side of CBMC, the API is not thread-safe. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
