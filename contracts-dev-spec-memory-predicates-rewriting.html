<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: Rewriting User-Defined Memory Predicates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('contracts-dev-spec-memory-predicates-rewriting.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Rewriting User-Defined Memory Predicates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#contracts-dev-spec-memory-predicate-collect">Collecting user-defined memory predicates</a></li>
<li class="level1"><a href="#contracts-dev-spec-memory-predicate-rewrite">Rewriting user-defined memory predicates</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__home_runner_work_cbmc_cbmc_src_goto_instrument_contracts_doc_developer_contracts_dev_spec_memory_predicates_rewriting"></a> Back to top <a class="el" href="contracts-dev-spec.html">Code Contracts Transformation Specification</a></p>
<p>The C extensions for contract specification provide three pointer-related memory predicates:</p>
<div class="fragment"><div class="line"><span class="comment">// Holds iff ptr is pointing to an object distinct to all objects pointed to by</span></div>
<div class="line"><span class="comment">// other __CPROVER_is_fresh occurrences in the contract&#39;s pre and post conditions</span></div>
<div class="line">__CPROVER_bool <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Holds iff ptr is a valid pointer pointing between lb and ub pointers.</span></div>
<div class="line"><span class="comment">// \pre lb and ub must be valid pointers pointing in the same object.</span></div>
<div class="line">__CPROVER_bool <a class="code" href="cprover__builtin__headers_8h.html#a33926c3f831d23353ac2baf02eeb063a">__CPROVER_pointer_in_range_dfcc</a>(<span class="keywordtype">void</span> *lb, <span class="keywordtype">void</span> *ptr, <span class="keywordtype">void</span> *ub);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Holds iff the function pointer \p fptr points to a function satisfying</span></div>
<div class="line"><span class="comment">// \p contract.</span></div>
<div class="line">__CPROVER_bool <a class="code" href="cprover__builtin__headers_8h.html#afb98fc4ff28173835ed64fa8192343d2">__CPROVER_obeys_contract</a>(<span class="keywordtype">void</span> (*fptr)(<span class="keywordtype">void</span>), <span class="keywordtype">void</span> (*contract)(<span class="keywordtype">void</span>));</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a33926c3f831d23353ac2baf02eeb063a"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a33926c3f831d23353ac2baf02eeb063a">__CPROVER_pointer_in_range_dfcc</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_pointer_in_range_dfcc(void *lb, void *ptr, void *ub)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ad4e9673ed79a6d8ff4af6cf12d95c29f"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_is_fresh(const void *mem, __CPROVER_size_t size)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_afb98fc4ff28173835ed64fa8192343d2"><div class="ttname"><a href="cprover__builtin__headers_8h.html#afb98fc4ff28173835ed64fa8192343d2">__CPROVER_obeys_contract</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_obeys_contract(void(*)(void), void(*)(void))</div></div>
</div><!-- fragment --><p>Users are free to call these predicates from requires and ensures clauses. Users can also define their own functions in terms of these predicates, and call them from requires and ensures clauses, but not from the program under analysis.</p>
<p>For instance, one could write a predicate defining linked lists of at most <code>len</code> elements as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>list_t</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> value;</div>
<div class="line">  <span class="keyword">struct </span>list_t *next;</div>
<div class="line">} list_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// true iff list of len nodes with values in [-10,10]</span></div>
<div class="line"><span class="keywordtype">bool</span> is_list(list_t *l, <span class="keywordtype">size_t</span> len)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(len == 0)</div>
<div class="line">    <span class="keywordflow">return</span> l == NULL;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(l, <span class="keyword">sizeof</span>(*l)) &amp;&amp; -10 &lt;= l-&gt;value &amp;&amp;</div>
<div class="line">           l-&gt;value &lt;= 10 &amp;&amp; is_list(l-&gt;next, len - 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p>One can also simply describe finite nested structures:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>buffer_t</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">char</span> *arr;</div>
<div class="line">  <span class="keywordtype">char</span> *cursor;</div>
<div class="line">} buffer_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>double_buffer_t</div>
<div class="line">{</div>
<div class="line">  buffer_t *first;</div>
<div class="line">  buffer_t *second;</div>
<div class="line">} double_buffer_t;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_sized_array(<span class="keywordtype">char</span> *arr, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(arr, size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_buffer(buffer_t *b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(b, <span class="keyword">sizeof</span>(*b)) &amp;&amp; (0 &lt; b-&gt;size &amp;&amp; b-&gt;size &lt;= 10) &amp;&amp;</div>
<div class="line">         is_sized_array(b-&gt;arr, b-&gt;size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_double_buffer(double_buffer_t *b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(b, <span class="keyword">sizeof</span>(*b)) &amp;&amp; is_buffer(b-&gt;first) &amp;&amp;</div>
<div class="line">         is_buffer(b-&gt;second);</div>
<div class="line">}</div>
</div><!-- fragment --><p>By rewriting such user-defined predicate we achieve two things:</p><ol type="1">
<li>in assumption contexts, evaluating the predicate allocates the data stucture specified by the predicate;</li>
<li>in assertion contexts, evaluating the predicate checks that a given pointer satisfies the predicate definition;</li>
</ol>
<p>To achieve point 1., we apply an instrumentation pass to transform the user-defined functions into functions that take their pointer arguments by reference instead of by value, so that enforcing the assumption described by the predicate can be done by updating the pointer in place using a side effect.</p>
<h1><a class="anchor" id="contracts-dev-spec-memory-predicate-collect"></a>
Collecting user-defined memory predicates</h1>
<p>We first run a pass that collects all user-defined functions that are defined in terms of one of the three core memory predicates using this fixpoint algorithm:</p>
<div class="fragment"><div class="line">predicates = {};</div>
<div class="line">updated = true;</div>
<div class="line">while(updated)</div>
<div class="line">{</div>
<div class="line">  updated = false;</div>
<div class="line">  for(function : goto_model.goto_functions.function_map)</div>
<div class="line">  {</div>
<div class="line">    if(!predicates.contains(function) &amp;&amp;</div>
<div class="line">      (calls_core_predicate(function) ||</div>
<div class="line">        calls_one_of(function, predicates)))</div>
<div class="line">    {</div>
<div class="line">      predicates.insert(function);</div>
<div class="line">      updated = true;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="contracts-dev-spec-memory-predicate-rewrite"></a>
Rewriting user-defined memory predicates</h1>
<p>We only support sets of predicates that are non-recursive or self-recursive (i.e. predicates that call themselves directly). We build a graph representing the P-calls-Q relation, omitting edges for self-recursion, and try to sort it topologically. If the sort succeeds we rewrite the predicates in topological order, so that when instrumenting P any other predicate Q it calls is already instrumented and we know which parameters of Q have been lifted. If the topological sort fails, then it means the predicate are mutually recursive and we abort instrumentation.</p>
<p>Rewriting a user-defined memory predicate P consists in:</p><ul>
<li>Identifying the subset of parameters of P which get passed to a core predicate or a user-defined predicate in a lifted position;</li>
<li>In the signature of P, lift all such parameters to pointer-to-pointer types;</li>
<li>In the body of P, rewrite all occurences of a lifted parameter <code>p</code> into <code>*p</code> (this brings back type coherence in the body of P);</li>
<li>For calls to memory predicates Q, add an <code>address_of</code> operator to arguments passed on a lifted parameter of Q;</li>
</ul>
<p>Once these transformations are applied, the body of the predicate is well typed and the predicate now takes the pointers on which it operates by reference instead of by value. By doing so, the P gains the capability to update in place the memory location hold the pointer value subject to the predicate definition.</p>
<p>The last step of the rewriting is to apply the normal DFCC instrumentation which adds a write set parameter to the function, instruments it for side effect checking, and maps core memory predicates to their implementations.</p>
<p>On our previous list example, this yields the following result:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_list(list_t **l, <span class="keywordtype">size_t</span> len,</div>
<div class="line">  <a class="code" href="struct_____c_p_r_o_v_e_r__contracts__write__set__t.html">__CPROVER_contracts_write_set_ptr_t</a> write_set)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(len == 0)</div>
<div class="line">    <span class="keywordflow">return</span> (*l) == NULL;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="cprover__contracts_8c.html#a618ed6892d91825d0becba82c6df28b6">__CPROVER_contracts_is_fresh</a>(&amp;(*l), <span class="keyword">sizeof</span>(*(*l)), write_set) &amp;&amp;</div>
<div class="line">      -10 &lt;= (*l)-&gt;value &amp;&amp; (*l)-&gt;value &lt;= 10 &amp;&amp;</div>
<div class="line">      is_list(&amp;((*l)-&gt;next), len-1, write_set);</div>
<div class="line">}</div>
<div class="ttc" id="acprover__contracts_8c_html_a618ed6892d91825d0becba82c6df28b6"><div class="ttname"><a href="cprover__contracts_8c.html#a618ed6892d91825d0becba82c6df28b6">__CPROVER_contracts_is_fresh</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_contracts_is_fresh(void **elem, __CPROVER_size_t size, __CPROVER_contracts_write_set_ptr_t write_set)</div><div class="ttdoc">Implementation of the is_fresh front-end predicate.</div><div class="ttdef"><b>Definition:</b> <a href="cprover__contracts_8c_source.html#l01159">cprover_contracts.c:1159</a></div></div>
<div class="ttc" id="astruct_____c_p_r_o_v_e_r__contracts__write__set__t_html"><div class="ttname"><a href="struct_____c_p_r_o_v_e_r__contracts__write__set__t.html">__CPROVER_contracts_write_set_t</a></div><div class="ttdoc">Runtime representation of a write set.</div><div class="ttdef"><b>Definition:</b> <a href="cprover__contracts_8c_source.html#l00071">cprover_contracts.c:72</a></div></div>
</div><!-- fragment --><p>On the nested structs example, it gives the following result:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_sized_array(<span class="keywordtype">char</span> **arr, <span class="keywordtype">size_t</span> size,</div>
<div class="line">  <a class="code" href="struct_____c_p_r_o_v_e_r__contracts__write__set__t.html">__CPROVER_contracts_write_set_ptr_t</a> write_set)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__contracts_8c.html#a618ed6892d91825d0becba82c6df28b6">__CPROVER_contracts_is_fresh</a>(&amp;(*arr), size, write_set);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_buffer(buffer_t **b,</div>
<div class="line">  <a class="code" href="struct_____c_p_r_o_v_e_r__contracts__write__set__t.html">__CPROVER_contracts_write_set_ptr_t</a> write_set)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__contracts_8c.html#a618ed6892d91825d0becba82c6df28b6">__CPROVER_contracts_is_fresh</a>(&amp;(*b), <span class="keyword">sizeof</span>(*(*b)), write_set) &amp;&amp;</div>
<div class="line">    (0 &lt; (*b)-&gt;size &amp;&amp; (*b)-&gt;size &lt;= 10) &amp;&amp;</div>
<div class="line">    is_sized_array(&amp;(*b)-&gt;arr, (*b)-&gt;size, write_set);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> is_double_buffer(double_buffer_t **b,</div>
<div class="line">  <a class="code" href="struct_____c_p_r_o_v_e_r__contracts__write__set__t.html">__CPROVER_contracts_write_set_ptr_t</a> write_set)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="cprover__contracts_8c.html#a618ed6892d91825d0becba82c6df28b6">__CPROVER_contracts_is_fresh</a>(&amp;(*b), <span class="keyword">sizeof</span>(*(*b)), write_set) &amp;&amp;</div>
<div class="line">      is_buffer(&amp;((*b)-&gt;first), write_set) &amp;&amp;</div>
<div class="line">      is_buffer(&amp;((*b)-&gt;second), write_set);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The write_set parameter carries assumption/assertion context flags, so that the implementation of the core-predicates know when to update the pointers in place using malloc and assignments to make the predicates hold.</p>
<hr  />
 <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Prev   </th><th class="markdownTableHeadLeft">Next    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><a class="el" href="contracts-dev-spec-spec-rewriting.html">Rewriting Declarative Assign and Frees Specification Functions</a>   </td><td class="markdownTableBodyLeft"><a class="el" href="contracts-dev-spec-dfcc.html">Dynamic Frame Condition Checking</a>   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="contracts-mainpage.html">Code Contracts in CBMC</a></li><li class="navelem"><a class="el" href="contracts-dev.html">Code Contracts Developer Documentation</a></li><li class="navelem"><a class="el" href="contracts-dev-spec.html">Code Contracts Transformation Specification</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
