<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: util</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__util.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">util</div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="autotoc_md168"></a>
Folder util</h1>
<dl class="section author"><dt>Author</dt><dd>Martin Brain, Owen Jones, Chris Smowton</dd></dl>
<h1><a class="anchor" id="util_data_structures"></a>
Data Structures</h1>
<p><a class="el" href="group__util.html">util</a> contains some of the key data-structures used in the CPROVER codebase.</p>
<h2><a class="anchor" id="irept_section"></a>
irept: a general-purpose polymorphic tree</h2>
<p>See detailed documentation at <a class="el" href="classirept.html">irept</a>.</p>
<p><a class="el" href="classirept.html">irept</a>s are generic tree nodes. You should think of each node as holding a single string (<a class="el" href="classsharing__treet.html#a2fc74ffd034e6bbf6b03921d4014c648">data</a>, actually an <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a>) and lots of child nodes, some of which are numbered ([sub](<a class="el" href="classtree__nodet.html#a8f759d22dcd47e91046bd35ad06adc1d">irept::dt::sub</a>)) and some of which are labelled ([named_sub](<a class="el" href="classtree__nodet.html#a29d3309a833548c958ebedc6f8d8159c">irept::dt::named_sub</a>)). The the label can either start with a “#” or without one. The meaning of the “#” is that this child shouldn't be considered when comparing two <a class="el" href="classirept.html">irept</a>s for equality; this is usually used when making an advisory annotation which does not alter the semantics of the program.</p>
<p>They are used to represent many kinds of structured objects throughout the CPROVER codebase, such as expressions, types and code. An <a class="el" href="classexprt.html">exprt</a> represents expressions, including for example <a class="el" href="classequal__exprt.html">equal_exprt</a>, an equality predicate, or <a class="el" href="classdereference__exprt.html">dereference_exprt</a>, which represents the <code>*</code> unary dereference operator found in C. A <a class="el" href="classtypet.html">typet</a> represents a type, and may have other <a class="el" href="classtypet.html">typet</a> nodes as children: for example, <a class="el" href="classarray__typet.html">array_typet</a> represents an array, and has a single numbered child that gives the type of the array elements. Finally, <a class="el" href="classcodet.html">codet</a> represents imperative statements, such as <a class="el" href="classcode__assignt.html">code_assignt</a>, which represents an imperative assignment. It has two numbered operands, its left- and right-hand sides.</p>
<p>Note that <a class="el" href="classexprt.html">exprt</a>, <a class="el" href="classcodet.html">codet</a> and similar classes deriving from <a class="el" href="classirept.html">irept</a> do so in order to add constraints to the general tree (for example, providing accessor methods with user-friendly names, or enforcing invariants that a node must have a certain number of children), but do not override virtual methods or add fields.</p>
<p>The implementation of <a class="el" href="classirept.html">irept</a> allows saving memory by sharing instances of its internal storage using a <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> scheme. For example, the statement <code>irep1.sub()[0] = irep2;</code> will share rather than copy <code>irep2</code> and its children, saving memory unless either irept is subsequently modified, at which point a copy is made.</p>
<h2><a class="anchor" id="irept_discussion_section"></a>
Discussion</h2>
<p>Many other compiler infrastructures represent a polymorphic tree using nodes specialised to a particular expression type: for example, perhaps a binary addition operator could be represented using a tag plus two pointers to child expressions, rather than allocating a whole irept (including a variable-length expression vector and empty maps for storing named subexpressions). This may save memory, but inhibits ad-hoc annotations such as tagging the addition "does not overflow" without adding that field to addition operations globally or maintaining a shadow data structure to track that information. This is easier with a general irept structure that can store an arbitrary number of arbitrarily-named child nodes.</p>
<p>Another optimisation commonly seen when storing polymorphic trees is to use a uniform node data structure (like irept) but to keep the node compact, for example storing at most four pointers and transparently allocating extension nodes when necessary for an unusually large expression. This provides the best of both worlds, obtaining compact storage for common cases such as unannotated binary expressions while permitting deviation at times. The downside is that implementing such a system is more complex than straightforwardly using C++ standard data structures as in irept.</p>
<h2><a class="anchor" id="irep_idt_section"></a>
Strings: dstringt, the string_container and the ID_*</h2>
<p>Within cbmc, strings are represented using <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a>, which is typedefed to <a class="el" href="classdstringt.html">dstringt</a>. You can also easily convert an <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> to a <code>std::string</code> using the <a class="el" href="irep_8h.html#aec473a7cdee5da3223f587aa2c1c4132">id2string</a> function, or to a <code>char*</code> using the <a class="el" href="classdstringt.html#a6c87a024bc9e15c2c5d567f35dd12bf4">c_str()</a> member function.</p>
<p><a class="el" href="classdstringt.html">dstringt</a> stores a string as an index into a large static table of strings. This makes it easy to compare if two <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a>s are equal (just compare the index) and it makes it efficient to store many copies of the same string. The static list of strings is initially populated from <code>irep_ids.def</code>, so for example the fourth entry in <code>irep_ids.def</code> is <code>“IREP_ID_ONE(type)”</code>, so the string “type” has index 3. You can refer to this <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> as <code>ID_type</code>. The other kind of line you see is <code>"IREP_ID_TWO(C_source_location, #source_location)"</code>, which means the <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> for the string “#source_location” can be referred to as <code>ID_C_source_location</code>. The “C” is for comment, meaning that it starts with “#”. Any strings that need to be stored as <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a>s which aren't in <code>irep_ids.def</code> are added to the end of the table when they are first encountered, and the same index is used for all instances.</p>
<p>See documentation at <a class="el" href="classdstringt.html">dstringt</a>.</p>
<h2><a class="anchor" id="typet_section"></a>
typet</h2>
<p><a class="el" href="classtypet.html">typet</a> represents the type of an expression. Types may have subtypes, stored in two <a class="el" href="classtree__nodet.html#a8f759d22dcd47e91046bd35ad06adc1d">sub</a>s named “subtype” (a single type) and “subtypes” (a vector of types). For pre-defined types see <code><a class="el" href="std__types_8h.html" title="Pre-defined types.">std_types.h</a></code> and <code><a class="el" href="mathematical__types_8h.html" title="Mathematical types.">mathematical_types.h</a></code>.</p>
<h3><a class="anchor" id="tag_typet_section"></a>
tag_typet</h3>
<p><a class="el" href="classtag__typet.html">tag_typet</a> is a type used to store a reference to the symbol table. The full <a class="el" href="classsymbolt.html">symbolt</a> can be retrieved using the identifier of <a class="el" href="classtag__typet.html">tag_typet</a>.</p>
<h2><a class="anchor" id="exprt_section"></a>
exprt</h2>
<p><a class="el" href="classexprt.html">exprt</a> is the class to represent an expression. It inherits from <a class="el" href="classirept.html">irept</a>, and the only things it adds to it are that (1) every <a class="el" href="classexprt.html">exprt</a> has an entry in <a class="el" href="classtree__nodet.html#a29d3309a833548c958ebedc6f8d8159c">named_sub</a> containing its type and (2) everything in the <a class="el" href="classtree__nodet.html#a8f759d22dcd47e91046bd35ad06adc1d">sub</a> of an <a class="el" href="classexprt.html">exprt</a> is again an <a class="el" href="classexprt.html">exprt</a>, not just an <a class="el" href="classirept.html">irept</a>. You can think of <a class="el" href="classexprt.html">exprt</a> as a node in the abstract syntax tree for an expression. There are many classes that inherit from <a class="el" href="classexprt.html">exprt</a> and which represent more specific things. For example, there is <a class="el" href="classminus__exprt.html">minus_exprt</a>, which has a <a class="el" href="classtree__nodet.html#a8f759d22dcd47e91046bd35ad06adc1d">sub</a> of size 2 (for the two arguments of minus).</p>
<p>Recall that every <a class="el" href="classirept.html">irept</a> has one piece of data of its own, i.e. its <a class="el" href="classirept.html#a88dd1ba1e91afeed54416f80969e9140">id()</a>, and all other information is in its <a class="el" href="classtree__nodet.html#a29d3309a833548c958ebedc6f8d8159c">named_sub</a> or <a class="el" href="classtree__nodet.html#a8f759d22dcd47e91046bd35ad06adc1d">sub</a>. For <a class="el" href="classexprt.html">exprt</a>s, the <a class="el" href="classirept.html#a88dd1ba1e91afeed54416f80969e9140">id()</a> is used to specify why kind of <a class="el" href="classexprt.html">exprt</a> this is, so a <a class="el" href="classminus__exprt.html">minus_exprt</a> has <code>ID_minus</code> as its <a class="el" href="classirept.html#a88dd1ba1e91afeed54416f80969e9140">id()</a>. This means that a <a class="el" href="classminus__exprt.html">minus_exprt</a> can be passed wherever an <a class="el" href="classexprt.html">exprt</a> is expected, and if you want to check if the expression you are looking at is a minus expression then you have to check its <a class="el" href="classirept.html#a88dd1ba1e91afeed54416f80969e9140">id()</a> (or use <a class="el" href="expr__cast_8h.html#a42363d1890db7dd905e72b2db8e336e7">can_cast_expr</a><code>&lt;<a class="el" href="classminus__exprt.html" title="Binary minus.">minus_exprt</a>&gt;</code>).</p>
<h2><a class="anchor" id="codet_section"></a>
codet</h2>
<p>See documentation at <a class="el" href="classcodet.html">codet</a>.</p>
<p><a class="el" href="classexprt.html">exprt</a> represents expressions and <a class="el" href="classcodet.html">codet</a> represents statements. <a class="el" href="classcodet.html">codet</a> inherits from <a class="el" href="classexprt.html">exprt</a>, so all <a class="el" href="classcodet.html">codet</a>s are <a class="el" href="classexprt.html">exprt</a>s, with <a class="el" href="classirept.html#a88dd1ba1e91afeed54416f80969e9140">id()</a> <code>ID_code</code>. Many different kinds of statements inherit from <a class="el" href="classcodet.html">codet</a>, and they are distinguished by their <a class="el" href="classcodet.html#ae1314833d2dac2601602a3743b78c491">statement</a>. For example, a while loop would be represented by a <a class="el" href="classcode__whilet.html">code_whilet</a>, which has <a class="el" href="classcodet.html#ae1314833d2dac2601602a3743b78c491">statement</a> <code>ID_while</code>. <a class="el" href="classcode__whilet.html">code_whilet</a> has two operands in its <a class="el" href="classtree__nodet.html#a8f759d22dcd47e91046bd35ad06adc1d">sub</a>, and helper functions to make it easier to use: <a class="el" href="classcode__whilet.html#ac445061830a3e375bee26e363e021063">cond()</a> returns the first subexpression, which is the condition for the while loop, and <a class="el" href="classcode__whilet.html#aa001c35967de3f9fa393db73039bc140">body()</a> returns the second subexpression, which is the body of the while loop - this has to be a <a class="el" href="classcodet.html">codet</a>, because the body of a while loop is a statement.</p>
<h2><a class="anchor" id="symbolt_section"></a>
symbolt, symbol_tablet, and namespacet</h2>
<p>A symbol table is a mapping from symbol names to <a class="el" href="classsymbolt.html">symbolt</a> objects, which store a symbol's name, attributes, type and perhaps value. They are used to describe local and global variables, type definitions and function prototypes and definitions.</p>
<p>All symbols store a type (an instance of <a class="el" href="classtypet.html">typet</a>). For function or method symbols these are <a class="el" href="classcode__typet.html">code_typet</a> instances.</p>
<p>Global variable symbols may have a value (an <a class="el" href="classexprt.html">exprt</a>), in which case it is used to initialise the global.</p>
<p>Method or function symbols may also have a value, in which case it is a <a class="el" href="classcodet.html">codet</a> and gives the function definition. A method or function symbol without a value is a prototype (for example, it might be an <code>extern</code> declaration in C). A function symbol that has been converted to a GOTO function <em>may</em> be replaced with a special "compiled" value, but this varies from driver program to program &ndash; at the time of writing, only <a class="el" href="group__goto-cc.html">goto-cc</a> does this.</p>
<p>Local variables' symbol values are always ignored; any initialiser must be explicitly assigned after they are instantiated by a declaration (<a class="el" href="classcode__declt.html">code_declt</a>).</p>
<p>Symbol expressions (<a class="el" href="classsymbol__exprt.html">symbol_exprt</a>) and types (<a class="el" href="classtag__typet.html">tag_typet</a>) refer to symbols stored in a symbol table. Symbol expressions can be thought of as referring to the table for more detail about a symbol (for example, is it a local or a global variable, or perhaps a function?), and have a type which must match the type given in the symbol table. Symbol types can be thought of as shorthands or aliases for a type given in more detail in the symbol table, for example permitting a shorthand for a large structure type, as well as permitting the construction of expressions referring to that type before its full definition is known.</p>
<p>Note the implementation of <a class="el" href="classsymbol__tablet.html">symbol_tablet</a> is split into a base interface (<a class="el" href="classsymbol__table__baset.html">symbol_table_baset</a>) and an implementation (<a class="el" href="classsymbol__tablet.html">symbol_tablet</a>). There is one alternate implementation (<a class="el" href="classjournalling__symbol__tablet.html">journalling_symbol_tablet</a>) which additionally maintains a log or journal of symbol creation, modification and deletions.</p>
<p>Namespaces (<a class="el" href="classnamespacet.html">namespacet</a>) provide a read-only view on one or more symbol tables, and provide helper functions that aid accessing the table. A namespace may layer one or more symbol tables, in which case any lookup operation checks the 'top' symbol table before moving down the layers towards the 'bottom' symbol table, looking up the target symbol name in each successive table until one is found. Note class <a class="el" href="classmulti__namespacet.html">multi_namespacet</a> can layer arbitrary numbers of symbol tables, while for historical reasons <a class="el" href="classnamespacet.html">namespacet</a> can layer up to two.</p>
<p>The namespace wrapper class also provides the <a class="el" href="classnamespace__baset.html#a08ff1828dbaf894a44a23f50a700255a">namespacet::follow</a> operation, which dereferences a <code><a class="el" href="classtag__typet.html" title="A tag-based type, i.e., typet with an identifier.">tag_typet</a></code> to retrieve the type it refers to, including following a type tag which refers to another symbol which eventually refers to a 'real' type.</p>
<h3><a class="anchor" id="symbolt_lifetime"></a>
Symbol lifetimes</h3>
<p>Symbols with <a class="el" href="classsymbolt.html#a6317578dd5e0ea50e815d1ee89b4f3f8">symbolt::is_static_lifetime</a> set are initialised before a program's entry-point is called and live until it ends. Such long-lived variables are used to implement globals, but also C's procedure-local static variables, which have restricted visiblity but the lifetime of a global. They may be marked dead using a <a class="el" href="classcode__deadt.html">code_deadt</a> instruction, but this does not render the variable inaccessible, it only indicates that the variable's current value will not be read without an intervening write.</p>
<p>Non-type, non-global symbols (those with <a class="el" href="classsymbolt.html#a6317578dd5e0ea50e815d1ee89b4f3f8">symbolt::is_static_lifetime</a> and <a class="el" href="classsymbolt.html#a751b0221d1807cae2f0dd144fe5a320f">symbolt::is_type</a> not set) are local variables, and their lifespan description varies depending on context.</p>
<p>In symbol table function definitions (the values of function-typed symbols), local variables are created using a <a class="el" href="classcode__declt.html">code_declt</a> instruction, and live until their enclosing <a class="el" href="classcode__blockt.html">code_blockt</a> ends (similar to the C idiom <code>{ int x; ... } // x lifespan ends</code>). By contrast in GOTO programs locals are declared using a DECL instruction and live until a DEAD instruction referring to the same symbol. Explicit DEAD instructions are always used rather than killing implicitly by exiting a function.</p>
<p>Multiple instances of the same local may be live at the same time by virtue of recursive function calls; a dead instruction or scope end always targets the most recently allocated instance.</p>
<p>Scoping rules are particular to source languages and are not enforced by CPROVER. For example, in standard C it is not possible to refer to a local variable across functions without using a pointer, but in some possible source languages this is permitted.</p>
<h3><a class="anchor" id="symbolt_details"></a>
Symbol details</h3>
<p>Symbols have:</p><ul>
<li>A mode, which indicates the source language frontend responsible for creating them. This is mainly used in pretty-printing the symbol table, to indicate the appropriate language frontend to use rendering the symbol's value and/or type. For example, mode == ID_C == "C" indicates that <a class="el" href="classansi__c__languaget.html">ansi_c_languaget</a>, the C front-end, should be used to pretty-print, which in turn delegates to <a class="el" href="classexpr2ct.html">expr2ct</a>.</li>
<li>A base-name and pretty-name, which are a short and user-friendly version of the symbol's definitive name respectively.</li>
<li>Several flags (see <a class="el" href="classsymbolt.html">symbolt</a> for full details), including <a class="el" href="classsymbolt.html#a6317578dd5e0ea50e815d1ee89b4f3f8">symbolt::is_static_lifetime</a> (is this a global variable symbol?), <a class="el" href="classsymbolt.html#a751b0221d1807cae2f0dd144fe5a320f">symbolt::is_type</a> (is this a type definition), <a class="el" href="classsymbolt.html#a7495d7224a73c59013e7fc0db952fa8f">symbolt::is_thread_local</a> (of a variable, are there implicitly instances of this variable per-thread?).</li>
</ul>
<h2><a class="anchor" id="cmdlinet"></a>
cmdlinet</h2>
<p>See <a class="el" href="group__util.html#cmdlinet">cmdlinet</a>.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_23.svg" width="1024" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h2><a class="anchor" id="ast-examples-section"></a>
Examples: how to represent the AST of statements, in C and in java</h2>
<h3><a class="anchor" id="ast-example-1-section"></a>
x = y + 123</h3>
<p>To be documented..</p>
<h3><a class="anchor" id="ast-example-2-section"></a>
if (x &gt; 10) { y = 2 } else { v[3] = 4 }</h3>
<p>To be documented.</p>
<h3><a class="anchor" id="ast-example-3-section"></a>
Java arrays: struct Array { int length, int *data };</h3>
<p>To be documented.</p>
<h2><a class="anchor" id="section-goto-typecheck"></a>
Goto Model Typecheck</h2>
<p>Class <code>typecheckt</code>.</p>
<h2><a class="anchor" id="irep-serialization"></a>
&lt;tt&gt;irept&lt;/tt&gt; Serialization</h2>
<p>The module provides serialisation and deserialisation of integer numbers, strings, and <code>irept</code> instances.</p>
<p>This is implemented in C++ modules:</p><ul>
<li><code><a class="el" href="irep__serialization_8h.html" title="binary irep conversions with hashing">irep_serialization.h</a></code></li>
<li><code><a class="el" href="irep__serialization_8cpp.html" title="binary irep conversions with hashing">irep_serialization.cpp</a></code></li>
<li><code><a class="el" href="irep__hash__container_8h.html" title="IREP Hash Container.">irep_hash_container.h</a></code> (applies only to <code>irept</code> instances)</li>
<li><code><a class="el" href="irep__hash__container_8cpp.html" title="Hashing IREPs.">irep_hash_container.cpp</a></code> (applies only to <code>irept</code> instances)</li>
</ul>
<h3><a class="anchor" id="irep-serialization-numbers"></a>
Serialization of Numbers</h3>
<p>A number is serialiased in 7-bit encoding. For example, given a 2-byte number in base 2, like <code>10101010 01010101</code>, then it is saves in 3 bytes, where each byte takes only 7 bits from the number, reading from the left. The 8th bit in each output byte is set to 1 except in the last byte, where the bit is 0. That 0 bit indicates the end of the encoding of the number. So, the output bytes look like this: <code>11010101 11010100 00000010</code>.</p>
<p>This is implmented in the function <code><a class="el" href="irep__serialization_8h.html#ad4d25c493e2f543c18d9a5768dc1faff" title="Write 7 bits of u each time, least-significant byte first, until we have zero.">write_gb_word</a></code>.</p>
<p>The deserialisation does the oposite process and it is implemented in <code><a class="el" href="classirep__serializationt.html#a6fbf5b6e870d6c21a11e83e80b6f7f27" title="Interpret a stream of byte as a 7-bit encoded unsigned number.">irep_serializationt::read_gb_word</a></code>.</p>
<h3><a class="anchor" id="irep-serialization-strings"></a>
Serialization of Strings</h3>
<p>A string is encoded as classic 0-terminated C string. However, characters <code>0</code> and <code>\\</code> are escaped by writing additional <code>\\</code> before them.</p>
<p>This is implmented in the function <code><a class="el" href="irep__serialization_8h.html#af09029b333b80f788fffed6862842c0c" title="outputs the string and then a zero byte.">write_gb_string</a></code> and the deserialisation is implemented in <code><a class="el" href="classirep__serializationt.html#af9b930b4738f3377d0f2e8046bec7546" title="reads a string from the stream">irep_serializationt::read_gb_string</a></code>.</p>
<p>Each string which is stored inside an <code><a class="el" href="classirept.html" title="There are a large number of kinds of tree structured or tree-like data in CPROVER.">irept</a></code> instance is saved (meaining its characters) into the ouptut stream, only in the first serialisation query of the string. In that case, before the string there is also saved a computed integer hash code of the string. Then, all subsequent serialisation queries save only that integer hash code of the string.</p>
<h3><a class="anchor" id="irep-serialization-ireps"></a>
Serialization of &lt;tt&gt;irept&lt;/tt&gt; Instances</h3>
<p><br  />
 </p>
<h2><a class="anchor" id="CProver-output"></a>
CProver output - printing.</h2>
<p>CProver output can be in plain text, json or xml format. All of CProver output should use the built-in messaging infrastructure, which filters messages by 'verbosity'. Default verbosity filtering is set to the maximum level (10), i.e. all messages are printed. Error messages have the lowest level of verbosity (level 1) while debug messages have the highest level (level 10). Intermediate levels (in order of increasing 'verbosity') are for warnings, results, status/phase information, statistical information and progress information (more information on these verbosity levels can be found in <a class="el" href="classmessaget.html">messaget</a> in the <code>message.h</code> header).</p>
<p>Key classes related to the messaging infrastructure can be found in the <code>message.h</code> header. <a class="el" href="classmessaget.html">messaget</a> provides messages (with a built-in verbosity level), which are then processed by subclasses of <a class="el" href="classmessage__handlert.html">message_handlert</a>. These filter messages according to verbosity level and direct output to an appropriate location. An important group of subclasses is <a class="el" href="classstream__message__handlert.html">stream_message_handlert</a> and its subtypes, which direct messages to an output stream (<code>std::cout</code> &amp; <code>std::cerr</code>, <code>std::clog</code> is not used). In particular, messages of verbosity level less than 3 are directed to <code>std::cerr</code>, while others go to <code>std::cout</code> (this may change, but you should be aware that not all messages are necessarily directed to only <code>std::cout</code> or <code>std::cerr</code>). Another key <a class="el" href="classmessage__handlert.html">message_handlert</a> subclass is <a class="el" href="classui__message__handlert.html">ui_message_handlert</a> - which provides output in plain text, json or xml formats.</p>
<h3><a class="anchor" id="CProver-legacy-output"></a>
CProver legacy output</h3>
<p>Although all output should use the messaging interface - there are a few locations where this is not yet implemented. These should <em>not</em> be extended - but it may be helpful to be aware of where this happens.</p>
<ul>
<li><p class="startli">Output from invariants / exceptions</p>
<p class="startli">Invariants output to <code>std::cerr</code> - and provide a backtrace and optionally some diagnostic information. For more information on invariants, see <code>invariant.h</code></p>
<p class="startli">Exceptions have a standard <code>what()</code> interface. Best current practice for exceptions is for the output of <code>what()</code> to be routed via a message with verbosity level 1 (as returned by <code><a class="el" href="classmessaget.html#a108043e0a9925dcebbb8a793611428b6">messaget::error()</a></code>). The message is then processed by a message_handler. Where plain text output (versus json or xml output) is chosen, exceptions print (indirectly) to <code>std::cerr</code>. Json and xml output always goes to <code>std::cout</code>. There are still a few locations where exceptions print directly to std::cerr. These should <em>not</em> be extended. More information on exceptions can be found in <code><a class="el" href="exception__utils_8h.html">exception_utils.h</a></code>.</p>
</li>
<li><p class="startli">Direct output via <code>std::cout</code> &amp; <code>std::cerr</code></p>
<p class="startli">These are in the process of being removed - no new output should go via <code>std::cout</code> or <code>std::cerr</code>, but should instead use the <a class="el" href="classmessaget.html">messaget</a> and <a class="el" href="classmessage__handlert.html">message_handlert</a> infrastructure.</p>
</li>
</ul>
<h2><a class="anchor" id="Graph"></a>
Graph</h2>
<h3><a class="anchor" id="autotoc_md169"></a>
Graph</h3>
<p>Implemented in <code><a class="el" href="graph_8h.html" title="A Template Class for Graphs.">src/util/graph.h</a></code> as <code>grapht</code> class. The <code>grapht</code> class represents a directed graph. However, an undirected graph can be emulated by inserting for each edge (u, v) also (v, u). A multi-graph is not supported though, because parallel edges are not allowed between vertices.</p>
<h4><a class="anchor" id="autotoc_md170"></a>
Data representation</h4>
<p>A graph is defined by a template class <code>grapht&lt;N&gt;</code>, where <code>N</code> is the type of the nodes of the graph. The class <code>grapht</code> stores the nodes in a vector. A user of the graph is supposed to access the nodes via their indices in the vector. The node type <code>N</code> must meet these requirements:</p><ul>
<li>It must be default constructible; the common way how to insert a node to the graph is to call method <code>add_node</code> which pushes a new default-constructed instance of <code>N</code> to the end of the vector and returns its index. Then <code>operator[]</code> can be used to obtain a reference to the pushed instance and set its content as desired.</li>
<li>It must define a type <code>edget</code>, representing type of data attached to any edge of the graph; in case edges should not have any data attached, then one can use a predefined class <code><a class="el" href="classempty__edget.html">empty_edget</a></code>. The type must be default-constructible.</li>
<li>It must define a type <code>edgets</code> as an associative container compatible with the type <code>std::map&lt;std::size_t, edget&gt;</code>.</li>
<li>It must define publicly accessible members of the type <code>edgest</code>, named <code>in</code> and <code>out</code>. The members represent edges in the graph. Namely, if <code>u</code> is an index of some node in the graph and <code>v</code> is a key in the map <code>in</code> (resp. <code>out</code>) of that node, then <code>(v, u)</code> (resp. <code>(u, v)</code>) represent an edge in the graph, with attached data <code>in[v]</code> (resp. <code>out[v]</code>).</li>
<li>It must define methods <code>add_in</code>, <code>erase_in</code>, and <code>add_out</code>, <code>erase_out</code> for insertion and removal of values to and from the maps <code>in</code> and <code>out</code>.</li>
<li>It must define a method <code>pretty</code> converting the node to a "pretty" string.</li>
</ul>
<p>One can use a predefined template class <code><a class="el" href="classgraph__nodet.html" title="This class represents a node in a directed graph.">graph_nodet</a>&lt;E&gt;</code> as the template parameter <code>N</code> of the graph. The template parameter <code>E</code> allows to define the type <code>edget</code>.</p>
<h4><a class="anchor" id="autotoc_md171"></a>
Graph algorithms</h4>
<p>The graph implementation comes with several graph algorithms. We describe each of them in following paragraphs.</p>
<p>TODO! </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
