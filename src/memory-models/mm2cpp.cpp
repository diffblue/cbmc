/*******************************************************************\

Module:

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <util/std_code.h>

#include "mm2cpp.h"

/*******************************************************************\

Function: text2c

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

std::string text2c(const irep_idt &src)
{
  std::string result;
  result.reserve(src.size());

  for(unsigned i=0; i<src.size(); i++)
  {
    char ch=src[i];
    if(isalnum(ch))
      result+=ch;
    else
      result+='_';
  }
  
  return result;
}

/*******************************************************************\

Function: cat_instruction2cpp

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void cat_instruction2cpp(const codet &code, unsigned indent)
{
  const irep_idt &statement=code.get_statement();
  
  if(statement==ID_block)
  {
    forall_operands(it, code)
    {
      cat_instruction2cpp(to_code(*it), indent+2);
    }
  }
  else if(statement==ID_let)
  {
    
  }
}

/*******************************************************************\

Function: mm2cpp

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void mm2cpp(
  const irep_idt &model_name,
  const irept &instruction,
  std::ostream &out)
{
  out << "// Generated by mmcc\n";
  out << "// Model: " << model_name << '\n';
  out << '\n';
  
  out << "class memory_model_" << text2c(model_name) << '\n';
  out << "{\n";
  out << "public:\n";
  out << "  void ordered();\n";
  out << "};\n";
  out << '\n';

  out << "void memory_model_" << text2c(model_name) << "::ordered()\n";
  out << "{\n";
  cat_instruction2cpp(to_code(static_cast<const exprt &>(instruction)), 0);
  out << "}\n";
  out << '\n';
}
