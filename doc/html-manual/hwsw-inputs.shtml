<!--#include virtual="header.inc" -->

<p><a href="./">CPROVER Manual TOC</a></p>

<h2>Hardware and Software Equivalence and Co-Verification</h2>

<h3>Synchronizing Inputs</h3>

<h4>Driving Primary Inputs</h4>

<p class="justified">
The examples in the <a href="hwsw-tutorial.shtml">tutorial</a> are trivial
in the sense that the model has only one possible trace. The
initial state is deterministic, and there is only one possible transition,
so the verification problem can be solved by testing a single run. In contrast,
consider the following Verilog module:
</p>

<hr>
<code>
module top(input clk, input i);<br>
<br>
&nbsp;&nbsp;reg [3:0] counter;<br>
<br>
&nbsp;&nbsp;initial counter=0;<br>
<br>
&nbsp;&nbsp;always @(posedge clk)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter=counter+1;<br>
<br>
endmodule
</code>
<hr>

<p class="justified">
The module above has an input named <code>i</code>. The top-level inputs
of the Verilog design have to be generated by the C program.
This is done by assigning the desired values to the corresponding struct
member, and then calling the <code>set_inputs()</code> function
before calling <code>next_timeframe()</code>.
Consider the following example:
</p>

<hr>
<code>
void next_timeframe();<br>
void set_inputs();<br>
extern const unsigned int bound;<br>
<br>
struct module_top {<br>
&nbsp;&nbsp;unsigned int counter;<br>
&nbsp;&nbsp;_Bool i;<br>
};<br>
<br>
extern struct module_top top;<br>
<br>
int main() {<br>
&nbsp;&nbsp;assert(top.counter==0);<br>
<br>
&nbsp;&nbsp;top.i=1;<br>
&nbsp;&nbsp;set_inputs(); next_timeframe();<br>
&nbsp;&nbsp;assert(top.counter==1);<br>
<br>
&nbsp;&nbsp;top.i=1;<br>
&nbsp;&nbsp;set_inputs(); next_timeframe();<br>
&nbsp;&nbsp;assert(top.counter==2);<br>
<br>
&nbsp;&nbsp;top.i=0;<br>
&nbsp;&nbsp;set_inputs(); next_timeframe();<br>
&nbsp;&nbsp;assert(top.counter==2);<br>
}
</code>
<hr>

<p class="justified">
As an example, consider a
Verilog module that has a signal <code>reset</code> as an input, which is
active-low. The following C fragment drives this input to be active in the
first cycle, and not active in any subsequent cycle:
</p>

<hr>
<code>
&nbsp;&nbsp;top.resetn=0;<br>
&nbsp;&nbsp;set_inputs(); next_timeframe();<br>
<br>
&nbsp;&nbsp;for(i=1; i&lt;bound; i++) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;top.resetn=1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;set_inputs(); next_timeframe();<br>
&nbsp;&nbsp;}
</code>
<hr>

<p class="justified">
Note that the value of the input must be set <i>before</i>
calling <code>next_timeframe()</code>. The effect of the
input values on values derived in a combinatorial way
is immediately visible. The effect on clocked values
becomes visible in the next time frame.
</p>

<h4>Using Nondeterminism</h4>

<p class="justified">
The examples above use particular, constant values to drive the primary
inputs.  In order to check the behavior of the Verilog model for more than
one specific input, use <a href="modeling-nondet.shtml">nondeterminism</a>.
</p>

<!--#include virtual="footer.inc" -->

