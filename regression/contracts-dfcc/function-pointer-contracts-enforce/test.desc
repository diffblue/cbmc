CORE
main.c
--restrict-function-pointer foo.function_pointer_call.1/arr_fun_contract --dfcc main --enforce-contract foo --replace-call-with-contract bar
^\[arr_fun_contract.assigns.\d+\].*Check that the assigns clause of contract::arr_fun_contract is included in the caller's assigns clause: SUCCESS$
^\[arr_fun_contract.frees.\d+\].*Check that the frees clause of contract::arr_fun_contract is included in the caller's frees clause: SUCCESS$
^\[arr_fun_contract.precondition.\d+\].*Check requires clause of contract contract::arr_fun_contract for function arr_fun_contract: SUCCESS$
^EXIT=0$
^SIGNAL=0$
^VERIFICATION SUCCESSFUL$
--
--
foo requires that a function pointer given as input satisfies
the contract arr_fun_contract. It nondeterministically updates the function
pointer by calling the function bar. The new function pointer is also assumed
to satisfy the same contract by virtue of bar's post conditions.
Foo then calls the function pointer, after making sure that its preconditions
are satified.
We check that the preconditions of arr_fun_contract are checked and satisfied
and that the assigns clause and frees clause inclusion checks of the function
pointer against foo are also checked and satisfied.
In this test, the function pointer contract is automatically discovered and
swapped with itself.