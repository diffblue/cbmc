<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: solvers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__solvers.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">solvers</div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="autotoc_md162"></a>
Folder solvers</h1>
<dl class="section author"><dt>Authors</dt><dd>Romain Brenguier, Kareem Khazem, Martin Brain</dd></dl>
<h1><a class="anchor" id="solvers-overview"></a>
Overview</h1>
<p>This directory contains most of the decision procedure code in CPROVER. A decision procedure is an algorithm which can check if a set of logical statements is satisfiable, i.e. if there is a value for each variable which makes all of them true at the same time. Formally all that is needed is determining if they are satisfiable, in practice it is often very valuable to know the assignments of the variables. Tools (and components) that implement decision procedures are often called solvers. For example a SAT solver is a tool that implements a decision procedure for checking the satisfiability of formulae (often in CNF) over Boolean variables. An SMT solver is a tool that implements decision procedures for the Satisfiability Modulo Theories class of problems. CPROVER includes its own SMT solver, built on top of a SAT solver but can also interface to external solvers.</p>
<p>CBMC and JBMC create formulae which describe some of the execution of parts of a program (see <a class="el" href="group__goto-symex.html">goto-symex</a> for how this is done) and then use a solver to see if there are any executions which break an assertion. If the formula describing the execution and the formula describing the assertion are satisfiable then it is possible for the assertion to fail and the assignment of the variables can be used to build an error trace (see <a class="el" href="classgoto__tracet.html">goto_tracet</a>). Thus the performance and capability of the solver used is crucial to the utility of CBMC and JBMC. Other tools make use of solvers in other ways to handle other problems. It is important to distinguish between goto-models, goto-programs, etc. which describe programs and have a semantics in terms of execution and formula that have a semantics in terms of logic. Solvers work with formulae and so have no notion of execution order, assignment, "before", branching, loops, exceptions, side-effects, function calls, etc. All of these have to be described in the formula presented to the decision procedure if you want to reason about them.</p>
<p>Other tools use solvers in different ways but the basic interface and ideas remain the same.</p>
<h1><a class="anchor" id="solvers-interfaces"></a>
Key Interfaces</h1>
<p>The most basic interface is <code><a class="el" href="classdecision__proceduret.html" title="An interface for a decision procedure for satisfiability problems.">decision_proceduret</a></code>. It gives the interface of all decision procedures. You call <code>set_to_true</code> and <code>set_to_false</code> to give the formulae and then <code>dec_solve</code> to check if they are satisfiable. If they are, it returns <code>D_SATISFIABLE</code> and you can use <code>get</code> to find the values in the satisfying assignment (if the underlying decision procedure supports this). If you are implementing a solver, then this is the most basic interface you have to support, if you are using the solver, this is the best interface to use as it does not commit you to any particular kind of solver. Looking at the inheritance diagram from <code><a class="el" href="classdecision__proceduret.html" title="An interface for a decision procedure for satisfiability problems.">decision_proceduret</a></code> is a good way of getting an over-view of the solvers currently supported.</p>
<p>Many (but not all) decision procedures have a notion of logical expression and can provide information about logical expressions within the solver. <code><a class="el" href="classprop__convt.html">prop_convt</a></code> expands on the interface of <code><a class="el" href="classdecision__proceduret.html" title="An interface for a decision procedure for satisfiability problems.">decision_proceduret</a></code> to add a data-type (<code>literalt</code>) and interfaces for manipulating logical expressions within the solver.</p>
<p>Within decision procedures it is common to reduce the logical expressions to equivalent expressions in a simpler language. This is similar to what a compiler will do in reducing higher-level language constructs to simple, assembler like instructions. This, of course, relies on having a decision procedure for the simpler language, just as a compiler relies on you having a processor that can handle the assembler. One of the popular choices of "processor" for decision procedures are SAT solvers. These handle a very restricted language in which all variables are simple Booleans and all formulae are just made of logical gates. By keeping their input simple, they can be made very fast and efficient; kind of like RISC processors. Like processors, creating a good SAT solver is a very specialised skill, so CPROVER uses third-party SAT solvers. By default this is MiniSAT, but others are supported (see the <code>sat/</code> directory). To do this it needs a software interface to a SAT solver : this is <code>propt</code>. It uses the same <code>literalt</code> to refer to Boolean variables, just as <code><a class="el" href="classprop__convt.html">prop_convt</a></code> uses them to refer to logical expressions. <code>land</code>, <code>lor</code>, <code>lxor</code> and so on allow gates to be constructed to express the formulae to be solved. If <code>cnf_handled_well</code> is true then you may also use <code>lcnf</code> to build formulae. Finally, <code>prop_solve</code> will run the decision procedure.</p>
<p>As previously mentioned, many decision procedures reduce formulae to CNF and solve with a SAT solver. <code><a class="el" href="classprop__conv__solvert.html">prop_conv_solvert</a></code> contains the foundations of this conversion. It implements the <code><a class="el" href="classprop__convt.html">prop_convt</a></code> by having an instance of <code>propt</code> (a SAT solver) and reducing the expressions that are input into CNF. The key entry point to this procedure is <code><a class="el" href="classprop__conv__solvert.html#aa7c020022f38d6901df99ce3e1eff5dc" title="Convert a Boolean expression and return the corresponding literal.">prop_conv_solvert::convert</a></code> which then splits into <code>prop_conv_solvert::convert_boolean</code> (which uses <code><a class="el" href="classpropt.html#a1a48b41843845690130ab0980695bea1">propt::land</a></code> and so on to convert Boolean expressions) and <code><a class="el" href="classprop__conv__solvert.html#ab4c30a4d86aa49d42759ce1ff3282ec3">prop_conv_solvert::convert_rest</a></code> which gives an error to start with. Various solvers inherit from <code><a class="el" href="classprop__conv__solvert.html">prop_conv_solvert</a></code> adding to <code>convert</code> and <code>convert_rest</code> to increase the language of expressions that can be converted. <code>equalityt</code> adds handling of equality between variables, <code>arrayst</code> then builds on that to add support for arrays, <code>boolbvt</code> adds bit-vector operations (plus, negate, multiply, shift, etc.) and finally <code>bv_pointers</code> adds pointers. This layering simplifies the conversion to CNF and allows parts of it to be over-ridden and modified (as <code><a class="el" href="classbv__refinementt.html">bv_refinementt</a></code> and <code><a class="el" href="classstring__refinementt.html">string_refinementt</a></code> do).</p>
<h1><a class="anchor" id="solvers-directories"></a>
Directories</h1>
<ul>
<li><code>prop/</code>: The interfaces above mostly live in <code>prop/</code>, which also contains a number of other supporting classes, like <code><a class="el" href="literal_8h.html">literal.h</a></code>.</li>
<li><code>sat/</code>: All of the code for interacting and interfacing with SAT solvers. This is largely a 'leaf' directory and makes little use of external interfaces beyond things in <code>prop</code>. <code><a class="el" href="cnf_8h.html" title="CNF Generation, via Tseitin.">cnf.h</a></code> contains <code>cnft</code> and <code><a class="el" href="classcnf__solvert.html">cnf_solvert</a></code> which give default implements <code>propt</code>s gate functions (<code>land</code>, <code>lxor</code>, etc.) in terms of <code>lcnf</code> as most modern SAT solvers only have interfaces for handling CNF, not logical gates. The various satcheck_* files implement the <code>propt</code> interfaces (generally with the <code><a class="el" href="classcnf__solvert.html">cnf_solvert</a></code> additions / simplifications) by connecting to various third-party SAT solvers. Finally <code><a class="el" href="satcheck_8h.html">satcheck.h</a></code> use the build time flags to pick which SAT solvers are available and which should be used as default.</li>
<li><code>qbf/</code>: An equivalent of <code>sat/</code> for QBF solvers. These extend the basic language of SAT solvers with universal and existential quantification over Boolean variables. This makes the solvers more expressive but also slower. <code>qbf/</code> is not used by the main CPROVER tools and the solvers it integrates are somewhat dated.</li>
<li><code>flattening/</code>: A library that converts operations to bit-vectors, including calling the conversions in <code>floatbv</code> as necessary. Is implemented as a simple conversion (with caching) and then a post-processing function that adds extra constraints. The <code>boolbvt</code> solver uses these to express bit-vector operations via the <code>propt</code> interfaces. This is not used by the SMT2 back-ends.</li>
<li>smt2/: Provides the <code><a class="el" href="classsmt2__dect.html" title="Decision procedure interface for various SMT 2.x solvers.">smt2_dect</a></code> type which converts the formulae to SMT-LIB 2 and then invokes one of Boolector, CVC3, CVC4, MathSAT, Yices or Z3. Note that the interaction with the solver is batched and uses temporary files rather than using the interactive command supported by SMT-LIB 2. With the <code>–fpa</code> option, this output mode will not flatten the floating point arithmetic and instead output SMT-LIB floating point standard.</li>
<li><code>floatbv/</code>: This library contains the code that is used to convert floating point variables (<code>floatbv</code>) to bit vectors (<code>bv</code>). This is referred to as ‘bit-blasting’ and is called in the <code>solver</code> code during conversion to SAT or SMT. It also contains the abstraction code described in the FMCAD09 paper.</li>
<li><code>lowering/</code>: These are <code>exprt</code> to <code>exprt</code> reductions of operations rather than the <code>exprt</code> to <code>bvt</code> reductions in <code>flattening/</code> allowing them to be used in SMT solvers which do not inherit from <code><a class="el" href="classprop__conv__solvert.html">prop_conv_solvert</a></code>.</li>
<li><code>refinement/</code>: Solvers that build on the <code><a class="el" href="classbv__pointerst.html">bv_pointerst</a></code> solver interface and specialise the handling of certain operations to improve performance.</li>
<li><code>miniBDD/</code>: A canonical representation of Boolean formulae.</li>
</ul>
<h1><a class="anchor" id="flattening-section"></a>
Flattening</h1>
<p><b>Key classes:</b></p><ul>
<li><a class="el" href="classpropt.html">propt</a> (in solvers/prop)</li>
<li><a class="el" href="classboolbvt.html">boolbvt</a></li>
<li><a class="el" href="classbv__utilst.html">bv_utilst</a></li>
</ul>
<p>The main class in this folder is <a class="el" href="classboolbvt.html">boolbvt</a> which wraps a variety of helper methods and classes (including inherited ones) and acts as an interface for transforming <a class="el" href="classexprt.html">exprt</a> into boolean formula and then solving it.</p>
<p>Many of its methods are focused around transforming a particular <a class="el" href="classexprt.html">exprt</a> into a vector of <a class="el" href="classliteralt.html">literalt</a> and then passing them to a <a class="el" href="classpropt.html">propt</a> for formula building / solving.</p>
<p>The primary methods are:</p>
<p>Note: <code>bvt</code> mentioned below is an alias to a vector of literalt.</p>
<p><code>bvt <a class="el" href="classboolbvt.html#a34f4d4fcb281e7074cecb324d588ee58" title="Converts an expression into its gate-level representation and returns a vector of literals correspond...">boolbvt::convert_bitvector(const exprt &amp;expr)</a></code></p>
<p>Which takes an exprt then calls the associated transformation functions to generate the <a class="el" href="classliteralt.html">literalt</a> vector to then pass to the internal <a class="el" href="classpropt.html">propt</a> instance.</p>
<p><code>const bvt &amp; <a class="el" href="classboolbvt.html#a14d25478f6b405c78cbbf3574ab0b03e" title="Convert expression to vector of literalts, using an internal cache to speed up conversion if availabl...">boolbvt::convert_bv</a>(const exprt &amp;expr, std::optional&lt;std::size_t&gt; expected_width)</code></p>
<p>Similar to convert_bitvector except it also provides basic caching and freezing results for incremental solving. It calls convert_bitvector internally.</p>
<p><code>literalt <a class="el" href="classboolbvt.html#af78c5a7a2e0aca78bf5d099e095e6143">boolbvt::convert_rest(const exprt &amp;expr)</a></code></p>
<p>(Note: I'm not sure why this is split from the normal convert_bitvector, but it's probably worth mentioning)</p>
<p><code>void post_process()</code></p>
<p>Performs any post-processing, which is normally adding constraints that require some global knowledge of the formula, ex. for encoding arrays into uninterpreted functions.</p>
<p><b>Some key classes:</b></p>
<p><a class="el" href="classpropt.html">propt</a> is instance of whichever solver is currently being used. This inherits from <code><a class="el" href="classdecision__proceduret.html" title="An interface for a decision procedure for satisfiability problems.">decision_proceduret</a></code> whose interface has a fuller explanation in the "General Interfaces" subsection.</p>
<p><a class="el" href="classbv__utilst.html">bv_utilst</a> holds a set of utility functions for bit manipulation that work upon <a class="el" href="classliteralt.html">literal</a>s (or vectors of them). Holds a reference to the propt that its parent uses.</p>
<p><a class="el" href="classfunctionst.html">functionst</a> Helper class that keeps a list of uninterpreted functions which then gets used to add function constraints when <code>post_process</code> is called.</p>
<p><a class="el" href="classboolbv__mapt.html">boolbv_mapt</a> Helper class that maps an <a class="el" href="irep_8h.html#a1ad4faefa9ca542d481e74be9cc01c2c">irep_idt</a> (and a type) to a vector of <a class="el" href="classliteralt.html">literal</a>s.</p>
<p><a class="el" href="classarrayst.html">arrayst</a> Base class of <a class="el" href="classboolbvt.html">boolbvt</a>. Adds additional array constraints when <code>post_process</code> is called.</p>
<p><a class="el" href="classequalityt.html">equalityt</a> Base class of <a class="el" href="classboolbvt.html">boolbvt</a>. Adds equality constraints between bitvectors when <code>post_process</code> is called.</p>
<h1><a class="anchor" id="solver-apis"></a>
Solver APIs</h1>
<h2><a class="anchor" id="smt-solving-api-section"></a>
SMT solving API</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="sat-solving-api-section"></a>
SAT solving API</h2>
<p>The basic SAT solver interface is in <a class="el" href="classcnft.html">cnf</a>. This inherits from the <a class="el" href="classpropt.html">propositional logic decision procedure wrapper</a>.</p>
<p>The interface supports the following operations by default:</p><ol type="1">
<li>Boolean operations on literals (like <code>and</code>, <code>or</code>, <code>xor</code>), etc. These take as input two <a class="el" href="classliteralt.html">literals</a> and return as output another <a class="el" href="classliteralt.html">literal</a>, applying Tseitin's transformation on them. Tseitin's transformation converts a propositional formula <code>F</code> into an equisatisfiable CNF formula that is linear in the size of <code>F</code>. For more information look at: <a href="https://en.wikipedia.org/wiki/Tseytin_transformation">https://en.wikipedia.org/wiki/Tseytin_transformation</a></li>
<li>Generating new <a class="el" href="classliteralt.html">literals</a> and adding their variables to the formula and returning the number of variables or clauses the solver is operating with (with <code>no_variables</code>).</li>
</ol>
<p>This interface is then extended by the various solver interfaces which implement the interface by hooking into the solver related functions that implement the operations that they abstract. Solvers for which drivers exist include <a class="el" href="namespace_minisat.html">Minisat</a>, Minisat2, Chaff, Picosat, <a class="el" href="namespace_glucose.html">Glucose</a>, Cadical, Booleforce and Lingeling.</p>
<p>For example, the <a class="el" href="namespace_minisat.html">Minisat</a> 2 interface (in <code><a class="el" href="satcheck__minisat2_8h.html">satcheck_minisat2.h</a></code>) implements a method <code>prop_solve()</code> that hooks into <a class="el" href="namespace_minisat.html">Minisat</a> 2's interface by initialising the variable list <a class="el" href="namespace_minisat.html">Minisat</a> 2 will use, and then invoking the actual solver on the formula and checking whether the solver could manage find a satisfying assignment or not.</p>
<p>For more details on how the particular drivers work, refer to them in their interface and implementation files, which follow the naming pattern <code>satcheck_x</code>, where <code>x</code> is the name of the solver.</p>
<p>We also support any solver that can hook into <a href="http://www.cs.utexas.edu/users/moore/acl2/manuals/current/manual/index-seo.php/IPASIR____IPASIR">ipasir</a>. This is a generic incremental SAT solver API. This is handled by the <code><a class="el" href="satcheck__ipasir_8h.html">satcheck_ipasir.h</a></code> interface abstracts over <code>ipasir</code> with our own generic interface. For a description of the <code>ipasir</code> interface take a look at the following file: <a href="https://github.com/biotomas/ipasir/blob/master/ipasir.h">ipasir.h</a></p>
<h1><a class="anchor" id="sat-smt-encoding"></a>
SAT/SMT Encoding</h1>
<p>In the <a class="el" href="group__solvers.html">solvers</a> directory.</p>
<p><b>Key classes:</b></p><ul>
<li><a class="el" href="classliteralt.html">literalt</a></li>
<li><a class="el" href="classboolbvt.html">boolbvt</a></li>
<li><a class="el" href="classpropt.html">propt</a></li>
</ul>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_21.svg" width="984" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<hr  />
<h1><a class="anchor" id="decision-procedure"></a>
Decision Procedure</h1>
<p>In the <a class="el" href="group__solvers.html">solvers</a> directory.</p>
<p><b>Key classes:</b></p><ul>
<li><a class="el" href="classsymex__target__equationt.html" title="Inheriting the interface of symex_targett this class represents the SSA form of the input program as ...">symex_target_equationt</a></li>
<li><a class="el" href="classpropt.html">propt</a></li>
</ul>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_22.svg" width="978" height="59"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h1><a class="anchor" id="string-solver-interface"></a>
String Solver Interface</h1>
<p>The string solver is particularly aimed at string logic, but since it inherits from <a class="el" href="classbv__refinementt.html">bv_refinementt</a> it is also capable of handling arithmetic, array logic, floating point operations etc. The backend uses the flattening of <a class="el" href="classboolbvt.html">boolbvt</a> to convert expressions to boolean formula.</p>
<p>An example of a problem given to string solver could look like this:</p>
<div class="fragment"><div class="line">return_code == cprover_string_concat_func(</div>
<div class="line">  length1, array1,</div>
<div class="line">  { .length=length2, .content=content2 },</div>
<div class="line">  { .length=length3, .content=content3 })</div>
<div class="line">length3 == length2</div>
<div class="line">content3 == content2</div>
<div class="line">is_equal == cprover_string_equals_func(length1, array1, 2, {&#39;a&#39;, &#39;a&#39;})</div>
<div class="line">is_equal == 1</div>
</div><!-- fragment --><p>Details about the meaning of the primitives <code>cprover_string_concat_func</code> and <code>cprover_string_equals_func</code> are given in section <a class="el" href="group__solvers.html#primitives">String Primitives</a>.</p>
<p>The first equality means that the string represented by <code>{length1, array1}</code> is the concatanation of the string represented by <code>{length2, array2}</code> and <code>{length3, array3}</code>. The second and third mean that <code>{length2, array2}</code> and <code>{length3, array3}</code> represent the same string. The fourth means that <code>is_equal</code> is 1 if and only if <code>{length1, array1}</code> is the string "aa". The last equation ensures that <code>is_equal</code> has to be equal to 1 in the solution.</p>
<p>For this system of equations the string solver should answer that it is satisfiable. It is then possible to recover which assignments make all equation true, in that case <code>length2 = length3 = 1</code> and &lsquo;content2 = content3 = {'a&rsquo;}`.</p>
<h2><a class="anchor" id="general_interface"></a>
General interface</h2>
<p>The common interface for solvers in CProver is inherited from <code><a class="el" href="classdecision__proceduret.html" title="An interface for a decision procedure for satisfiability problems.">decision_proceduret</a></code> and is the common interface for all solvers. It is essentially composed of these three functions:</p>
<ul>
<li><code><a class="el" href="classstring__refinementt.html#aab339349e5c6a8cb3c8f61010f04b5ca" title="Record the constraints to ensure that the expression is true when the boolean is true and false other...">string_refinementt::set_to(const exprt &amp;expr, bool value)</a></code>: Record the constraints to ensure that the expression is true when the boolean is true and false otherwise.</li>
<li><code><a class="el" href="classstring__refinementt.html#a62e604a1865aa7853799bc24c1ad3fcd" title="Main decision procedure of the solver.">string_refinementt::dec_solve()</a></code>: Main decision procedure of the solver.</li>
<li><code><a class="el" href="classstring__refinementt.html#ac5296b634b2451a0a9859f62a2dddca6" title="Evaluates the given expression in the valuation found by string_refinementt::dec_solve.">string_refinementt::get(const exprt &amp;expr) const</a></code>: Evaluates the given expression in the valuation found by <a class="el" href="classstring__refinementt.html#a62e604a1865aa7853799bc24c1ad3fcd" title="Main decision procedure of the solver.">string_refinementt::dec_solve</a>.</li>
</ul>
<p>For each goal given to CProver:</p><ul>
<li><code>set_to</code> is called on several equations, roughly one for each step of the symbolic execution that leads to that goal;</li>
<li><code>dec_solve</code> is called to determine whether the goal is reachable given these equations;</li>
<li><code>get</code> is called by the interpreter to obtain concrete value to build a trace leading to the goal;</li>
<li>The same process can be repeated for further goals, in that case the constraints added by previous calls to <code>set_to</code> remain valid.</li>
</ul>
<h2><a class="anchor" id="specificity"></a>
Specificity of the string solver</h2>
<p>The specificity of the solver is in what kind of expressions <code>set_to</code> accepts and understands. <code><a class="el" href="classstring__refinementt.html#aab339349e5c6a8cb3c8f61010f04b5ca" title="Record the constraints to ensure that the expression is true when the boolean is true and false other...">string_refinementt::set_to</a></code> accepts all constraints that are normally accepted by <code><a class="el" href="classbv__refinementt.html">bv_refinementt</a></code>.</p>
<p><code><a class="el" href="classstring__refinementt.html#aab339349e5c6a8cb3c8f61010f04b5ca" title="Record the constraints to ensure that the expression is true when the boolean is true and false other...">string_refinementt::set_to</a></code> also understands constraints of the form:</p><ul>
<li><code>char_pointer1 = b ? char_pointer2 : char_pointer3</code> where <code>char_pointer&lt;i&gt;</code> variables are of type pointer to characters and <code>b</code> is a Boolean expression.</li>
<li><code>i = cprover_primitive(args)</code> where <code>i</code> is of signed bit vector type. String primitives are listed in the next section.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>In the implementation, equations that are not of these forms are passed to an embedded <code><a class="el" href="classbv__refinementt.html">bv_refinementt</a></code> solver.</dd></dl>
<h2><a class="anchor" id="string-representation"></a>
String representation in the solver</h2>
<p>String primitives can have arguments which are pointers to characters. These pointers represent strings. To each of these pointers the string solver associate a char array which represents the content of the string. If the pointer is the address of an actual array in the program they should be linked by using the primitive <code>cprover_string_associate_array_to_pointer</code>. The length of the array can also be linked to a variable of the program using <code>cprover_string_associate_length_to_array</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The solver assumes the memory pointed by the arguments is immutable which is not something that is true in general for C pointers for instance. Therefore for each transformation on a string, it is assumed the program allocates a new string before calling a primitive.</dd></dl>
<h1><a class="anchor" id="builtin-functions"></a>
Builtin functions</h1>
<p>String operations are handled as "builtin functions", which can operate in two modes:</p><ol type="1">
<li>constraint generation</li>
<li>model evaluation</li>
</ol>
<p>This is described in more detail <a class="el" href="classstring__builtin__functiont.html">here. </a></p>
<h1><a class="anchor" id="primitives"></a>
String primitives</h1>
<h2><a class="anchor" id="basic-primitives"></a>
Basic access:</h2>
<ul>
<li><code>cprover_string_associate_array_to_pointer</code> : Link with an array of characters of the program.</li>
<li><code>cprover_string_associate_length_to_array</code> : Link the length of the array with the given integer value.</li>
<li><code>cprover_string_char_at</code> : Character at a given position. <a class="el" href="classstring__constraint__generatort.html#ad2eba61dc98ff9c33d85ddc5db6c8d6e">More... </a></li>
<li><code>cprover_string_length</code> : Length of a string. <a class="el" href="classstring__constraint__generatort.html#ae0ab1148baaf52c82aeb389c764704ec">More... </a></li>
</ul>
<h2><a class="anchor" id="comparisons"></a>
Comparisons:</h2>
<ul>
<li><code>cprover_string_compare_to</code> : Lexicographic comparison of two strings. <a class="el" href="classstring__constraint__generatort.html#a094b01404a1528d9d36ff8c9a90789c2">More... </a></li>
<li><code>cprover_string_contains</code> : Test whether a string contains another. <a class="el" href="classstring__constraint__generatort.html#a947bfc18e507ae29f4c9c24c849008da">More... </a></li>
<li><code>cprover_string_equals</code> : Equality of the content of two strings. <a class="el" href="classstring__constraint__generatort.html#a2564a8557294c2a97adc17eaac4faaa9">More... </a></li>
<li><code>cprover_string_equals_ignore_case</code> : Equality of the content ignoring case of characters. <a class="el" href="classstring__constraint__generatort.html#a098d449152e6871936586b8f3ef911f0">More... </a></li>
<li><code>cprover_string_is_prefix</code> : Add axioms stating that the returned expression is true exactly when the offset is greater or equal to 0 and the first string is a prefix of the second one, starting at position offset. <a class="el" href="classstring__constraint__generatort.html#a767cec45b3a581dfab202a481ce5809b">More... </a></li>
<li><code>cprover_string_index_of</code> : Index of the first occurence of a target inside the string. <a class="el" href="classstring__constraint__generatort.html#aceef0bfde58d9441a98c748db3107523">More... </a></li>
<li><code>cprover_string_last_index_of</code> : Index of the last occurence of a target inside the string. <a class="el" href="classstring__constraint__generatort.html#abca07d170bbcfcd740a32f30c16ed005">More... </a></li>
</ul>
<h2><a class="anchor" id="transformations"></a>
Transformations:</h2>
<ul>
<li><code>cprover_string_char_set</code> : Set of constraints ensuring that <code>result</code> is similar to <code>input</code> where the character at index <code>position</code> is set to <code>character</code>. <a class="el" href="classstring__set__char__builtin__functiont.html#aa52d6ca08acdf9cb9a63287bc61bc62d">More... </a></li>
<li><code>cprover_string_concat</code> : Add axioms enforcing that <code>res</code> is equal to the concatenation of <code>s1</code> and <code>s2</code>. <a class="el" href="classstring__constraint__generatort.html#a3674489dd834809a99bb80f9a0e731ee">More... </a></li>
<li><code>cprover_string_delete</code> : Remove a portion of a string. <a class="el" href="classstring__constraint__generatort.html#a75ba1c88b61ff22ee4e116b7462b4f13">More... </a></li>
<li><code>cprover_string_insert</code> : Constraints ensuring the <code>result</code> corresponds to <code>input1</code> where we inserted <code>input2</code> at position <code>offset</code> given by the first argument. <a class="el" href="classstring__insertion__builtin__functiont.html#a26fd9a7dffe37f08db6717341948d1de">More... </a></li>
<li><code>cprover_string_replace</code> : Replace a character by another in a string. <a class="el" href="classstring__constraint__generatort.html#a7f337a6e1697edc8c6db192243084a0a">More... </a></li>
<li><code>cprover_string_set_length</code> : Reduce or extend a string to have the given length. <a class="el" href="classstring__constraint__generatort.html#a6ef6ab647296c131587157505d4edbb3">More... </a></li>
<li><code>cprover_string_substring</code> : Substring of a string between two indices. <a class="el" href="classstring__constraint__generatort.html#a9251d46e59b15892d46a08224fff35cf">More... </a></li>
<li><code>cprover_string_to_lower_case</code> : Set of constraints ensuring <code>result</code> corresponds to <code>input</code> in which uppercase characters have been converted to lowercase. <a class="el" href="classstring__to__lower__case__builtin__functiont.html#aba79d40faa63596f0c2a695f6bad8dd2">More... </a></li>
<li><code>cprover_string_to_upper_case</code> : Set of constraints ensuring <code>result</code> corresponds to <code>input</code> in which lowercase characters of Basic Latin and Latin-1 supplement of unicode have been converted to uppercase. <a class="el" href="classstring__to__upper__case__builtin__functiont.html#a4956cadb1fd7864fdaa5428a14e88ddf">More... </a></li>
<li><code>cprover_string_trim</code> : Remove leading and trailing whitespaces. <a class="el" href="classstring__constraint__generatort.html#a77d74444fe41524a7528a40dad56dc52">More... </a></li>
</ul>
<h2><a class="anchor" id="conversions"></a>
Conversions:</h2>
<ul>
<li><code>cprover_string_format</code> : Parse <code>s</code> and add axioms ensuring the output corresponds to the output of String.format. <a class="el" href="string__format__builtin__function_8cpp.html#a57da6580528fc39e2e8099ce9bc99c0a">More... </a></li>
<li><code>cprover_string_from_literal</code> : String corresponding to an internal cprover string. <a class="el" href="classstring__constraint__generatort.html#a8aab0f9856ebd30a24a8e08214f5c9a2">More... </a></li>
<li><code>cprover_string_of_int</code> : Add axioms enforcing that the string corresponds to the result of String.valueOf(I) or String.valueOf(J) Java functions applied on the integer expression. <a class="el" href="classstring__constraint__generatort.html#a5ddef0b51489e4b1fb5f2a2d26e23f5f">More... </a></li>
<li><code>cprover_string_of_float</code> : String representation of a float value. <a class="el" href="classstring__constraint__generatort.html#ac236732228bb23fad6099e9226ec5c3a">More... </a></li>
<li><code>cprover_string_of_float_scientific_notation</code> : Add axioms to write the float in scientific notation. <a class="el" href="classstring__constraint__generatort.html#abe967436462fe6f89f09ebf821b7e855">More... </a></li>
<li><code>cprover_string_parse_int</code> : Integer value represented by a string. <a class="el" href="classstring__constraint__generatort.html#a81b1ef8ad359acc371c5031f0e6be5e8">More... </a></li>
</ul>
<h2><a class="anchor" id="solvers-deprecated"></a>
Deprecated primitives:</h2>
<ul>
<li><code>cprover_string_concat_code_point</code>, <code>cprover_string_code_point_at</code>, <code>cprover_string_code_point_before</code>, <code>cprover_string_code_point_count</code>: Java specific, should be part of Java models.</li>
<li><code>cprover_string_offset_by_code_point</code>, <code>cprover_string_concat_char</code>, <code>cprover_string_concat_int</code>, <code>cprover_string_concat_long</code>, <code>cprover_string_concat_bool</code>, <code>cprover_string_concat_double</code>, <code>cprover_string_concat_float</code> : Should be done in two steps: conversion from primitive type and call to the string primitive.</li>
<li><code>cprover_string_array_of_char_pointer</code>, <code>cprover_string_to_char_array</code> : Pointer to char array association is now handled by <code><a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a></code>, there is no need for explicit conversion.</li>
<li><code>cprover_string_is_empty</code> : Should use <code>cprover_string_length(s) == 0</code> instead.</li>
<li><code>cprover_string_is_suffix</code> : Should use <code>cprover_string_is_prefix</code> with an offset argument.</li>
<li><code>cprover_string_empty_string</code> : Can use literal of empty string instead.</li>
<li><code>cprover_string_of_long</code> : Should be the same as <code>cprover_string_of_int</code>.</li>
<li><code>cprover_string_delete_char_at</code> : A call to <code>cprover_string_delete_char_at(s, i)</code> would be the same thing as <code>cprover_string_delete(s, i, i+1)</code>.</li>
<li><code>cprover_string_copy</code> : Same as <code>cprover_string_substring(s, 0)</code>.</li>
<li><code>cprover_string_of_int_hex</code> : Same as <code>cprover_string_of_int(s, 16)</code>.</li>
<li><code>cprover_string_of_double</code> : Same as <code>cprover_string_of_float</code>.</li>
</ul>
<h1><a class="anchor" id="algorithm"></a>
Decision algorithm</h1>
<p>Looks for a valuation of variables compatible with the constraints that have been given to <code>set_to</code> so far.</p>
<p>The decision procedure initiated by <a class="el" href="classstring__refinementt.html#a62e604a1865aa7853799bc24c1ad3fcd" title="Main decision procedure of the solver.">string_refinementt::dec_solve</a> is composed of several steps detailed below.</p>
<h2><a class="anchor" id="autotoc_md165"></a>
Symbol resolution</h2>
<p>Pointer symbols which are set to be equal by constraints, are replaced by an single symbol in the solver. The <code>symbol_solvert</code> object used for this substitution is constructed by <code>generate_symbol_resolution_from_equations(const std::vector&lt;<a class="el" href="classequal__exprt.html" title="Equality.">equal_exprt</a>&gt;&amp;,const namespacet&amp;,<a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a>&amp;)</code>. All these symbols are then replaced using <code>replace_symbols_in_equations(const <a class="el" href="classunion__find__replacet.html" title="Similar interface to union-find for expressions, with a function for replacing sub-expressions by the...">union_find_replacet</a> &amp;, std::vector&lt;<a class="el" href="classequal__exprt.html" title="Equality.">equal_exprt</a>&gt; &amp;)</code>.</p>
<h2><a class="anchor" id="autotoc_md166"></a>
Conversion to first order formulas:</h2>
<p>Each string primitive is converted to a list of first order formulas by the function <code>substitute_function_applications_in_equations(std::vector&lt;<a class="el" href="classequal__exprt.html" title="Equality.">equal_exprt</a>&gt;&amp;,<a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a>&amp;)</code>. These formulas should be unquantified or be either a <code><a class="el" href="classstring__constraintt.html">string_constraintt</a></code> or a <code><a class="el" href="structstring__not__contains__constraintt.html" title="Constraints to encode non containement of strings.">string_not_contains_constraintt</a></code>. The constraints corresponding to each primitive can be found by following the links in section <a class="el" href="group__solvers.html#primitives">String primitives</a>.</p>
<p>Since only arrays appear in the string constraints, during the conversion to first order formulas, pointers are associated to arrays. The <code><a class="el" href="classstring__constraint__generatort.html">string_constraint_generatort</a></code> object keeps track of this association. It can either be set manually using the primitives <code>cprover_associate_array_to_pointer</code> or a fresh array is created.</p>
<h2><a class="anchor" id="autotoc_md167"></a>
Refinement loop</h2>
<p>We use <code>super_dec_solve</code> and <code>super_get</code> to denote the methods of the underlying solver (<code><a class="el" href="classbv__refinementt.html">bv_refinementt</a></code> by default). The refinement loop relies on functions <code>string_refinementt::check_axioms</code> which returns true when the set of quantified constraints <code>q</code> is satisfied by the valuation given by<code>super_get</code> and <code>string_refinementt::instantiate</code> which gives propositional formulas implied by a string constraint. If the following algorithm returns <code>SAT</code> or <code>UNSAT</code>, the given constraints are <code>SAT</code> or <code>UNSAT</code> respectively: </p><div class="fragment"><div class="line">is_SAT(unquantified_constraints uq, quantified_constraints q)</div>
<div class="line">{</div>
<div class="line">  cur &lt;- uq;</div>
<div class="line">  while(limit--) &gt; 0</div>
<div class="line">  {</div>
<div class="line">    if(super_dec_solve(cur)==SAT)</div>
<div class="line">    {</div>
<div class="line">      if(check_axioms(q, super_get))</div>
<div class="line">      else</div>
<div class="line">        for(axiom in q)</div>
<div class="line">          cur.add(instantiate(axiom));</div>
<div class="line">        return SAT;</div>
<div class="line">    }</div>
<div class="line">    else</div>
<div class="line">      return UNSAT;</div>
<div class="line">  }</div>
<div class="line">  return ERROR;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd><code>resultt::D_SATISFIABLE</code> if the constraints are satisfiable, <code>resultt::D_UNSATISFIABLE</code> if they are unsatisfiable, <code>resultt::D_ERROR</code> if the limit of iteration was reached.</dd></dl>
<h2><a class="anchor" id="instantiation"></a>
Instantiation</h2>
<p>This is done by <a class="el" href="string__refinement_8cpp.html#a41c296f3d6eae2764f28bf45efc96583" title="Instantiation of all constraints.">generate_instantiations(const index_set_pairt &amp;index_set, const string_axiomst &amp;axioms, const std::unordered_map&lt;string_not_contains_constraintt, symbol_exprt&gt; &amp;not_contain_witnesses)</a>. The string refinement decision procedure works with two types of quantified axioms, which are of the form \(\forall x.\ P(x)\) (<code><a class="el" href="classstring__constraintt.html">string_constraintt</a></code>) or of the form \(\forall x. P(x) \Rightarrow \exists y .s_0[x+y] \ne s_1[y] \) (<code><a class="el" href="structstring__not__contains__constraintt.html" title="Constraints to encode non containement of strings.">string_not_contains_constraintt</a></code>). They are instantiated in a way which depends on their form:</p><ul>
<li>For formulas of the form \(\forall x.\ P(x)\) if string <code>str</code> appears in <code>P</code> indexed by some <code>f(x)</code> and <code>val</code> is in the index set of <code>str</code> we find <code>y</code> such that <code>f(y)=val</code> and add lemma <code>P(y)</code>. (See <code>instantiate(<a class="el" href="classmessaget_1_1mstreamt.html">messaget::mstreamt</a>&amp;, const <a class="el" href="classstring__constraintt.html">string_constraintt</a>&amp;, const exprt &amp;, const exprt&amp;)</code> for details.)</li>
<li>For formulas of the form \(\forall x. P(x) \Rightarrow \exists y .s_0[x+y] \ne s_1[y]) \) we need to look at the index set of both <code>s_0</code> and <code>s_1</code>. (See <code>instantiate(const <a class="el" href="structstring__not__contains__constraintt.html" title="Constraints to encode non containement of strings.">string_not_contains_constraintt</a>&amp;, const <a class="el" href="structindex__set__pairt.html">index_set_pairt</a>&amp;, const std::map&lt;string_not_contains_constraintt, symbol_exprt&gt;&amp;)</code> for details.)</li>
</ul>
<h2><a class="anchor" id="axiom-check"></a>
Axiom check</h2>
<p>For each string_constraint <code>a</code>:</p><ul>
<li>the negation of <code>a</code> is an existential formula <code>b</code>;</li>
<li>we substituted symbols in <code>b</code> by their values found in <code>get</code>;</li>
<li>arrays are concretized, meaning we attribute a value for characters that are unknown to get, for details see substitute_array_access;</li>
<li><code>b</code> is simplified and array accesses are replaced by expressions without arrays;</li>
<li>we give lemma <code>b</code> to a fresh solver;</li>
<li>if no counter-example to <code>b</code> is found, this means the constraint <code>a</code> is satisfied by the valuation given by get. <dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current model satisfies all the axioms, <code>false</code> otherwise with a list of lemmas which are obtained by instantiating constraints at indexes given by counter-examples.</dd>
<dd>
true if the current model satisfies all the axioms <a class="el" href="string__refinement_8cpp.html#a479ec7cdc1b70d68eefdc14deaaabfab">(See function documentation...) </a></dd></dl>
</li>
</ul>
<h1><a class="anchor" id="floatbv"></a>
Floatbv Directory</h1>
<p>This library contains the code that is used to convert floating point variables (<code>floatbv</code>) to bit vectors (<code>bv</code>). This is referred to as ‘bit-blasting’ and is called in the <code>solver</code> code during conversion to SAT or SMT. It also contains the abstraction code described in the FMCAD09 paper. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
