<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: Background Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('background-concepts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Background Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Control granularity of object accesses.</p>
<dl class="section author"><dt>Author</dt><dd>Martin Brain, Peter Schrammel, Johannes Kloos</dd></dl>
<p>The purpose of this section is to explain several key concepts used throughout the CPROVER framework at a high level, ignoring the details of the actual implementation. In particular, we will discuss different ways to represent programs in memory, three important analysis methods and some commonly used terms.</p>
<h1><a class="anchor" id="representations_section"></a>
Representations</h1>
<p>One of the first questions we should be considering is how we represent programs in such a way that we can easily analyze and reason about them.</p>
<p>As it turns out, the best way to do this is to use a variety of different representations, each representing a different level of abstraction. These representations are designed in such a way that for each analysis we want to perform, there is an appropriate representation, and it is easy to go from representations that are close to the source code to representations that focus on specific semantic aspects of the program.</p>
<p>The representations that the CPROVER framework uses mirror those used in modern compilers such as LLVM and gcc. I will point out those places where the CPROVER framework does things differently, attempting to give rationales wherever possible.</p>
<p>One in-depth resource for most of this section is the classic <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">compiler construction text book ''Compilers: Principles, Techniques and Tools''</a> by Aho, Lam, Sethi and Ullman.</p>
<p>To illustrate the different concepts, we will consider a small example program. While the program is in C, the general ideas apply to other languages as well - see later sections of this manual to understand how the specific features of those languages are handled. Our running example will be a program that calculates factorials.</p>
<div class="fragment"><div class="line"><span class="comment">/* factorial.c</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * For simplicity&#39;s sake, we just give the forward</span></div>
<div class="line"><span class="comment"> * declarations of atoi and printf.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="stdlib_8c.html#ad228deceea1bac4d9f171f647c265059">atoi</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *);</div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="stdio_8c.html#a98631211a4a8aee62f572375d5b637be">printf</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *, ...);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> factorial(<span class="keywordtype">unsigned</span> n) {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac = 1;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt;= n; i++) {</div>
<div class="line">    fac *= i;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> fac;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Error handling elided - this is just for illustration. */</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="keywordtype">unsigned</span> n = <a class="code" href="stdlib_8c.html#ad228deceea1bac4d9f171f647c265059">atoi</a>(argv[1]);</div>
<div class="line">  <a class="code" href="stdio_8c.html#a98631211a4a8aee62f572375d5b637be">printf</a>(<span class="stringliteral">&quot;%u! = %lu\n&quot;</span>, n, factorial(n));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="afile__converter_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="file__converter_8cpp_source.html#l00041">file_converter.cpp:41</a></div></div>
<div class="ttc" id="astdio_8c_html_a98631211a4a8aee62f572375d5b637be"><div class="ttname"><a href="stdio_8c.html#a98631211a4a8aee62f572375d5b637be">printf</a></div><div class="ttdeci">int printf(const char *format,...)</div><div class="ttdef"><b>Definition:</b> <a href="stdio_8c_source.html#l01376">stdio.c:1376</a></div></div>
<div class="ttc" id="astdlib_8c_html_ad228deceea1bac4d9f171f647c265059"><div class="ttname"><a href="stdlib_8c.html#ad228deceea1bac4d9f171f647c265059">atoi</a></div><div class="ttdeci">int atoi(const char *nptr)</div><div class="ttdef"><b>Definition:</b> <a href="stdlib_8c_source.html#l00465">stdlib.c:465</a></div></div>
</div><!-- fragment --><p>The question of this first section is: how do we represent this program in memory so that we can do something useful with it?</p>
<p>One possibility would be to just store the program as a string, but this is clearly impractical: even finding whether there is an assignment to a specific variable would require significant parsing effort. For this reason, the first step is to parse the program text into a more abstract representation.</p>
<h2><a class="anchor" id="AST_section"></a>
AST</h2>
<p>The first step in representing a program in memory is to parse the program, at the same time checking for syntax errors, and store the parsing result in memory.</p>
<p>The key data structure that stores the result of this step is known as an <b>Abstract Syntax Tree</b>, or <b>AST</b> for short (cf. <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Wikipedia</a>). ASTs are still relatively close to the source code, and represent the structure of the source code while abstracting away from syntactic details, e.g., dropping parentheses, semicolons and braces as long as those are only used for grouping.</p>
<p>Considering the example of the C program given above, we first notice that the program describes (in C terms) a single <em>translation unit</em>, consisting of four top-level <em>declarations</em> (the two function forward declarations of <code>atoi</code> and <code>printf</code>, and the function definitions of <code>factorial</code> and <code>main</code>). Let us start considering the specification of <code>atoi</code>. This gives rise to a subtree modeling that we have a function called <code>atoi</code> whose return type is <code>int</code>, with an unnamed argument of type <code>const char *</code>. We can represent this using a tree that has, for instance, the following structure (this is a simplified version of the tree that the CPROVER framework uses internally):</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_1.svg" width="206" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
AST for the `atoi` declaration</div>
</div>
<p>This graph shows the (simplified) AST structure for the <code>atoi</code> function. The top level says that this is a global entity, namely one that has code (i.e., a function), called <code>atoi</code> and yielding <code>int</code>. Furthermore, it has a child node initiating a parameter list, and there is a node in the parameter list for each parameter, giving its type and name, if a name is given.</p>
<p>Extending this idea, we can represent the structure of the <code>factorial</code> function using ASTs. The idea here is that the code itself has a hierarchical structure. In the case of C, this starts with the block structure of the code: at the top, we start with a block of code, having three children, each being a ''statement'' node:</p><ol type="1">
<li><code>unsigned long fac = 1</code></li>
<li><code>for (unsigned int i = 1; i &lt;= n; i++) { fac *= i }</code></li>
<li><code>return fac</code></li>
</ol>
<p>The first statement is already a basic statement: we represent it as a local declaration (similar to the global declarations above) of a variable.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="255" height="122"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
AST for `unsigned long fac = 1`</div>
</div>
<p>The second statement is a compound statement, which we can decompose further. At the top level, we have a node stating that this is a <code>for</code> statement, with four child nodes:</p><ol type="1">
<li>Another declaration node, declaring variable <code>i</code>.</li>
<li>An expression node, with operator <code>&lt;=</code> and two children giving the LHS as variable <code>i</code> and the RHS as variable <code>n</code>.</li>
<li>An expression node with post-fix operator <code>++</code> and a child giving the variable <code>i</code> as argument.</li>
<li>A block node, starting a new code block. This node has one child:<ol type="a">
<li>An expression node with top-level operator <code>*=</code> and two child nodes giving the LHS as variable <code>fac</code> and the RHS as variable <code>i</code>. All in all, the AST for this piece of code looks like this:</li>
</ol>
</li>
</ol>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="1114" height="415"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
AST for the `for` loop</div>
</div>
<p>Finally, the third statement is again simple: it consists of a return statement node, with a child node for the variable expression <code>fac</code>. Since the AST is very similar to the first AST above, we omit it here. All in all, the AST for the function body looks like this:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="1236" height="574"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
AST for the body of `factorial`</div>
</div>
<p>Using the AST for the function body, we can easily produce the definition of the <code>factorial</code> function:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_5.svg" width="1236" height="692"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
AST for `factorial` (full definition)</div>
</div>
<p>In the end, we produce a sequence of trees modeling each declaration in the translation unit (i.e., the file <code>factorial.c</code>).</p>
<p>This data structure is already useful: at this level, we can easily derive simple information such as ''which functions are being defined?'', ''what are the arguments to a given function'' and so on.</p>
<h3><a class="anchor" id="symbol_table_section"></a>
Symbol tables and variable disambiguation</h3>
<p>Nevertheless, for many analyses, this representation needs to be transformed further. In general, the first step is to <b>resolve variable names</b>. This is done using an auxiliary data structure known as the <b>symbol table</b>.</p>
<p>The issue that this step addresses is that the meaning of a variable name depends on a given <em>scope</em> - for instance, in a C program, we can define the variable <code>i</code> as a local variable in two different functions, so that the name <code>i</code> refers to two different objects, depending on which function is being executed at a given point in time.</p>
<p>To resolve this problem, a first transformation step is performed, changing (short) variable names to some form of unique identifier. This ensures that each variable identifier is used only once, and all accesses to a given variable can be easily found by just looking for the variable identifier. For instance, we could change each variable name into a pair of the name and a serial number. The serial number gets increased whenever a variable of that name is declared. In the example, the ASTs for <code>factorial</code> and <code>main</code> after resolving variable names would look roughly like this:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_6.svg" width="2783" height="788"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
ASTs with resolved variables</div>
</div>
<p>Note that the parameter <code>n</code> in <code>factorial</code> and the local variable <code>n</code> in <code>main</code> are now disambiguated as <code>n.1</code> and <code>n.2</code>; furthermore, we leave the names of global objects as-is. In the CPROVER framework, a more elaborate system is used: local variables are prefixed with the function names, and further disambiguation is performed by adding indices. For brevity, we use indices only.</p>
<p>Further information on ASTs can be found in the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Wikipedia page</a> and the materials linked there. Additionally, there is an <a href="https://stackoverflow.com/questions/1888854/what-is-the-difference-between-an-abstract-syntax-tree-and-a-concrete-syntax-tree">interesting discussion on StackOverflow</a> about abstract versus concrete syntax trees.</p>
<p>At this level, we can already perform a number of interesting analyses, such as basic type checking. But for more advanced analyses, other representations are better: the AST contains many different kinds of nodes (essentially, one per type of program construct), and has a rather intricate structure.</p>
<h2><a class="anchor" id="IR_section"></a>
Intermediate Representations (IR)</h2>
<p>The ASTs in the previous section represent the syntax of a program, including all the features of a given programming language. But in practice, most programming languages have a large amount of ''syntactic sugar'': constructs that are, technically speaking, redundant, but make programming a lot easier. For analysis, this means that if we immediately try to work on the initial AST, we would have to handle all these various cases.</p>
<p>To simplify analysis, it pays off to bring the AST into simpler forms, known as <b>intermediate representations</b> (short <b>IR</b>). An IR is usually given as some form of AST, using a more restricted subset or a variant of the original language that is easier to analyze than the original version.</p>
<p>Taking the example from above, we rewrite the program into a simpler form of the C language: instead of allowing powerful control constructs such as <code>while</code> and <code>for</code>, we reduce everything to <code>if</code> and <code>goto</code>. In fact, we even restrict <code>if</code> statements: an <code>if</code> statement should always be of the form <code>if (*condition*) goto *target* else goto *target*;</code>. As it turns out, this is sufficient to represent every C program. The factorial function in our example program can then be rewritten as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> factorial(<span class="keywordtype">unsigned</span> n) {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac = 1;</div>
<div class="line">  <span class="comment">// Replace the for loop with if and goto</span></div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;</div>
<div class="line">for_loop_start:</div>
<div class="line">  <span class="keywordflow">if</span> (i &lt;= n) <span class="keywordflow">goto</span> for_loop_entry <span class="keywordflow">else</span> <span class="keywordflow">goto</span> for_loop_end;</div>
<div class="line">for_loop_entry:</div>
<div class="line">    fac *= i;</div>
<div class="line">    i++;</div>
<div class="line">    <span class="keywordflow">goto</span> for_loop_start;</div>
<div class="line">for_loop_end:</div>
<div class="line">  <span class="keywordflow">return</span> fac;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We leave it up to the reader to verify that both versions of the function behave the same way, and to draw the function as an AST.</p>
<p>In the CPROVER framework, a number of different IRs are employed to simplify the program under analysis into a simple core language step-by-step. In particular, expressions are brought into much simpler forms. This sequence of transformations is described in later chapters.</p>
<p>TODO: Link to corresponding sections.</p>
<h2><a class="anchor" id="CFG_section"></a>
Control Flow Graphs (CFG)</h2>
<p>Another important representation of a program can be gained by transforming the program structure into a <a href="https://en.wikipedia.org/wiki/Control_flow_graph"><b>control flow graph</b></a>, short <b>CFG</b>. While the AST focuses more on the syntactic structure of the program, keeping constructs like while loops and similar forms of structured control flow, the CFG uses a unified graph representation for control flow.</p>
<p>In general, for analyses based around Abstract Interpretation (see <a class="el" href="background-concepts.html#abstract_interpretation_section">Abstract Interpretation</a>), it is usually preferable to use a CFG representation, while other analyses, such as variable scope detection, may be easier to perform on ASTs.</p>
<p>The general idea is to present the program as a graph. The nodes of the graph are instructions or sequences of instructions. In general, the nodes are <b>basic blocks</b>: a basic block is a sequence of statements that is always executed in order from beginning to end. The edges of the graph describe how the program execution may move from one basic block to the next. Note that single statements are always basic blocks; this is the representation used inside the CPROVER framework. In the examples below, we try to use maximal basic blocks (i.e., basic blocks that are as large as possible); this can be advantageous for some analyses.</p>
<p>Let us consider the factorial function as an example. As a reminder, here is the code, in IR: </p><div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac = 1;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;</div>
<div class="line">for_loop_start:</div>
<div class="line">  <span class="keywordflow">if</span> (i &lt;= n) <span class="keywordflow">goto</span> for_loop_entry <span class="keywordflow">else</span> <span class="keywordflow">goto</span> for_loop_end;</div>
<div class="line">for_loop_entry:</div>
<div class="line">    fac *= i;</div>
<div class="line">    i++;</div>
<div class="line">    <span class="keywordflow">goto</span> for_loop_start;</div>
<div class="line">for_loop_end:</div>
<div class="line">  <span class="keywordflow">return</span> fac;</div>
</div><!-- fragment --><p>We rewrite the code with disambiguated variables (building the AST from it is left as an exercise): </p><div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac.1 = 1;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i.1 = 1;</div>
<div class="line">for_loop_start:</div>
<div class="line">  <span class="keywordflow">if</span> (i.1 &lt;= n.1) <span class="keywordflow">goto</span> for_loop_entry <span class="keywordflow">else</span> <span class="keywordflow">goto</span> for_loop_end;</div>
<div class="line">for_loop_entry:</div>
<div class="line">    fac.1 *= i.1;</div>
<div class="line">    i.1++;</div>
<div class="line">    <span class="keywordflow">goto</span> for_loop_start;</div>
<div class="line">for_loop_end:</div>
<div class="line">  <span class="keywordflow">return</span> fac.1;</div>
</div><!-- fragment --><p>This function consists of four basic blocks:</p><ol type="1">
<li><code>unsigned long fac.1 = 1;</code> <code>unsigned int i.1 = 1;</code></li>
<li><code>if (i.1 &lt;= n.1) goto for_loop_entry else goto for_loop_end</code> (this block has a label, <code>for_loop_start</code>).</li>
<li><code>fac.1 *= i.1</code><br  />
 <code>i.1 ++</code> <code>goto for_loop_start</code> (this block has a label, <code>for_loop_entry</code>).</li>
<li><code>return fac.1</code> (this block has a label, <code>for_loop_end</code>).</li>
</ol>
<p>One way to understand which functions form basic blocks is to consider the successors of each instruction. If we have two instructions A and B, we say that B is a <em>successor</em> of A if, after executing A, we can execute B without any intervening instructions. For instance, in the example above, the loop initialization statement <code>unsigned int i.1 = 1</code> is a successor of <code>unsigned long fac.1 = 1</code>. On the other hand, <code>return fac.1</code> is not a successor of <code>unsigned long fac.1 = 1</code>: we always have to execute some other intermediate statements to reach the return statement.</p>
<p>Now, consider the <code>if</code> statement, <code>if (i.1 &lt;= n.1) goto for_loop_entry else goto for_loop_end</code>. This statement has <em>two</em> successors: <code>fac.1 *= i.1</code> and <code>return fac.1</code>.</p>
<p>Similarly, we say that A is a <em>predecessor</em> of B if B is a successor of A. We find that the <code>if</code> statement has two predecessors, <code>unsigned int i.1 = 1</code> and <code>goto for_loop_start</code>.</p>
<p>A basic block is a sequence of instructions with the following property:</p><ol type="1">
<li>If B comes directly after A in the sequence, B must be the sole successor of A.</li>
<li>If A comes directly before B in the sequence, A must be the sole predecessor of B.</li>
</ol>
<p>In particular, each member of the sequence but the first must have exactly one predecessor, and each member of the sequence but the last must have exactly one successor. These criteria explain why we have the basic blocks described above.</p>
<p>Putting everything together, we get a control flow graph like this:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_7.svg" width="455" height="288"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
Control flow graph for factorial</div>
</div>
<p>The graph can be read as follows: each node corresponds to a basic block. The initial basic block (where the function is entered) is marked with a double border, while those basic blocks that leave the function have a gray background. An edge from a basic block B to a basic block B', means that if the execution reaches the end of B, execution may continue in B'. Some edges are labeled: the edge leaving the comparison basic block with the label <code>true</code>, for instance, can only be taken if the comparison did, in fact, return <code>true</code>.</p>
<p>Note that this representation makes it very easy to interpret the program, keeping just two pieces of state: the current position (which basic block and which line), and the values of all variables (in real software, this would also include parts of the heap and the call stack). Execution proceeds as follows: as long as there are still instructions to execute in the current basic block, run the next instruction and move the current position to right after that instruction. At the end of a basic block, take one of the available outgoing edges to another basic block.</p>
<p>In the CPROVER framework, we often do not construct CFGs explicitly, but instead use an IR that is constructed in a way very similar to CFGs, known as ''GOTO programs''. This IR is used to implement a number of static analyses, as described in sections <a class="el" href="group__analyses.html#analyses-frameworks">Frameworks:</a> and <a class="el" href="group__analyses.html#analyses-specific-analyses">Specific analyses:</a>.</p>
<h2><a class="anchor" id="SSA_section"></a>
SSA</h2>
<p>While control flow graphs are already quite useful for static analysis, some techniques benefit from a further transformation to a representation known as <b>static single assignment</b>, short <b>SSA</b>. The point of this step is to ensure that we can talk about the entire history of assignments to a given variable. This is achieved by renaming variables again: whenever we assign to a variable, we <em>clone</em> this variable by giving it a new name. This ensures that each variable appearing in the resulting program is written to exactly once (but it may be read arbitrarily many times). In this way, we can refer to earlier values of the variable by just referencing the name of an older incarnation of the variable.</p>
<p>We illustrate this transformation by first showing how the body of the <code>for</code> loop of <code>factorial</code> is transformed. We currently have:</p>
<div class="fragment"><div class="line">expression: fac.1 *= i.1</div>
<div class="line">expression: i.1 ++</div>
</div><!-- fragment --><p>We now give a second number to each variable, counting the number of assignments so far. Thus, the SSA version of this code turns out to be </p><div class="fragment"><div class="line">expression: fac.1.2 = fac1.1 * i.1.1</div>
<div class="line">expression: i.1.2 = i.1.1 + 1</div>
</div><!-- fragment --><p> This representation now allows us to state facts such as ''<code>i</code> is increasing'' by writing <code>i.1.1 &lt; i.1.2</code>.</p>
<p>At this point, we run into a complication. Consider the following piece of code for illustration: </p><div class="fragment"><div class="line"><span class="comment">// Given some integers a, b</span></div>
<div class="line"><span class="keywordtype">int</span> x = a;</div>
<div class="line"><span class="keywordflow">if</span> (a &lt; b)</div>
<div class="line">  x = b;</div>
<div class="line"><span class="keywordflow">return</span> x;</div>
</div><!-- fragment --><p> The corresponding control flow graph looks like this:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_8.svg" width="163" height="295"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
CFG for maximum function</div>
</div>
<p>When we try to transform to SSA, we get: </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_9.svg" width="176" height="296"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
CFG for maximum function - SSA, attempt</div>
</div>
<p> Depending on which path the execution takes, we have to return either <code>x.1</code> or <code>x.2</code>! The way to make this work is to introduce a function &Phi; that selects the right instance of the variable; in the example, we would have </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_10.svg" width="195" height="296"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
CFG for maximum function - SSA using &Phi;</div>
</div>
<p>In the CPROVER framework, we provide a precise implementation of &Phi;, using explicitly tracked information about which branches were taken by the program. There are also some differences in how loops are handled (finite unrolling in CPROVER, versus a &Phi;-based approach in compilers); this approach will be discussed in a later chapter.</p>
<p>For the time being, let us come back to <code>factorial</code>. We can now give an SSA using &Phi; functions:</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_11.svg" width="435" height="311"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
Control flow graph in SSA for factorial</div>
</div>
<p>The details of SSA construction, plus some discussion of how it is used in compilers, can be found in the <a href="https://dl.acm.org/citation.cfm?doid=115372.115320">original paper</a>.</p>
<p>The SSA is an extremely helpful representation when one wishes to perform model checking on the program (see next section), since it is much easier to extract the logic formulas used in this technique from an SSA compared to a CFG (or, even worse, an AST). That being said, the CPROVER framework takes a different route, opting to convert to intermediate representation known as GOTO programs instead.</p>
<h2><a class="anchor" id="field_sensitivity_section"></a>
Field Sensitivity</h2>
<p><a class="el" href="classfield__sensitivityt.html">Field sensitivity</a> is a transformation of the instructions goto-program which mainly replaces some expressions by symbols but can also add assignments to the target equations produced by symbolic execution. The main goal of this transformation is to allow more constants to be propagated during symbolic execution. Note that field sensitivity is not applied as a single pass over the whole goto program but instead applied as the symbolic execution unfolds.</p>
<p>On a high level, field sensitivity replaces member operators, and array accesses with atomic symbols representing a field when possible. In cases where this is not immediately possible, like struct assignments, some things need to be added. The possible cases are described below.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
Member access</h3>
<p>A member expression <code>struct_expr.field_name</code> is replaced by the symbol <code>struct_expr..field_name</code>; note the use of <code>..</code> to visually distinguish the symbol from the member expression. This is valid for both lvalues and rvalues. See <a class="el" href="classfield__sensitivityt.html#ab8283bec88669c814dcc228231a2fbc6">field_sensitivityt::apply</a>.</p>
<h3><a class="anchor" id="autotoc_md132"></a>
Symbols representing structs</h3>
<p>In an rvalue, a symbol struct_expr which has a struct type with fields field1, field2, etc, will be replaced by <code>{struct_expr..field_name1; struct_expr..field_name2; …}</code>. See <a class="el" href="classfield__sensitivityt.html#ab0336ba44961097ebccc95cc4bdbd086">field_sensitivityt::get_fields</a>.</p>
<h3><a class="anchor" id="autotoc_md133"></a>
Assignment to a struct</h3>
<p>When the symbol is on the left-hand-side, for instance for an assignment <code>struct_expr = other_struct</code>, the assignment is replaced by a sequence of assignments: <code>struct_expr..field_name1 = other_struct..field_name1;</code> <code>struct_expr..field_name2 = other_struct..field_name2;</code> etc. See <a class="el" href="classfield__sensitivityt.html#acb85cf6b9db2203521e695cc227d1435">field_sensitivityt::field_assignments</a>.</p>
<h3><a class="anchor" id="autotoc_md134"></a>
Array access</h3>
<p>An index expression <code>array[index]</code> when index is constant and array has constant size is replaced by the symbol <code>array[[index]]</code>; note the use of <code>[[</code> and <code>]]</code> to visually distinguish the symbol from the index expression. When <code>index</code> is not a constant, <code>array[index]</code> is replaced by <code>{array[[0]]; array[[1]]; …index]</code>. Note that this process does not apply to arrays whose size is not constant, and arrays whose size exceed the bound <code>max_field_sensitivity_array_size</code>. See <a class="el" href="classfield__sensitivityt.html#ab8283bec88669c814dcc228231a2fbc6">field_sensitivityt::apply</a>.</p>
<h3><a class="anchor" id="autotoc_md135"></a>
Symbols representing arrays</h3>
<p>In an rvalue, a symbol <code>array</code> which has array type will be replaced by <code>{array[[0]]; array[[1]]; …}[index]</code>. See <a class="el" href="classfield__sensitivityt.html#ab0336ba44961097ebccc95cc4bdbd086">field_sensitivityt::get_fields</a>.</p>
<h3><a class="anchor" id="autotoc_md136"></a>
Assignment to an array</h3>
<p>When the array symbol is on the left-hand-side, for instance for an assignment <code>array = other_array</code>, the assignment is replaced by a sequence of assignments: <code>array[[0]] = other_array[[0]]</code>; <code>array[[1]] = other_array[[1]]</code>; etc. See <a class="el" href="classfield__sensitivityt.html#acb85cf6b9db2203521e695cc227d1435">field_sensitivityt::field_assignments</a>.</p>
<h1><a class="anchor" id="analysis_techniques_section"></a>
Analysis techniques</h1>
<h2><a class="anchor" id="BMC_section"></a>
Bounded model checking</h2>
<p>One of the most important analysis techniques by the CPROVER framework, implemented using the CBMC (and JBMC) tools, is <b>bounded model checking</b>, a specific instance of a method known as <a href="https://en.wikipedia.org/wiki/Model_checking">Model Checking</a>.</p>
<p>The basic question that model checking tries to answer is: given some system (in our case, a program) and some property, can we find an execution of the system such that it reaches a state where the property holds? If yes, we would like to know how the program reaches this state - at the very least, we want to see what inputs are required, but in general, we would prefer having a <b>trace</b>, which shows what statements are executed and in which order.</p>
<p>In general, a trace describes which statements of the program were executed, and which intermediate states were reached. Often, it is sufficient to only provide part of the intermediate states (omitting some entirely, and only mentioning parts that cannot be easily reconstructed in others).</p>
<p>As it turns out, model checking for programs is, in general, a hard problem. Part of the reason for this is that many model checking algorithms strive for a form of ''completeness'' where they either find a trace or return a proof that such a trace cannot possibly exist.</p>
<p>Since we are interested in generating test cases, we prefer a different approach: it may be that a certain target state is reachable only after a very long execution, or not at all, but this information does not help us in constructing test cases. For this reason, we introduce an <b>execution bound</b> that describes how deep we go when analyzing a program.</p>
<p>Model checking techniques using such execution bounds are known as <b>bounded model checking</b>; they will return either a trace, or a statement that says ''the target state could not be reached in n steps'', for a given bound n. Thus, for a given bound, we always get an <b>underapproximation</b> of all states that can be reached: we can certainly find those reachable within the given bound, but we may miss states that can be reached only with more steps. Conversely, we will never claim that a state is not reachable within a certain bound if there is, in fact, a way of reaching this state.</p>
<p>The bounded model checking techniques used by the CPROVER framework are based on <em>symbolic model checking</em>, a family of model checking techniques that work on sets of program states and use advanced tools such as SAT solvers (more on that below) to calculate the set of reachable states. The key step here is to encode both the program and the set of states using an appropriate logic, mostly <em>propositional logic</em> and (fragments of) <em>first-order logic</em>.</p>
<p>In the following, we will quickly discuss propositional logic, in combination with SAT solving, and show how to build a simple bounded model checker. Actual bounded model checking for software requires a number of additional steps and concepts, which will be introduced as required later on.</p>
<h3><a class="anchor" id="propositional_logic_subsubsection"></a>
Propositional logic and SAT solving</h3>
<p>Many of the concepts in this section can be found in more detail in the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Propositional_calculus">Propositional logic</a>.</p>
<p>Let us start by looking at <b>propositional formulas</b>. A propositional formula consists of <b>propositional variables</b>, say <em>x</em>, <em>y</em> and <em>z</em>, that can take the Boolean values <b>true</b> and <b>false</b>, connected together with logical operators (often called <em>junctors</em>), namely <em>and</em>, <em>or</em> and <em>not</em>. Sometimes, one introduces additional junctors, such as <em>xor</em> or <em>implies</em>, but these can be defined in terms of the three basic junctors just described.</p>
<p>Examples of propositional formulas would be ''<em>x</em> and <em>y</em>'' or ''not <em>x</em> or <em>y</em> or <em>z</em>''. We can <b>evaluate</b> formulas by setting each variable to a Boolean value and reducing using the follows rules:</p><ul>
<li><em>x</em> and <b>false</b> = <b>false</b> and <em>x</em> = <b>false</b> or <b>false</b> = not <b>true</b> = <b>false</b></li>
<li><em>x</em> or <b>true</b> = <b>true</b> or <em>x</em> = <b>true</b> and <b>true</b> = not <b>false</b> = <b>true</b></li>
</ul>
<p>An important related question is: given a propositional formula, is there a variable assignment that makes it evaluate to true? This is known as the <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem"><b>SAT problem</b></a>. The most important things to know about SAT are:</p><ol type="1">
<li>It forms the basis for bounded model checking algorithms;</li>
<li>It is a very hard problem to solve in general: it is NP-complete, meaning that it is easy to check a solution, but (as far as we know) hard to find one;</li>
<li>There has been impressive research in <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT"><b>SAT solvers</b></a> that work well in practice for the kinds of formulas that we encounter in model checking. A commonly-used SAT solver is <a href="http://minisat.se">minisat</a>.</li>
<li>SAT solvers use a specific input format for propositional formulas, known as the <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form"><b>conjunctive normal form</b></a>. For details, see the linked Wikipedia page; roughly, a conjunctive normal form formula is a propositional formula with a specific shape: at the lowest level are <em>atoms</em>, which are propositional variables ''<em>x</em>'' and negated propositional variables ''not <em>x</em>''; the next layer above are <em>clauses</em>, which are sequences of atoms connected with ''or'', e.g. ''not <em>x</em> or <em>y</em> or <em>z</em>''. The top layer consists sequences of clauses, connected with ''and''.</li>
</ol>
<p>As an example in how to use a SAT solver, consider the following formula (in conjunctive normal form):</p>
<p>''(<em>x</em> or <em>y</em>) and (<em>x</em> or not <em>y</em>) and <em>x</em> and <em>y</em>''</p>
<p>We can represent this formula in the minisat input format as:</p>
<div class="fragment"><div class="line">p cnf 2 3</div>
<div class="line">1 2 0</div>
<div class="line">1 -2 0</div>
<div class="line">1 0</div>
<div class="line">2 0</div>
</div><!-- fragment --><p> Compare the <a href="https://www.dwheeler.com/essays/minisat-user-guide.html">Minisat user guide</a>. Try to run minisat on this example. What would you expect, and what result do you get?</p>
<p>Next, try running minisat on the following formula: ''(<em>x</em> or <em>y</em>) and (<em>x</em> or not <em>y</em>) and (not <em>x</em>) and <em>y</em>'' What changed? Why?</p>
<h3><a class="anchor" id="bitvector_subsubsection"></a>
Using SAT to reason about data: Bit vectors</h3>
<p>So far, we have seen how to reason about simple propositional formulas. This seems to be quite far from our goal of reasoning about the behavior of programs. As a first step, let us see how we can lift SAT-based reasoning to reasoning about data such as machine integers.</p>
<p>Remember the <code>factorial</code> function. It starts with the line </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac = 1;</div>
</div><!-- fragment --><p> Now, suppose that <code>fac</code> will be represented as a binary number with 64 bits (this is standard on, e.g., Linux). So, if we wish to reason about the contents of the variable <code>fac</code>, we might as well represent it as a vector of 64 propositional variables, say <code>fac</code><sub>0</sub> to <code>fac</code><sub>63</sub>, where <code>fac</code> = 2<sup>63</sup> <code>fac</code><sub>63</sub> + ... + 2<sup>0</sup> <code>fac</code><sub>0</sub>. We can then assert that <code>fac</code>=1 using the propositional formula <code>fac</code><sub>63</sub> = 0 and ... and <code>fac</code><sub>1</sub> = 0 and <code>fac</code><sub>0</sub> = 1, where we define the formula A = B as ''(A or not B) and (B or not A)''.</p>
<p>We call this a <em>bit vector</em> representation. Compare the Wikipedia page on <a href="https://en.wikipedia.org/wiki/Binary_number">Binary numbers</a>.</p>
<p>Bit vector representations can also be used to describe operations on binary numbers. For instance, suppose we have two four-bit numbers A_3, ... A_0 (representing a number A) and B_3, ..., B_0 (representing a number b) and wish to add them. As detailed on the page on <a href="https://en.wikipedia.org/wiki/Adder_(electronics)">Binary adders</a>, we define three additional bit vectors, the <em>carries</em> C<sub>0</sub>, ..., C<sub>3</sub>, the <em>partial sum</em> P<sub>0</sub>, ..., P<sub>4</sub> and the <em>sum</em> S<sub>0</sub>, ..., S<sub>4</sub> , representing a number S such that S=A+B. Note that the sum vector has one bit more - why? How is this related to arithmetic overflow in C?</p>
<p>For convenience, we first define the <em>half-adder</em>. This is given as two formulas, HA_S(A,B) = (A and not B) or (B and not A), which gives the sum of the bits A and B, and HA_C(A,B) = A and B, which indicates whether the result of the sum was too big to fit into one bit (so we carry a one to the next bit).</p>
<p>Using the half-adder formulas, we can define the <em>full adder</em>, again given as two formulas, one for sum and the other for carry. We have FA_S(A,B,C_in) = HA(HA(A,B),C_in), giving the sum of A, B and C_in, and FA_C(A,B,C_in) = HA_C(A,B) or (C_in and HA_S(A,B)), which states whether the result is too big to fit into a bit. Note that the full adder has an additional input for carries; in the following step, we will use it to chain the full adders together to compute the actual sum.</p>
<p>Using the helper variables we have above, we can give the sum of the four-bit numbers as </p><blockquote class="doxtable">
<p>C_0 = FA_C(A_0,B_0,0) and C_1 = FA_C(A_1,B_1,C_0) and C_2 = FA_C(A_2,B_2,C_1) and C_3 = FA_C(A_3,B_3,C_2) and S_0 = FA_S(A_0,B_0,0) and S_1 = FA_S(A_1,B_1,C_0) and and S_2 = FA_S(A_2,B_2,C_1) and S_3 = FA_S(A_3,B_3,C_2) and S_3 = FA_S(0,0,C_3). </p>
</blockquote>
<p>Other arithmetic operations on binary numbers can be expressed using propositional logic as well; the details can be found in the linked articles, as well as <a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two's complement</a> for handling signed integers and <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a> for floating point numbers.</p>
<p>In the following, we will simply write formulas such as S=A+B, with the understanding that this is internally represented using the appropriate bit vectors.</p>
<h3><a class="anchor" id="bmc_subsubsection"></a>
How bounded model checking works</h3>
<p>At this point, we can start considering how to express program behavior in propositional logic.</p>
<p>Let us start with a very simple program: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> sum(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">}</div>
</div><!-- fragment --><p> To describe the behavior of this program, we introduce the appropriately-sized bit vectors A and B, and an additional helper vector return. The A and B bit vectors reflect the values of the parameters <code>a</code> and <code>b</code>, while return contains the return value of the function. As we have seen above, we can describe the value of <code>a+b</code> as A+B &ndash; remember that this is an abbreviation for a moderately complex formula on bit vectors!</p>
<p>From the semantics of the <code>return</code> instruction, we know that this program will return the value <code>a+b</code>, so we can describe its behavior as return = A+B.</p>
<p>Let us consider a slightly more complex program. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> calculate(<span class="keywordtype">int</span> x)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> y = x * x;</div>
<div class="line">  y = y + x;</div>
<div class="line">  <span class="keywordflow">return</span> y;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We again introduce several bit vectors. For the parameter <code>x</code>, we introduce a bit vector X, and for the return value, return. But we also have to deal with the (local) variable <code>y</code>, which gets two assignments. Furthermore, we now have a program with three instructions.</p>
<p>Thinking about the approach so far, we find that we cannot directly translate <code>y=y+x</code> into a propositional formula: On the left-hand side of the <code>=</code>, we have the ''new'' value of <code>y</code>, while the right-hand side uses the ''old'' value. But propositional formulas do not distinguish between ''old'' and ''new'' values, so we need to find a way to distinguish between the two. The easiest solution is to use the Static Single Assignment form described in section <a class="el" href="background-concepts.html#SSA_section">SSA</a>. We transform the program into SSA (slightly simplifying the notation): </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> calculate(<span class="keywordtype">int</span> x.1)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> y.1 = x.1 * x.1;</div>
<div class="line">  y.2 = y.1 + x.1;</div>
<div class="line">  <span class="keywordflow">return</span> y.2;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In this form, we know that each variable is assigned to at most once. To capture the behavior of this program, we translate it statement-by-statement into a propositional formula. We introduce two bit vectors Y1 and Y2 to stand for <code>y.1</code> and <code>y.2</code> (we map X to <code>x.1</code> and return to the return value). <code>int y.1 = x.1 * x.1</code> becomes Y1 = X * X, <code>y.2 = y.1 + x.1</code> becomes Y2 = Y1 + X and <code>return y.2</code> becomes return = Y2.</p>
<p>To tie the three formulas together into a description of the whole program, we note that the three instructions form a single basic block, so we know they are always executed as a unit. In this case, it is sufficient to simply connect them with ''and'': Y1 = X * X and Y2 = Y1 + X and return = Y2. Note that thanks to SSA, we do not need to pay attention to control flow here.</p>
<p>One example of non-trivial control flow are <code>if</code> statements. Consider the following example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> max(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  <span class="keywordflow">if</span> (a &lt; b)</div>
<div class="line">    result = b;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result = a;</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Bringing this into SSA form, we have the following program (we write <code>Phi</code> for &Phi;): </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> max(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  <span class="keywordflow">if</span> (a &lt; b)</div>
<div class="line">    result.1 = b;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result.2 = a;</div>
<div class="line">  <span class="keywordflow">return</span> Phi(result.1,result.2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> We again introduce bit vectors A (for parameter <code>a</code>), B (for parameters <code>b</code>), R1 (for <code>result.1</code>), R2 (for <code>result.2</code>) and return (for the return value). The interesting question in this case is how we can handle the &Phi; node: so far, it is a ''magic'' operator that selects the correct value.</p>
<p>As a first step, we modify the SSA form slightly by introducing an additional propositional variable C that tracks which branch of the <code>if</code> was taken. We call this variable the <em>code guard variable</em>, or <em>guard</em> for short. Additionally, we add C to the &Phi; node as a new first parameter, describing which input to use as a result. The corresponding program looks something like this: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> max(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  bit C; <span class="comment">/* Track which branch was taken */</span></div>
<div class="line">  C = a &lt; b;</div>
<div class="line">  <span class="comment">/* if (C) - not needed anymore thanks to SSA */</span></div>
<div class="line">    result.1 = b;</div>
<div class="line">  <span class="comment">/* else */</span></div>
<div class="line">    result.2 = a;</div>
<div class="line">  <span class="keywordflow">return</span> Phi(C,result.1,result.2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> For the encoding of the program, we introduce the implication junctor, written &rArr;, where ''A &rArr; B'' is equivalent to ''(not A) or B''. It can be understood as ''if A holds, B must hold as well''.</p>
<p>With these ingredients, we can encode the program. First of all, we translate the basic statements of the program:</p><ul>
<li><code>C = a&lt;b</code> maps to C = A&lt;B, for an appropriate formula A&lt;B.</li>
<li><code>result.1 = b</code> becomes R1 = B, and <code>result.2 = a</code> becomes R2 = A.</li>
</ul>
<p>Finally, the &Phi; node is again resolved using the &rArr; junctor: we can encode the <code>return</code> statement as (C &rArr; return = R1) and ((not C) &rArr; return = R2).</p>
<p>At this point, it remains to tie the statements together; we find that we can again simply connect them with ''and''. We get: </p><blockquote class="doxtable">
<p>C = a&lt;b and R1 = B and R2 = A and (C &rArr; return = R1) and ((not C) &rArr; return = R2). </p>
</blockquote>
<p>So far, we have only discussed how to encode the behavior of programs as propositional formulas. To actually reason about programs, we also need to a way to describe the property we want to prove. To do this, we introduce a primitive <code>ASSERT</code>. Let <code>e</code> be some expression; then <code>ASSERT(e)</code> is supposed to do nothing if <code>e</code> evaluates to true, and to abort the program if <code>e</code> evaluates to false.</p>
<p>For instance, we can add prove that <code>max(a,b) &lt;= a</code> by modifying the <code>max</code> function into </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> max(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  <span class="keywordflow">if</span> (a &lt; b)</div>
<div class="line">    result = b;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    result = a;</div>
<div class="line">  <a class="code" href="goto__program_8h.html#a9e03d66cd12c59d9d3daad1ec6296beba61d9e0e93eb9635173764c5ba45666f1">ASSERT</a>(result &lt;= a);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="agoto__program_8h_html_a9e03d66cd12c59d9d3daad1ec6296beba61d9e0e93eb9635173764c5ba45666f1"><div class="ttname"><a href="goto__program_8h.html#a9e03d66cd12c59d9d3daad1ec6296beba61d9e0e93eb9635173764c5ba45666f1">ASSERT</a></div><div class="ttdeci">@ ASSERT</div><div class="ttdef"><b>Definition:</b> <a href="goto__program_8h_source.html#l00036">goto_program.h:36</a></div></div>
</div><!-- fragment --><p>The corresponding SSA would be </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> max(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  bit C; <span class="comment">/* Track which branch was taken */</span></div>
<div class="line">  C = a &lt; b;</div>
<div class="line">  result.1 = b;</div>
<div class="line">  result.2 = a;</div>
<div class="line">  <a class="code" href="goto__program_8h.html#a9e03d66cd12c59d9d3daad1ec6296beba61d9e0e93eb9635173764c5ba45666f1">ASSERT</a>(Phi(C,result.1,result.2) &lt;= a);</div>
<div class="line">  <span class="keywordflow">return</span> Phi(C,result.1,result.2);</div>
<div class="line">}</div>
</div><!-- fragment --><p> We translate <code>ASSERT(Phi(C,result.1,result.2) &lt;= a)</code> into </p><blockquote class="doxtable">
<p>&Phi;(C,result.1,result.2) &lt;= a </p>
</blockquote>
<p>The resulting formula would be </p><blockquote class="doxtable">
<p>C = a&lt;b and R1 = B and R2 = A and (C &rArr; R1 &lt;= A) and ((not C) &rArr; R2 &lt;= A). (C &rArr; return = R1) and ((not C) &rArr; return = R2). </p>
</blockquote>
<p>We can extend this approach quite straightforwardly to other constructs, but one obvious problem remains: We have not described how to handle loops. This turns out to be a substantial issue for theoretical reasons: Programs without loop (and without recursive functions) always run for a limited amount of execution steps, so we can easily write down formulas that, essentially, track their entire execution history. But programs with loops can take arbitrarily many steps, or even run into infinite loops, so we cannot describe their behavior using a finite propositional formula in the way we have done above.</p>
<p>There are multiple approaches to deal with this problem, all with different trade-offs. CBMC chooses bounded model checking as the underlying approach. The idea is that we only consider program executions that are, in some measure, ''shorter'' than a given bound. This bound then implies an upper bound on the size of the required formulas, which makes the problem tractable.</p>
<p>To make this concrete, let's go back to the factorial example. We consider the function in the following form (in CPROVER, we actually use a <code>goto</code>-based IR, but the <code>while</code>-based version is a bit simpler to understand): </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> factorial(<span class="keywordtype">unsigned</span> n) {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac = 1;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;</div>
<div class="line">  <span class="keywordflow">while</span> (i &lt;= n) {</div>
<div class="line">    fac *= i;</div>
<div class="line">    i = i+1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> fac;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We set the following ''length bound'': The loops in the program are allowed to be executed at most three times; we will ignore all other executions. With this in mind, we observe that the following two classes of programs behave exactly the same: </p><div class="fragment"><div class="line"><span class="comment">/* Execute this loop at most n+1 times */</span></div>
<div class="line"><span class="keywordflow">while</span> (e) {</div>
<div class="line">  body;</div>
<div class="line">}</div>
</div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (e) {</div>
<div class="line">  body;</div>
<div class="line">  <span class="comment">/* Execute this loop at most n times */</span></div>
<div class="line">  <span class="keywordflow">while</span> (e) {</div>
<div class="line">    body;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> This transformation is known as <a href="https://en.wikipedia.org/wiki/Loop_unrolling">loop unrolling</a> or <em>unwinding</em>: We can always replace a loopby an <code>if</code> that checks if we should execute, a copy of the loop body and the loop statement.</p>
<p>So, to reason about the <code>factorial</code> function, we unroll the loop three times and then replace the loop with <code>ASSERT(!(condition))</code>. We get: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> factorial(<span class="keywordtype">unsigned</span> n) {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac = 1;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1;</div>
<div class="line">  <span class="keywordflow">if</span> (i &lt;= n) {</div>
<div class="line">    fac *= i;</div>
<div class="line">    i = i+1;</div>
<div class="line">    <span class="keywordflow">if</span> (i &lt;= n) {</div>
<div class="line">      fac *= i;</div>
<div class="line">      i = i+1;</div>
<div class="line">      <span class="keywordflow">if</span> (i &lt;= n) {</div>
<div class="line">        fac *= i;</div>
<div class="line">        i = i+1;</div>
<div class="line">        <a class="code" href="goto__program_8h.html#a9e03d66cd12c59d9d3daad1ec6296beba61d9e0e93eb9635173764c5ba45666f1">ASSERT</a>(!(i &lt;= n));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> fac;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Since this program is now in a simpler form without loops, we can use the techniques we learned above to transform it into a propositional formula. First, we transform into SSA (with code guard variables already included): </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> factorial(<span class="keywordtype">unsigned</span> n) {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> fac.1 = 1;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i.1 = 1;</div>
<div class="line">  bit C1 = i.1 &lt;= n;</div>
<div class="line">  <span class="comment">/* if (C1) { */</span></div>
<div class="line">  fac.2 = fac.1 * i.1;</div>
<div class="line">  i.2 = i.1+1;</div>
<div class="line">  bit C2 = i.2 &lt;= n;</div>
<div class="line">  <span class="comment">/* if (C2) { */</span></div>
<div class="line">  fac.3 = fac.2 * i.2;</div>
<div class="line">  i.3 = i.2+1;</div>
<div class="line">  bit C3 = i.3 &lt;= n;</div>
<div class="line">  <span class="comment">/* if (C3) { */</span></div>
<div class="line">  fac.4 = fac.3 * i.3;</div>
<div class="line">  i.4 = i.3+1;</div>
<div class="line">  <a class="code" href="goto__program_8h.html#a9e03d66cd12c59d9d3daad1ec6296beba61d9e0e93eb9635173764c5ba45666f1">ASSERT</a>(!(i.4 &lt;= n));</div>
<div class="line">  <span class="comment">/* }}} */</span></div>
<div class="line">  <span class="keywordflow">return</span> Phi(C1, Phi(C2, Phi(C3, fac.4, fac.3), fac.2), fac.1);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that we may be missing possible executions of the program due to this translation; we come back to this point later.</p>
<p>The corresponding propositional formula can then be written as (check that this is equivalent to the formula you would be getting by following the translation procedure described above):</p>
<blockquote class="doxtable">
<p>fac.1 = 1 and i.1 = 1 and C1 = i.1 &lt;= n and fac.2 = fac.1 * i.1 and i.2 = i.1 + 1 and C2 = i.2 &lt;= n and fac.3 = fac.2 * i.2 and i.3 = i.2 + 1 and C3 = i.3 &lt;= n and fac.4 = fac.3 * i.3 and i.4 = i.3 + 1 and C4 = i.4 &lt;= n and not (i.4 &lt;= n) and ((C1 and C2 and C3) &rArr; result = fac.4) and ((C1 and C2 and not C3) &rArr; result = fac.3) and ((C1 and not C2) &rArr; result = fac.2) and ((not C1) &rArr; result = fac.1) </p>
</blockquote>
<p>In the following, we reference this formula as FA(n, result).</p>
<p>At this point, we know how to encode programs as propositional formulas. Our goal was to reason about programs, and in particular, to check whether a certain property holds. Suppose, for example, that we want to check if there is a way that the <code>factorial</code> function returns <code>6</code>. One way to do this is to look at the following propositional formula: FA(n, result) and result = 6. If this formula has a model (i.e., if we can find a satisfying assignment to all variables, and in particular, to n), we can extract the required value for the parameter <code>n</code> from that model. As we have discussed above, this can be done using a SAT solver: If you run, say, MiniSAT on this formula, you will get a model that translates to n=3.</p>
<p>Be aware that this method has very clear limits: We know that the factorial of <code>5</code> is <code>120</code>, but with the formula above, evaluating ''FA(n, result) and result=120'' would yield ''unsatisfiable''! This is because we limited the number of loop iterations, and to reach 120, we have to execute the loop more than three times. In particular, a ''VERIFICATION SUCCESSFUL'' message, as output by CBMC, must always be interpreted keeping the bounds that were used in mind.</p>
<p>In the case that we found a model, we can get even more information: We can even reconstruct the program execution that would lead to the requested result. This can be achieved by tracing the SSA, using the guard variables to decide which branches of <code>if</code> statements to take. In this way, we can simulate the behavior of the program. Writing down the steps of this simulation yields a <em>trace</em>, which described how the corresponding program execution would look like.</p>
<h3><a class="anchor" id="smt_etc_subsubsection"></a>
Where to go from here</h3>
<p>The above section gives only a superficial overview on how SAT solving and bounded model checking work. Inside the CPROVER framework, we use a significantly more advanced engine, with numerous optimizations to the basic algorithms presented above. One feature that stands out is that we do not reduce everything to propositional logic, but instead use a more powerful logic, namely quantifier-free first-order logic. The main difference is that instead of propositional variables, we allow expressions that return Boolean values, such as comparisons between numbers or string matching expressions. This gives us a richer logic to express properties. Of course, a simple SAT solver cannot deal with such formulas, which is why we go to <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories"><em>SMT solvers</em></a> instead - these solvers can deal with specific classes of first-order formulas (like the ones we produce). One well-known SMT solver is <a href="https://github.com/Z3Prover/z3">Z3</a>.</p>
<h2><a class="anchor" id="static_analysis_section"></a>
Static analysis</h2>
<p>While BMC analyzes the program by transforming everything to logic formulas and, essentially, running the program on sets of concrete states, another approach to learn about a program is based on the idea of interpreting an abstract version of the program. This is known as <a href="https://en.wikipedia.org/wiki/Abstract_interpretation"><b>abstract interpretation</b></a>. Abstract interpretation is one of the main methods in the area of <b>static analysis</b>.</p>
<h3><a class="anchor" id="abstract_interpretation_section"></a>
Abstract Interpretation</h3>
<p>The key idea is that instead of looking at concrete program states (e.g., ''variable x contains value 1''), we look at some sufficiently-precise abstraction (e.g., ''variable x is odd'', or ''variable x is positive''), and perform interpretation of the program using such abstract values. Coming back to our running example, we wish to prove that the factorial function never returns 0.</p>
<p>An abstract interpretation is made up from four ingredients:</p><ol type="1">
<li>An <b>abstract domain</b>, which represents the analysis results.</li>
<li>A family of <b>transformers</b>, which describe how basic programming language constructs modify the state.</li>
<li>A map that takes a pair of a program location (e.g., a position in the program code) and a variable name and yields a value in the abstract domain.</li>
<li>An algorithm to compute a ''fixed point'', computing a map as described in the previous step that describes the behavior of the program.</li>
</ol>
<p>The first ingredient we need for abstract interpretation is the <b>abstract domain</b>. The domain allows us to express what we know about a given variable or value at a given program location; in our example, whether it is zero or not. The way we use the abstract domain is for each program point, we have a map from visible variables to elements of the abstract domain, describing what we know about the values of the variables at this point.</p>
<p>For instance, consider the <code>factorial</code> example again. After running the first basic block, we know that <code>fac</code> and <code>i</code> both contain 1, so we have a map that associates both <code>fac</code> and <code>i</code> to "not 0".</p>
<p>An abstract domain is a set $D$ (or, if you prefer, a data type) with the following properties:</p><ul>
<li>There is a function merge that takes two elements of $D$ and returns an element of $D$. This function is:<ul>
<li><b>associative</b> - <code>(merge(x, merge(y,z)) = merge(merge(x,y), z))</code>,</li>
<li><b>commutative</b> - <code>(merge(x,y) = merge(y,x))</code> and</li>
<li><b>idempotent</b> <code>(merge(x,x) = x)</code>.</li>
</ul>
</li>
<li>There is an element bottom of $D$ such that <code>merge(x, bottom) = x</code>.</li>
</ul>
<p>Algebraically speaking, $D$ needs to be a semi-lattice.</p>
<p>For our example, we use the following domain:</p><ul>
<li>D contains the elements "bottom" (nothing is known), "equals 0", "not 0" and "could be 0".</li>
<li><code>merge</code> is defined as follows:<ul>
<li><code>merge(bottom, x)</code> = <code>x</code></li>
<li><code>merge("could be 0", x)</code> = <code>"could be 0"</code></li>
<li><code>merge(x,x) =</code>x<code> *</code>merge("equals 0", "not 0")<code>=</code>"could be 0"<code> -</code>bottom` is bottom, obviously. It is easy but tedious to check that all conditions hold.</li>
</ul>
</li>
</ul>
<p>The second ingredient we need are the <b>abstract state transformers</b>. An abstract state transformer describes how a specific expression or statement processes abstract values. For the example, we need to define abstract state transformers for multiplication and addition.</p>
<p>Let us start with multiplication, so let us look at the expression <code>x*y</code>. We know that if <code>x</code> or <code>y</code> are 0, <code>x*y</code> is zero. Thus, if <code>x</code> or <code>y</code> are "equals 0", the result of <code>x*y</code> is also "equals 0". If <code>x</code> or <code>y</code> are "could be 0" (but neither is "equals 0"), we simply don't know what the result is - it could be zero or not. Thus, in this case, the result is "could be 0".</p>
<p>What if <code>x</code> and <code>y</code> are both "not 0"? In a mathematically ideal world, we would have <code>x*y</code> be non-zero as well. But in a C program, multiplication could <em>overflow</em>, yielding <code>0</code>. So, to be correct, we have to yield "could be 0" in this case.</p>
<p>Finally, when <code>x</code> is bottom, we can just return whatever value we had assigned to <code>y</code>, and vice versa.</p>
<p>For addition, the situation looks like this: consider <code>x+y</code>. If neither <code>x</code> nor <code>y</code> is "not 0", but at least one is "could be 0", the result is "could be 0". If both are "equals 0", the result is "equals 0". What if both are "not 0"? It seems that, since the variables are unsigned and not zero, it should be "not 0". Sadly, overflow strikes again, and we have to make do with "could be 0". The bottom cases can be handled just like for multiplication.</p>
<p>The way of defining the transformation functions above showcases another important property: they must reflect the actual behavior of the underlying program instructions. There is a formal description of this property, using <a href="https://en.wikipedia.org/wiki/Galois_connection"><em>Galois connections</em></a>; for the details, it is best to look at the literature.</p>
<p>The third ingredient is straightforward: we use a simple map from program locations and variable names to values in the abstract domain. In more complex analyses, more involved forms of maps may be used (e.g., to handle arbitrary procedure calls, or to account for the heap).</p>
<p>At this point, we have almost all the ingredients we need to set up an abstract interpretation. To actually analyze a function, we take its CFG and perform a <em>fixpoint algorithm</em>.</p>
<p>Concretely, let us consider the CFG for factorial again. This time, we have named the basic blocks, and simplified the variable names. </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_12.svg" width="415" height="331"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe><div class="caption">
Control flow graph for factorial - named basic blocks</div>
</div>
<p>We provide an initial variable map: <code>n</code> is "could be 0" before BB1. As a first step, we analyze BB1 and find that the final variable map should be:</p><ul>
<li><code>n</code> "could be 0".</li>
<li><code>fac</code> "not 0" (it is, in fact, 1, but our domain does not allow us to express this).</li>
<li><code>i</code> "not 0". Let as call this state N.</li>
</ul>
<p>At this point, we look at all the outgoing edges of BB1 - we wish to propagate our new results to all blocks that follow BB1. There is only one such block, BB2. We analyze BB2 and find that it doesn't change any variables. Furthermore, the result of <code>i &lt;= n</code> does not allow us to infer anything about the values in the variable map, so we get the same variable map at the end of BB2 as before.</p>
<p>Again, we look at the outgoing edges. There are two successor blocks, BB3 and BB4. The information in our variable map does not allow us to rule out either of the branches, so we need to propagate to both blocks. We start with BB3 and remember that we need to visit BB4.</p>
<p>At this point, we know that <code>n</code> "could be 0", while <code>fac</code> and <code>i</code> are "not 0". Applying the abstract transformers, we learn that afterwards, both <code>fac</code> and <code>i</code> "could be 0" (<code>fac</code> ends up as "could be 0" since both <code>fac</code> and <code>i</code> were "not 0" initially, <code>i</code> ends up as "could be 0" because both <code>i</code> and 1 are "not 0"). So, the final variable map at the end of BB3 is</p><ul>
<li><code>n</code>, <code>fac</code> and <code>i</code> "could be 0". Let us call this state S.</li>
</ul>
<p>At this point, we propagate again, this time to BB2. But wait, we have propagated to BB2 before! The way this is handled is as follows: We first calculate what the result of running BB2 from S; this yields S again. Now, we know that at the end of BB2, we can be either in state S or N. To get a single state out of these two, we <em>merge</em>: for each variable, merge the mapping of that variable in S and N. We get:</p><ul>
<li><code>n</code> maps to merge("could be 0", "could be 0") = "could be 0"</li>
<li><code>fac</code> maps to merge("could be 0", "not 0") = "could be 0"</li>
<li><code>i</code> maps to merge("could be 0", "not 0") = "could be 0" In other words, we arrive at S again.</li>
</ul>
<p>At this point, we propagate to BB3 and BB4 again. Running BB3, we again end up with state S at the end of BB3, so things don't change. We detect this situation and figure out that we do not need to propagate from BB3 to BB2 - this would not change anything! Thus, we can now propagate to BB4. The state at the end of BB4 is also S.</p>
<p>Now, since we know the variable map at the end of BB4, we can look up the properties of the return value: in S, <code>fac</code> maps to "could be 0", so we could not prove that the function never returns 0. In fact, this is correct: calculating <code>factorial(200)</code> will yield 0, since the 64-bit integer <code>fac</code> overflows.</p>
<p>Nevertheless, let us consider what would happen in a mathematically ideal world (e.g., if we used big integers). In that case, we would get "not 0" * "not 0" = "not 0", "not 0" + x = "not 0" and x + "not 0" = "not 0". Running the abstract interpretation with these semantics, we find that if we start BB3 with variable map N, we get variable map N at the end as well, so we end up with variable map N at the end of BB4 - but this means that fac maps to "not 0"!</p>
<p>The algorithm sketched above is called a fixpoint algorithm because we keep propagating until we find that applying the transformers does not yield any new results (which, in a mathematically precise way, can be shown to be equivalent to calculating, for a specific function f, an x such that f(x) = x).</p>
<p>This overview only describes the most basic way of performing abstract interpretation. For one, it only works on the procedure level (we say it is an <em>intra-procedural analysis</em>); there are various ways of extending it to work across function boundaries, yielding <em>inter-procedural analysis</em>. Additionally, there are situations where it can be helpful make a variable map more abstract (widening) or use information that can be gained from various sources to make it more precise (narrowing); these advanced topics can be found in the literature as well.</p>
<h1><a class="anchor" id="Glossary_section"></a>
Glossary</h1>
<h2><a class="anchor" id="instrument_subsection"></a>
Instrument</h2>
<p>To instrument a piece of code means to modify it by (usually) inserting new fragments of code that, when executed, tell us something useful about the code that has been instrumented.</p>
<p>For instance, imagine you are given the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> aha (<span class="keywordtype">int</span> a)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (a &gt; 10)</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">      <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and you want to design an analysis that figures out which lines of code will be covered when <code>aha</code> is executed with the input <code>5</code>.</p>
<p>We can <em>instrument</em> the code so that the function will look like: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> aha (<span class="keywordtype">int</span> a)</div>
<div class="line">{</div>
<div class="line">   __runtime_line_seen(0);</div>
<div class="line">   <span class="keywordflow">if</span> (a &gt; 10) {</div>
<div class="line">      __runtime_line_seen(1);</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      __runtime_line_seen(2);</div>
<div class="line">      <span class="keywordflow">return</span> -1;</div>
<div class="line">   }</div>
<div class="line">   __runtime_line_seen(3);</div>
<div class="line">}</div>
</div><!-- fragment --><p>All we have to do now is to implement the function <code>void __runtime_line_seen(int line)</code> so that when executed it logs somewhere what line is being visited. Finally we execute the instrumented version of <code>aha</code> and collect the desired information from the log.</p>
<p>More generally speaking, and especially within the CPROVER code base, instrumenting the code often refers to modify its behavior in a manner that makes it easier for a given analysis to do its job, regardless of whether that is achieved by executing the instrumented code or by just analyzing it in some other way.</p>
<h2><a class="anchor" id="flattening_lowering_subsection"></a>
Flattening and Lowering</h2>
<p>As we have seen above, we often operate on many different representations of programs, such as ASTs, control flow graphs, SSA programs, logical formulas in BMC and so on. Each of these forms is good for certain kinds of analyses, transformations or optimizations.</p>
<p>One important kind of step in dealing with program representations is going from one representation to the other. Often, such steps are going from a more ''high-level'' representation (closer to the source code) to a more ''low-level'' representation. Such transformation steps are known as <b>flattening</b> or <b>lowering</b> steps, and tend to be more-or-less irreversible.</p>
<p>An example of a lowering step is the transformation from ASTs to the GOTO IR, given above.</p>
<h2><a class="anchor" id="verification_condition_subsection"></a>
Verification Condition</h2>
<p>In the CPROVER framework, the term <b>verification condition</b> is used in a somewhat non-standard way. Let a program and a set of assertions be given. We transform the program into an (acyclic) SSA (i.e., an SSA with all loops unrolled a finite number of times) and turn it into a logical formula, as described above. Note that in this case, the formula will also contain information about what the program does after the assertion is reached: this part of the formula, is, in fact, irrelevant for deciding whether the program can satisfy the assertion or not. The <em>verification condition</em> is the part of the formula that only covers the program execution until the line that checks the assertion has been executed, with everything that comes after it removed.</p>
<p>Last modified: 2024-03-25 14:55:24 +0100 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Documentation</a></li><li class="navelem"><a class="el" href="cprover_documentation.html">CProver documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
