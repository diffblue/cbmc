<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: Shadow Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Shadow Memory </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_modeling_shadow_memory"></a></p>
<p>The Symbolic Shadow Memory module described below is an implementation of what is outlined in the paper <a href="https://dl.acm.org/doi/abs/10.1145/3551349.3559523">CBMC-SSM: Bounded Model Checking of C Programs with Symbolic Shadow Memory</a>.</p>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>CBMC implements <em>Symbolic Shadow Memory</em>. Symbolic Shadow Memory (from now on, SSM) allows one to create a parallel memory structure that is maintained by the analysis program and that shadows the standard memory of the program. In the Shadow Memory structure, a user can create fields, for which he can get (retrieve) and set values.</p>
<p>By doing so, a user can organise their own tracking of metadata related to the code, in a way that is then considered by the backend of CBMC during analysis. This can be used to implement novel analyses that the CBMC framework itself does not support. For example, the paper above presents as an example a taint analysis implemented with the use of the SSM component described here.</p>
<h1><a class="anchor" id="usage"></a>
Usage</h1>
<p>A user can interact with the Symbolic Shadow Memory component through four CBMC primitives. These allow the declaration of shadow memory fields, and get/set their corresponding values:</p>
<ul>
<li><code>__CPROVER_field_decl_local</code></li>
<li><code>__CPROVER_field_decl_global</code></li>
<li><code>__CPROVER_get_field</code></li>
<li><code>__CPROVER_set_field</code></li>
</ul>
<p>More precisely, their signatures (in pseudo-C, because of some constraints that we cannot express using the type system), along with some small examples of their usage, are described below:</p>
<h2><a class="anchor" id="void-__cprover_field_decl_localtype1-field_name-ssm_value_type-init_value"></a>
&lt;tt&gt;void __CPROVER_field_decl_local(type1 field_name, SSM_value_type init_value)&lt;/tt&gt;</h2>
<p>Type constraints:</p>
<ul>
<li><code>type1</code>: string literal, such as <code>"field"</code>,</li>
<li><code>SSM_value_type</code>: any value up to 8 bits in size (signed or unsigned).</li>
</ul>
<p>Declares a local shadow memory field called <code>field_name</code>, and initialises it with the value <code>init_value</code>. The field is going to be associated with function local-scope objects (i.e.&#160;a variable on the stack).</p>
<p>Note that each function scope will have a separate <em>local</em> shadow memory, so the value stored in the <em>local</em> shadow memory is not propagated to subcalls (even when the call is recursive). For this reason, to be able to access shadow memory argument values from a called function or the value of the return from the callee it is necessary to use the global shadow memory and passing arguments and return values as pointers or to use global variables.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func() {</div>
<div class="line">    <span class="comment">// Sample local object (local variable)</span></div>
<div class="line">    <span class="keywordtype">char</span> x = 0;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Shadow memory field associated with local objects.</span></div>
<div class="line">    __CPROVER_field_decl_local(<span class="stringliteral">&quot;shadow&quot;</span>, (_Bool)1);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="void-__cprover_field_decl_globaltype1-field_name-ssm_value_type-init_value"></a>
&lt;tt&gt;void __CPROVER_field_decl_global(type1 field_name, SSM_value_type init_value)&lt;/tt&gt;</h2>
<p>Type constraints:</p>
<ul>
<li><code>type1</code>: string literal, such as <code>"field"</code>,</li>
<li><code>SSM_value_type</code>: any value up to 8 bits in size (signed or unsigned).</li>
</ul>
<p>As for <code>__CPROVER_field_decl_local</code>, but the field declared is associated with objects whose lifetime exceeds the current function scope (i.e.&#160;global variables or heap allocated objects).</p>
<div class="fragment"><div class="line"><span class="comment">// Sample global object</span></div>
<div class="line"><span class="keywordtype">int</span> a = 10;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func() {</div>
<div class="line">    <span class="comment">// Shadow memory field associated with global objects.</span></div>
<div class="line">    __CPROVER_field_decl_global(<span class="stringliteral">&quot;shadow&quot;</span>, (_Bool)0);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ssm_value_type-__cprover_get_fieldtype1-p-type2-field_name"></a>
&lt;tt&gt;SSM_VALUE_TYPE __CPROVER_get_field(type1 *p, type2 field_name)&lt;/tt&gt;</h2>
<p>Type constraints:</p>
<ul>
<li><code>SSM_VALUE_TYPE</code>: the type of the returned value is the same of the SSM field, i.e.&#160;the type that was used to intialise the SSM field during declaration,</li>
<li><code>type1 *</code>: a non-<code>void</code> pointer to an object of type <code>type1</code>, whose address we are going to use for indexing the shadow memory component for the field declared,</li>
<li><code>type2</code>: a string literal-typed value, denoting the name of the field whose value we want to retrieve, such as <code>"field"</code>.</li>
</ul>
<p>Retrieves the latest value associated with a SSM field to the given pointer. This would be either the value the field was declared to be initialised with, or, if there had been subsequent changes to it through a <code>__CPROVER_set_field</code> (see <code>__CPROVER_set_field</code> section below), the value that it was last <code>set</code> with.</p>
<div class="fragment"><div class="line"><span class="comment">// Sample global object</span></div>
<div class="line"><span class="keywordtype">int</span> a = 10;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func() {</div>
<div class="line">    <span class="comment">// Shadow memory field (called &quot;field&quot;) associated with global objects.</span></div>
<div class="line">    __CPROVER_field_decl_global(<span class="stringliteral">&quot;shadow&quot;</span>, (_Bool)0);</div>
<div class="line"> </div>
<div class="line">    _Bool shadow_x = __CPROVER_get_field(&amp;a, <span class="stringliteral">&quot;shadow&quot;</span>);</div>
<div class="line">    __CPROVER_assert(shadow_x == 0, <span class="stringliteral">&quot;expected success: field initialised with 0&quot;</span>);</div>
<div class="line">    __CPROVER_assert(shadow_x == 1, <span class="stringliteral">&quot;expected fail: field initialised with 0&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that getting the value of a local variable from a global SSM field or the opposite will return the default value for that SSM field (and it <b>will not</b> fail).</p>
<h2><a class="anchor" id="void-__cprover_set_fieldtype1-p-type2-field_name-type3-set_value"></a>
&lt;tt&gt;void __CPROVER_set_field(type1 *p, type2 field_name, type3 set_value)&lt;/tt&gt;</h2>
<p>Type constraints:</p>
<ul>
<li><code>type1 *</code>: a non-<code>void</code> pointer to an object of type <code>type1</code>, whose address we are going to use for indexing the shadow memory component for the field declared,</li>
<li><code>type2</code>: a string literal-typed value, denoting the name of the field whose value we want to retrieve, such as <code>"field"</code>,</li>
<li><code>type3</code>: type of the value to be set. This can be any integer type signed or unsigned (including <code>_Bool</code>). Notice that if this type differs from the type the SSM field was declared with (<code>SSM_VALUE_TYPE</code> above) it will be implicitly casted to it.</li>
</ul>
<p>Sets the value associated with a SSM field to the given pointer <code>p</code> with the given value <code>set_value</code>. If the <code>set_value</code> type is not the <code>SSM_VALUE_TYPE</code>, it will be implicitly casted to it.</p>
<div class="fragment"><div class="line"><span class="comment">// Sample global object, used for addressing within the SSM component.</span></div>
<div class="line"><span class="keywordtype">int</span> a = 10;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func() {</div>
<div class="line">    <span class="comment">// Shadow memory field (called &quot;field&quot;) associated with global objects.</span></div>
<div class="line">    <span class="comment">// Originally assigned a value of `0`, of type `_Bool`.</span></div>
<div class="line">    __CPROVER_field_decl_global(<span class="stringliteral">&quot;shadow&quot;</span>, (_Bool)0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">    <span class="comment">// of the object `a`. </span></div>
<div class="line">    _Bool shadow_x = __CPROVER_get_field(&amp;a, <span class="stringliteral">&quot;shadow&quot;</span>);</div>
<div class="line">    __CPROVER_assert(shadow_x == 0, <span class="stringliteral">&quot;expected success: field defaulted to a value of 0&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set field &quot;shadow&quot; for the memory location denoted by the address of `a`</span></div>
<div class="line">    <span class="comment">// to a value of `1`.</span></div>
<div class="line">    __CPROVER_set_field(&amp;a, <span class="stringliteral">&quot;shadow&quot;</span>, 1);</div>
<div class="line">    <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">    <span class="comment">// of the object `a`.</span></div>
<div class="line">    shadow_x = __CPROVER_get_field(&amp;a, <span class="stringliteral">&quot;shadow&quot;</span>);</div>
<div class="line">    __CPROVER_assert(shadow_x == 1, <span class="stringliteral">&quot;expected success: field set to a value of 1&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that setting the value of a local variable from a global SSM field or the opposite will produce no effect (and it <b>will not</b> fail).</p>
<h2><a class="anchor" id="working-with-compound-type-objects"></a>
Working with Compound Type Objects</h2>
<p>When using SSM on compound type pointers (e.g.&#160;<code>struct</code> and <code>union</code>) the value used for the <code>__CPROVER_set_field</code> will be replicated in each of the fields of the type, and aggregated again when retrieving them with <code>__CPROVER_get_field</code>. The aggregation function is <code>or</code> for an SSM field of <code>_Bool</code> type, and <code>max</code> for other types.</p>
<p>This is helpful, for example, in the case of taint analysis (as presented in the paper and shown below). In this case, when retrieving the taint value of a struct containing a tainted field the result value will indicate taint (without the need for changing non-tainted field values), and when setting the taint value of a struct then all its fields will be set to the given value.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>S {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> f1;</div>
<div class="line">  <span class="keywordtype">char</span> f2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> func() {</div>
<div class="line">  <span class="comment">// Shadow memory field (called &quot;field&quot;) associated with local objects.</span></div>
<div class="line">  <span class="comment">// Originally assigned a value of `0`, of type `_Bool`.</span></div>
<div class="line">  __CPROVER_field_decl_local(<span class="stringliteral">&quot;shadow&quot;</span>, (_Bool)0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Struct typed variable</span></div>
<div class="line">  <span class="keyword">struct </span>S s;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the object `s`. Here we expect a `0` as default.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field defaulted to a value of 0&quot;</span>);</div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the field `f1` of the object `s`. Here we expect a `0` as default.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s.f1, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field defaulted to a value of 0&quot;</span>);</div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the field `f1` of the object `s`. Here we expect a `0` as default.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s.f2, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field defaulted to a value of 0&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the shadow memory of the field `f1` (ONLY) of the object `s`.</span></div>
<div class="line">  __CPROVER_set_field(&amp;s.f1, <span class="stringliteral">&quot;shadow&quot;</span>, 1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the object `s`. Here we expect a `1` as the value of field `f1` (after</span></div>
<div class="line">  <span class="comment">// aggregating all its field values using `max`).</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s, <span class="stringliteral">&quot;shadow&quot;</span>) == 1, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field previously set to a value of 1&quot;</span>);</div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the field `f1` of the object `s`. Here we expect a `1` as set above.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s.f1, <span class="stringliteral">&quot;shadow&quot;</span>) == 1, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field previously set to a value of 1&quot;</span>);</div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the field `f2` of the object `s`. Here we expect a `0` as default.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s.f2, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field defaulted to a value of 0&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the shadow memory of the object `s`. This in turns sets also the </span></div>
<div class="line">  <span class="comment">// values of each (shadow) field of `s`.</span></div>
<div class="line">  __CPROVER_set_field(&amp;s, <span class="stringliteral">&quot;shadow&quot;</span>, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the object `s`. Here we expect a `0` as set above.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field previously set to a value of 0&quot;</span>);</div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the field `f1` of the object `s`. Here we expect a `0` as the set</span></div>
<div class="line">  <span class="comment">// above was replicated on all the fields of `s`.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s.f1, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field previously set to a value of 0&quot;</span>);</div>
<div class="line">  <span class="comment">// Retrieve the value of the field named &quot;shadow&quot; associated with the address</span></div>
<div class="line">  <span class="comment">// of the field `f2` of the object `s`. Here we expect a `0` as the set</span></div>
<div class="line">  <span class="comment">// above was replicated on all the fields of `s`.</span></div>
<div class="line">  __CPROVER_assert(__CPROVER_get_field(&amp;s.f2, <span class="stringliteral">&quot;shadow&quot;</span>) == 0, </div>
<div class="line">                   <span class="stringliteral">&quot;expected success: field previously set to a value of 0&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Last modified: 2024-07-29 12:31:24 +0200 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
