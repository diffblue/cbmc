<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: properties</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">properties </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="automatically-generating-properties"></a>
Automatically Generating Properties</h1>
<h2><a class="anchor" id="what-is-a-property"></a>
What is a “Property”?</h2>
<p>We have mentioned <em>properties</em> several times so far, but we never explained <em>what</em> kind of properties CBMC can verify. We cover this topic in more detail in this section.</p>
<p>CBMC uses <a href="http://en.wikipedia.org/wiki/Assertion_(computing)">assertions</a> to specify program properties. Assertions are properties of the state of the program when the program reaches a particular program location. Assertions are often written by the programmer using the <code>assert</code> macro.</p>
<p>In addition to the assertions written by the programmer, assertions for specific properties can also be generated automatically by CBMC, often relieving the programmer from expressing properties that should hold in any well-behaved program.</p>
<p>CBMC comes with an assertion generator, which performs a conservative <a href="http://en.wikipedia.org/wiki/Static_code_analysis">static analysis</a> to determine program locations that potentially contain a bug. Due to the imprecision of the static analysis, it is important to emphasize that these generated assertions are only <em>potential</em> bugs, and that the Model Checker first needs to confirm that they are indeed genuine bugs.</p>
<p>The assertion generator can generate assertions for the verification of the following properties:</p>
<ul>
<li><b>Buffer overflows.</b> For each array access, check whether the upper and lower bounds are violated.</li>
<li><b>Pointer safety.</b> Search for <code>NULL</code>-pointer dereferences or dereferences of other invalid pointers.</li>
<li><b>Memory leaks.</b> Check whether the program constructs dynamically allocated data structures that are subsequently inaccessible.</li>
<li><b>Division by zero.</b> Check whether there is a division by zero in the program.</li>
<li><b>Not-a-Number.</b> Check whether floating-point computation may result in <a href="http://en.wikipedia.org/wiki/NaN">NaNs</a>.</li>
<li><b>Arithmetic overflow.</b> Check whether a numerical overflow occurs during an arithmetic operation.</li>
<li><b>Undefined shifts.</b> Check for shifts with excessive distance.</li>
</ul>
<p>We won’t explain the properties in detail. Most of them relate to behaviors that are left undefined by the respective language semantics. For a discussion on why these behaviors are usually very undesirable, read <a href="http://blog.regehr.org/archives/213">this</a> blog post by John Regehr.</p>
<p>All the properties described above are <em>reachability</em> properties. They are always of the form</p>
<p>“*Is there a path through the program such that some property is violated?*”</p>
<p>The counterexamples to such properties are always program paths. Users of the Eclipse plugin can step through these counterexamples in a way that is similar to debugging programs. The installation of this plugin is explained <a href="http://www.cprover.org/eclipse-plugin/">here</a>.</p>
<h2><a class="anchor" id="using-goto-instrument"></a>
Using goto-instrument</h2>
<p>The goto-instrument static analyzer operates on goto-binaries, which is a binary representation of control-flow graphs. The goto-binary is extracted from program source code using goto-cc, which is explained <a class="el" href="md_goto_cc.html">here</a>. Given a goto-program, goto-instrument operates as follows:</p>
<ol type="1">
<li>A goto-binary is read in.</li>
<li>The specified static analyses are performed.</li>
<li>Any potential bugs found are transformed into corresponding assertions, and are added into the program.</li>
<li>A new goto-binary (with assertions) is written to disc.</li>
</ol>
<p>As an example, we begin with small C program we call <code>expr.c</code> (taken from <a href="http://www.spinroot.com/uno/">here</a>):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *ptr;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keywordflow">if</span> (ptr)</div>
<div class="line">    *ptr = 0;</div>
<div class="line">  <span class="keywordflow">if</span> (!ptr)</div>
<div class="line">    *ptr = 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The program contains an obvious NULL-pointer dereference. We first compile the example program with goto-cc and then instrument the resulting goto-binary with pointer checks. </p><pre class="fragment">goto-cc expr.c -o in.gb   goto-instrument in.gb out.gb --pointer-check
</pre><p> We can now get a list of the assertions that have been generated: </p><pre class="fragment">goto-instrument out.gb --show-properties
</pre><p> Using CBMC on <code>out.gb</code>, we can obtain a counterexample trace for the NULL-pointer dereference: </p><pre class="fragment">cbmc out.gb
</pre><p> The goto-instrument program supports these checks:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag   </th><th class="markdownTableHeadNone">Check    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--no-assertions</code>   </td><td class="markdownTableBodyNone">ignore user assertions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--bounds-check</code>   </td><td class="markdownTableBodyNone">add array bounds checks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--div-by-zero-check</code>   </td><td class="markdownTableBodyNone">add division by zero checks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--pointer-check</code>   </td><td class="markdownTableBodyNone">add pointer checks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--pointer-primitive-check</code>   </td><td class="markdownTableBodyNone">add pointer primitive checks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--signed-overflow-check</code>   </td><td class="markdownTableBodyNone">add arithmetic over- and underflow checks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--unsigned-overflow-check</code>   </td><td class="markdownTableBodyNone">add arithmetic over- and underflow checks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--undefined-shift-check</code>   </td><td class="markdownTableBodyNone">add range checks for shift distances    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--nan-check</code>   </td><td class="markdownTableBodyNone">add floating-point NaN checks    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--uninitialized-check</code>   </td><td class="markdownTableBodyNone">add checks for uninitialized locals (experimental)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--error-label label</code>   </td><td class="markdownTableBodyNone">check that given label is unreachable   </td></tr>
</table>
<p>As all of these checks apply across the entire input program, we may wish to disable or enable them for selected statements in the program. For example, unsigned overflows can be expected and acceptable in certain instructions even when elsewhere we do not expect them. As of version 5.12, CBMC supports selectively disabling or enabling automatically generated properties using pragmas.</p>
<p>CPROVER pragmas are handled using a stack:</p>
<ul>
<li><code>#pragma CPROVER check push</code> pushes a new level on the pragma stack</li>
<li><code>#pragma CPROVER check disable "&lt;name_of_check&gt;"</code> adds a disable pragma at the top of the stack</li>
<li><code>#pragma CPROVER check enable "&lt;name_of_check&gt;"</code> adds a enable pragma at the top of the stack</li>
<li>an <code>enable</code> or <code>disable</code> pragma for a given check present at the top level of the stack shadows other pragmas for the same in lower levels of the stack</li>
<li>adding both <code>enable</code> and <code>disable</code> pragmas for a same check in a same level of the stack creates a PARSING_ERROR.</li>
<li><code>#pragma CPROVER check pop</code> pops a level in the stack and restores the state of pragmas at the sub level</li>
</ul>
<p>For example, for unsigned overflow checks, use </p><pre class="fragment">unsigned foo(unsigned x)
{
#pragma CPROVER check push
#pragma CPROVER check enable "unsigned-overflow"
  // unsigned overflow check apply here
  x = x + 1;
#pragma CPROVER check pop
  // unsigned overflow checks do not apply here
  x = x + 2;

unsigned foo(unsigned x)
{
#pragma CPROVER check push
#pragma CPROVER check enable "unsigned-overflow"
#pragma CPROVER check enable "signed-overflow"
  // unsigned and signed overflow check apply here
  x = x + 1;
#pragma CPROVER check push
#pragma CPROVER check disable "unsigned-overflow"
  // only signed overflow check apply here
  x = x + 2;
#pragma CPROVER check pop
  // unsigned and signed overflow check apply here
  x = x + 3;
#pragma CPROVER check pop
  // unsigned overflow checks do not apply here
  x = x + 2;

unsigned foo(unsigned x)
{
#pragma CPROVER check push
#pragma CPROVER check enable "unsigned-overflow"
#pragma CPROVER check enable "signed-overflow"
  // unsigned and signed overflow check apply here
  x = x + 1;
#pragma CPROVER check push
#pragma CPROVER check disable "unsigned-overflow"
#pragma CPROVER check enable "unsigned-overflow"
  // PARSING_ERROR Found enable and disable pragmas for unsigned-overflow-check
  x = x + 2;
#pragma CPROVER check pop
  x = x + 3;
#pragma CPROVER check pop
  x = x + 2;
</pre> <h3><a class="anchor" id="flag-nan-check-limitations"></a>
Flag –nan-check limitations</h3>
<p>Please note that <code>--nan-check</code> flag is adding not-a-number checks only for generation of NaN value. Current implementation of <code>--nan-check</code> flag is not providing checks for propagation of NaN values. Generating assertions on type casting or structure/union member access is unsupported and such operation will not be examined.</p>
<p>For example: </p><pre class="fragment">float f = 0.0/0.0; // will generate NaN - CBMC will add assertion
float g = NAN+0.0; // propagation of NaN value - no assertion generated
</pre> <h3><a class="anchor" id="generating-function-bodies"></a>
Generating function bodies</h3>
<p>Sometimes implementations for called functions are not available in the goto program, or it is desirable to replace bodies of functions with certain predetermined stubs (for example to confirm that these functions are never called, or to indicate that these functions will never return). For this purpose goto-instrument provides the <code>--generate-function-body</code> option, that takes a regular expression (in <a href="http://en.cppreference.com/w/cpp/regex/ecmascript">ECMAScript syntax</a>) that describes the names of the functions to generate. Note that this will only generate bodies for functions that do not already have one; If one wishes to replace the body of a function with an existing definition, the <code>--remove-function-body</code> option can be used to remove the body of the function prior to generating a new one.</p>
<p>The shape of the stub itself can be chosen with the <code>--generate-function-body-options</code> parameter, which can take these values:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Result    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>nondet-return</code>   </td><td class="markdownTableBodyNone">Do nothing and return a nondet result (this is the default)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>assert-false</code>   </td><td class="markdownTableBodyNone">Make the body contain an assert(false)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>assume-false</code>   </td><td class="markdownTableBodyNone">Make the body contain an assume(false)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>assert-false-assume-false</code>   </td><td class="markdownTableBodyNone">Combines assert-false and assume-false    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>havoc</code>   </td><td class="markdownTableBodyNone">Set the contents of parameters and globals to nondet   </td></tr>
</table>
<p>The various combinations of assert-false and assume-false can be used to indicate that functions shouldn’t be called, that they will never return or both.</p>
<p>Example: We have a program like this:</p>
<div class="fragment"><div class="line"><span class="comment">// error_example.c</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> api_error(<span class="keywordtype">void</span>);</div>
<div class="line"><span class="keywordtype">void</span> internal_error(<span class="keywordtype">void</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> arr[10] = {1,2,3,4,5, 6, 7, 8, 9, 10};</div>
<div class="line">  <span class="keywordtype">int</span> sum = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; 10; ++i)</div>
<div class="line">  {</div>
<div class="line">    sum += arr[i];</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(sum != 55)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// we made a mistake when calculating the sum</span></div>
<div class="line">    internal_error();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(rand() &lt; 0)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// we think this cannot happen</span></div>
<div class="line">    api_error();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, we can compile the program and detect that the error functions are indeed called by invoking these commands: </p><pre class="fragment">goto-cc error_example.c -o error_example.gb
# Replace all functions ending with _error
# (Excluding those starting with __)
# With ones that have an assert(false) body
goto-instrument error_example.gb error_example_replaced.gb \
  --generate-function-body '(?!__).*_error' \
  --generate-function-body-options assert-false
cbmc error_example_replaced.gb
</pre><p> This generates the following output: </p><pre class="fragment">** Results:
error_example.c function api_error
[api_error.assertion.1] line 4 assertion false: FAILURE

error_example.c function internal_error
[internal_error.assertion.1] line 5 assertion false: FAILURE

** 2 of 2 failed (2 iterations)
VERIFICATION FAILED
</pre><p> Without the instrumentation step we would have seen “VERIFICATION SUCCESSFUL”.</p>
<p>The havoc option takes further parameters <code>globals</code> and <code>params</code> with this syntax: <code>havoc[,globals:&lt;regex&gt;][,params:&lt;regex&gt;]</code> (where the square brackets indicate an optional part). The regular expressions have the same format as the those for the <code>--generate-function-body</code> option and indicate which globals and function parameters should be set to nondet. All regular expressions require exact matches (i.e.&#160;the regular expression <code>a|b</code> will match ‘a’ and ‘b’ but not ‘adrian’ or ‘bertha’).</p>
<p>Example: With a C program like this</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Complex {</div>
<div class="line">  <span class="keywordtype">double</span> real;</div>
<div class="line">  <span class="keywordtype">double</span> imag;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Complex AGlobalComplex;</div>
<div class="line"><span class="keywordtype">int</span> do_something_with_complex(<span class="keyword">struct</span> Complex *complex);</div>
</div><!-- fragment --><p>And the command line </p><pre class="fragment">goto-instrument in.gb out.gb
  --generate-function-body do_something_with_complex
  --generate-function-body-options
    'havoc,params:.*,globals:AGlobalComplex'
</pre><p> The goto code equivalent of the following will be generated:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> do_something_with_complex(<span class="keyword">struct</span> Complex *complex)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(complex)</div>
<div class="line">  {</div>
<div class="line">    complex-&gt;real = nondet_double();</div>
<div class="line">    complex-&gt;imag = nondet_double();</div>
<div class="line">  }</div>
<div class="line">  AGlobalComplex.real = nondet_double();</div>
<div class="line">  AGlobalComplex.imag = nondet_double();</div>
<div class="line">  <span class="keywordflow">return</span> nondet_int();</div>
<div class="line">}</div>
</div><!-- fragment --><p>A note on limitations: Because only static information is used for code generation, arrays of unknown size and pointers will not be affected by this. Which means that for code like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Node {</div>
<div class="line">  <span class="keywordtype">int</span> val;</div>
<div class="line">  <span class="keyword">struct </span>Node *next;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> do_something_with_node(<span class="keyword">struct</span> Node *node);</div>
</div><!-- fragment --><p>Code like this will be generated:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_something_with_node(<span class="keyword">struct</span> Node *node)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span>(node)</div>
<div class="line">   {</div>
<div class="line">     node-&gt;val = nondet_int();</div>
<div class="line">     node-&gt;next = nondet_0();</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that no attempt to follow the <code>next</code> pointer is made. If an array of unknown (or 0) size is encountered, a diagnostic is emitted and the array is not further examined.</p>
<p>Some care must be taken when choosing the regular expressions for globals and functions. Names starting with <code>__</code> are reserved for internal purposes; For example, replacing functions or setting global variables with the <code>__CPROVER</code> prefix might make analysis impossible. To avoid doing this by accident, negative lookahead can be used. For example, <code>(?!__).*</code> matches all names not starting with <code>__</code>.</p>
<p>Last modified: 2024-04-30 09:25:56 -0400 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
