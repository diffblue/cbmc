<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: modeling-pointers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">modeling-pointers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h2><a class="anchor" id="pointer-model"></a>
Pointer Model</h2>
<h3><a class="anchor" id="pointers-in-c"></a>
Pointers in C</h3>
<p>C programs (and sometimes C++ programs as well) make intensive use of pointers in order to decouple program code from specific data. A pointer variable does not store data such as numbers or letters, but instead points to a location in memory that hold the relevant data. This section describes the way the CPROVER tools model pointers.</p>
<h3><a class="anchor" id="objects-and-offsets"></a>
Objects and Offsets</h3>
<p>The CPROVER tools represent pointers as a pair. The first member of the pair is the <em>object</em> the pointer points to, and the second is the offset within the object.</p>
<p>In C, objects are simply continuous fragments of memory (this definition of “object” is not to be confused with the use of the term in object-oriented programming). Variables of any type are guaranteed to be stored as one object, irrespective of their type. As an example, all members of a struct or array belong to the same object. CPROVER simply assigns a number to each active object. The object number of a pointer <code>p</code> can be extracted using the expression <code>__CPROVER_POINTER_OBJECT(p)</code>. As a consequence, pointers to different objects are always different, which is not sound.</p>
<p>The offset (the second member of the pair that forms a pointer) is relative to the beginning of the object; it uses byte granularity. As an example, the code fragment:</p>
<div class="fragment"><div class="line">unsigned array[10];</div>
<div class="line">char *p;</div>
<div class="line"> </div>
<div class="line">p=(char *)(array+1);</div>
<div class="line">p++;</div>
</div><!-- fragment --><p>will result in a pointer with offset 5. The offset of a pointer <code>p</code> can be extracted using the expression <code>__CPROVER_POINTER_OFFSET(p)</code>.</p>
<h3><a class="anchor" id="dereferencing-pointers"></a>
Dereferencing Pointers</h3>
<p>The CPROVER tools require that pointers that are dereferenced point to a valid object. Assertions that check this requirement can be generated using the option –pointer-check and, if desired, –bounds-check. These options will ensure that NULL pointers are not dereferenced, and that dynamically allocated objects have not yet been deallocated.</p>
<p>Furthermore, the CPROVER tools check that dynamically allocated memory is not deallocated twice. The goto-instrument tool is also able to add checks for memory leaks, that is, it detects dynamically allocated objects that are not deallocated once the program terminates.</p>
<p>The CPROVER tools support pointer typecasts. Most casts are supported, with the following exceptions:</p>
<ol type="1">
<li>Pointers can only be accessed using a pointer type. The conversion of a pointer into an integer type using a pointer typecast is not supported.</li>
<li>Casts from integers to pointers yield a pointer that is either NULL (if the integer is zero) or that point into a special array for modeling <a href="http://en.wikipedia.org/wiki/Memory-mapped_I/O">memory-mapped I/O</a>. Such pointers are assumed not to overlap with any other objects. This is, of course, only sound if a corresponding range check is instrumented.</li>
<li>Accesses to arrays via pointers that have the array subtype need to be well-aligned.</li>
</ol>
<h3><a class="anchor" id="pointers-in-open-programs"></a>
Pointers in Open Programs</h3>
<p>It is frequently desired to validate an open program (a fragment of a program). Some variables are left undefined. When an undefined pointer is dereferenced, CBMC assumes that the pointer points to a separate object of appropriate type with unbounded size. The object is assumed not to alias with any other object. This assumption may obviously be wrong in specific extensions of the program.</p>
<p>Last modified: 2022-11-10 00:29:31 +0000 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
