<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: cbmc-unwinding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">cbmc-unwinding </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h2><a class="anchor" id="understanding-loop-unwinding"></a>
Understanding Loop Unwinding</h2>
<h3><a class="anchor" id="iteration-based-unwinding"></a>
Iteration-based Unwinding</h3>
<p>The basic idea of CBMC is to model a programâ€™s execution up to a bounded number of steps. Technically, this is achieved by a process that essentially amounts to <em>unwinding loops</em>. This concept is best illustrated with a generic example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="keywordflow">while</span>(cond) {</div>
<div class="line">    BODY CODE</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>A BMC instance that will find bugs with up to five iterations of the loop would contain five copies of the loop body, and essentially corresponds to checking the following loop-free program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="keywordflow">if</span>(cond) {</div>
<div class="line">    BODY CODE COPY 1</div>
<div class="line">    <span class="keywordflow">if</span>(cond) {</div>
<div class="line">      BODY CODE COPY 2</div>
<div class="line">      <span class="keywordflow">if</span>(cond) {</div>
<div class="line">        BODY CODE COPY 3</div>
<div class="line">        <span class="keywordflow">if</span>(cond) {</div>
<div class="line">          BODY CODE COPY 4</div>
<div class="line">          <span class="keywordflow">if</span>(cond) {</div>
<div class="line">            BODY CODE COPY 5</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the use of the <code>if</code> statement to prevent the execution of the loop body in the case that the loop ends before five iterations are executed. The construction above is meant to produce a program that is trace equivalent with the original programs for those traces that contain up to five iterations of the loop.</p>
<p>In many cases, CBMC is able to determine automatically an upper bound on the number of loop iterations. This may even work when the number of loop unwindings is not constant. Consider the following example:</p>
<div class="fragment"><div class="line">_Bool f();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;100; i++) {</div>
<div class="line">    <span class="keywordflow">if</span>(f()) <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  assert(0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The loop in the program above has an obvious upper bound on the number of iterations, but note that the loop may abort prematurely depending on the value that is returned by <code>f()</code>. CBMC is nevertheless able to automatically unwind the loop to completion.</p>
<p>This automatic detection of the unwinding bound may fail if the number of loop iterations is highly data-dependent. Furthermore, the number of iterations that are executed by any given loop may be too large or may simply be unbounded. For this case, CBMC offers the command-line option <code>--unwind B</code>, where <code>B</code> denotes a number that corresponds to the maximal number of loop unwindings CBMC performs on any loop.</p>
<p>Note that the number of unwindings is measured by counting the number of <em>backjumps</em>. In the example above, note that the condition <code>i&lt;100</code> is in fact evaluated 101 times before the loop terminates. Thus, the loop requires a limit of 101, and not 100.</p>
<h3><a class="anchor" id="setting-separate-unwinding-limits"></a>
Setting Separate Unwinding Limits</h3>
<p>The setting given with <code>--unwind</code> is used globally, that is, for all loops in the program. In order to set individual limits for the loops, first use: </p><pre class="fragment">--show-loops
</pre><p> to obtain a list of all loops in the program. Then identify the loops you need to set a separate bound for, and note their loop ID. Then use: </p><pre class="fragment">--unwindset [T:]L:B
</pre><p> where <code>L</code> denotes a loop ID and <code>B</code> denotes the bound for that loop in thread T, if a thread number is included. The initial thread has index 0, and threads are consecutively numbered in program order of threads being spawned. The <code>--unwindset</code> option can be given multiple times.</p>
<p>As an example, consider a program with two loops in the function main: </p><pre class="fragment">--unwindset main.0:10 --unwindset main.1:20
</pre><p> This sets a bound of 10 for the first loop, and a bound of 20 for the second loop.</p>
<p>What if the number of unwindings specified is too small? In this case, bugs that require paths that are deeper may be missed. In order to address this problem, CBMC can optionally insert checks that the given unwinding bound is actually sufficiently large. These checks are called <em>unwinding assertions</em>, and are enabled with the option <code>--unwinding-assertions</code>. Continuing the generic example above, this unwinding assertion for a bound of five corresponds to checking the following loop-free program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="keywordflow">if</span>(cond) {</div>
<div class="line">    BODY CODE COPY 1</div>
<div class="line">    <span class="keywordflow">if</span>(cond) {</div>
<div class="line">      BODY CODE COPY 2</div>
<div class="line">      <span class="keywordflow">if</span>(cond) {</div>
<div class="line">        BODY CODE COPY 3</div>
<div class="line">        <span class="keywordflow">if</span>(cond) {</div>
<div class="line">          BODY CODE COPY 4</div>
<div class="line">          <span class="keywordflow">if</span>(cond) {</div>
<div class="line">            BODY CODE COPY 5</div>
<div class="line">            assert(!cond);</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The unwinding assertions can be verified just like any other generated assertion. If all of them are proven to hold, the given loop bounds are sufficient for the program. This establishes a <a href="http://en.wikipedia.org/wiki/Worst-case_execution_time">high-level worst-case execution time</a> (WCET).</p>
<p>In some cases, it is desirable to cut off very deep loops in favor of code that follows the loop. As an example, consider this program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;10000; i++) {</div>
<div class="line">    BODY CODE</div>
<div class="line">  }</div>
<div class="line">  assert(0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the example above, small values of <code>--unwind</code> will prevent that the assertion is reached. If the code in the loop is considered irrelevant to the later assertion, use the option </p><pre class="fragment">--partial-loops
</pre><p> This option will allow paths that execute loops only partially, enabling a counterexample for the assertion above even for small unwinding bounds. The disadvantage of using this option is that the resulting path may be spurious, that is, it may not exist in the original program. If <code>--unwinding-assertions</code> is also used, and the particular counterexample trace does not include a report of a violated unwinding assertion, then that counterexample is not impacted by insufficient loop unwinding.</p>
<h3><a class="anchor" id="depth-based-unwinding"></a>
Depth-based Unwinding</h3>
<p>The loop-based unwinding bound is not always appropriate. In particular, it is often difficult to control the size of the generated formula when using the <code>--unwind</code> option. The option: </p><pre class="fragment">--depth nr
</pre><p> specifies an unwinding bound in terms of the number of instructions that are executed on a given path, irrespective of the number of loop iterations. Note that CBMC uses the number of instructions in the control-flow graph as the criterion, not the number of instructions in the source code.</p>
<p>Last modified: 2024-06-14 10:36:00 +0200 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
