<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: contracts-assigns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">contracts-assigns </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="assigns-clause"></a>
Assigns Clause</h1>
<h2><a class="anchor" id="in-function-contracts"></a>
In Function Contracts</h2>
<h3><a class="anchor" id="syntax"></a>
Syntax</h3>
<div class="fragment"><div class="line">__CPROVER_assigns(*identifier*, ...)</div>
</div><!-- fragment --><p>An <em>assigns</em> clause allows the user to specify that a memory location may be written by a function. The set of locations writable by a function is the union of the locations specified by the assigns clauses, or the empty set of no <em>assigns</em> clause is specified. While, in general, an <em>assigns</em> clause could be interpreted with either <em>writes</em> or <em>modifies</em> semantics, this design is based on the former. This means that memory not captured by an <em>assigns</em> clause must not be written within the given function, even if the value(s) therein are not modified.</p>
<h3><a class="anchor" id="object-slice-expressions"></a>
Object slice expressions</h3>
<p>The following functions can be used in assigns clause to specify ranges of assignable addresses.</p>
<p>Given a pointer <code>ptr</code> pointing into some object <code>o</code>, <code>__CPROVER_object_from(ptr)</code> specifies that all bytes starting from the given pointer and until the end of the object are assignable:</p>
<div class="fragment"><div class="line">__CPROVER_size_t __CPROVER_object_from(void *ptr); </div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object <code>o</code>, <code>__CPROVER_object_from(ptr, size)</code> specifies that <code>size</code> bytes starting from the given pointer and until the end of the object are assignable. The <code>size</code> value must such that <code>size &lt;= __CPROVER_object_size(ptr) - __CPROVER_pointer_offset(ptr)</code> holds:</p>
<div class="fragment"><div class="line">__CPROVER_size_t __CPROVER_object_slice(void *ptr, __CPROVER_size_t size);</div>
</div><!-- fragment --><p>Caveats and limitations: The slices in question must <em>not</em> be interpreted as pointers by the program. During call-by-contract replacement, <code>__CPROVER_havoc_slice(ptr, size)</code> is used to havoc these targets, and <code>__CPROVER_havoc_slice</code> does not support havocing pointers. ### Parameters</p>
<p>An <em>assigns</em> clause currently supports simple variable types and their pointers, structs, and arrays. Recursive pointer structures are left to future work, as their support would require changes to CBMCâ€™s memory model.</p>
<div class="fragment"><div class="line">/* Examples */</div>
<div class="line">int err_signal; // Global variable</div>
<div class="line"> </div>
<div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line"> </div>
<div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">__CPROVER_assigns(err_signal)</div>
<div class="line"> </div>
<div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">__CPROVER_assigns(*out, err_signal)</div>
</div><!-- fragment --><h3><a class="anchor" id="semantics"></a>
Semantics</h3>
<p>The semantics of an <em>assigns</em> clause of a given function can be understood in two contexts: enforcement and replacement.</p>
<h4><a class="anchor" id="enforcement"></a>
Enforcement</h4>
<p>In order to determine whether an <em>assigns</em> clause is a sound abstraction of the write set of a function <em>f</em>, the body of the function is instrumented with assertion statements before each statement which may write to memory (e.g., an assignment). These assertions are based on the writable locations identified by the <em>assigns</em> clauses.</p>
<p>For example, consider the following implementation of <code>sum</code> function.</p>
<div class="fragment"><div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">/* Writable Set */</div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Assignable variables in the function are just those specified so with <code>__CPROVER_assigns</code>, together with any local variables. In the case of <code>sum</code> that is <code>*out</code> and <code>result</code>. Each assignment will be instrumented with an assertion to check that the target of the assignment is one of those options.</p>
<div class="fragment"><div class="line">int __CPROVER_contracts_original_sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result;</div>
<div class="line">  __CPROVER_assert((__CPROVER_POINTER_OBJECT(&amp;result) == __CPROVER_POINTER_OBJECT(out)  &amp;&amp;</div>
<div class="line">                    __CPROVER_POINTER_OFFSET(&amp;result) == __CPROVER_POINTER_OFFSET(out)) ||</div>
<div class="line">                   (__CPROVER_POINTER_OBJECT(&amp;result) == __CPROVER_POINTER_OBJECT(&amp;result)  &amp;&amp;</div>
<div class="line">                    __CPROVER_POINTER_OFFSET(&amp;result) == __CPROVER_POINTER_OFFSET(&amp;result))</div>
<div class="line">                   , &quot;Check that result is assignable&quot;);</div>
<div class="line">  result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  __CPROVER_assert((__CPROVER_POINTER_OBJECT(out) == __CPROVER_POINTER_OBJECT(out)  &amp;&amp;</div>
<div class="line">                     __CPROVER_POINTER_OFFSET(out) == __CPROVER_POINTER_OFFSET(out)) ||</div>
<div class="line">                    (__CPROVER_POINTER_OBJECT(out) == __CPROVER_POINTER_OBJECT(&amp;result)  &amp;&amp;</div>
<div class="line">                     __CPROVER_POINTER_OFFSET(out) == __CPROVER_POINTER_OFFSET(&amp;result))</div>
<div class="line">                    , &quot;Check that result is assignable&quot;);</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/* Function Contract Enforcement */</div>
<div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  int return_value_sum = __CPROVER_contracts_original_sum(a, b, out);</div>
<div class="line">  return return_value_sum;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Additionally, the set of assignable target expressions is updated while traversing the function body when new memory is allocated. For example, the statement <code>x = (int *)malloc(sizeof(int))</code> would create a pointer, stored in <code>x</code>, to assignable memory. Since the memory is allocated within the current function, there is no way an assignment to this memory can affect the memory of the calling context. If memory is allocated for a struct, the subcomponents are considered assignable as well.</p>
<p>Finally, a set of freely-assignable symbols <em>free</em> is tracked during the traversal of the function body. These are locally-defined variables and formal parameters without dereferences. For example, in a variable declaration <code>&lt;type&gt; x = &lt;initial_value&gt;</code>, <code>x</code> would be added to the <em>free</em> set. Assignment statements where the left-hand-side is in the <em>free</em> set are not instrumented with the above assertions.</p>
<h4><a class="anchor" id="replacement"></a>
Replacement</h4>
<p>Assuming <em>assigns</em> clauses are a sound abstraction of the write set for a given function, CBMC will use the function contract in place of the function implementation as described by <a href="contracts-requires-and-ensures.md#replacement">Requires &amp; Ensures Clauses</a>, and it will add non-deterministic assignments for each object listed in the <code>__CPROVER_assigns</code> clause. Since these objects might be modified by the function, CBMC uses non-deterministic assignments to havoc them and restrict their values only by assuming the postconditions (i.e., ensures clauses).</p>
<p>In our example, consider that a function <code>foo</code> may call <code>sum</code>.</p>
<div class="fragment"><div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">/* Preconditions */</div>
<div class="line">__CPROVER_requires(__CPROVER_is_fresh(out, sizeof(*out)))</div>
<div class="line">/* Postconditions */</div>
<div class="line">__CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE)</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b)))</div>
<div class="line">/* Writable Set */</div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line">  int rval = sum(a, b, &amp;out);</div>
<div class="line">  if (rval == SUCCESS) </div>
<div class="line">    return out;</div>
<div class="line">  return rval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>CBMC will use the function contract in place of the function implementation wherever the function is called.</p>
<div class="fragment"><div class="line">int foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line">    </div>
<div class="line">  /* Function Contract Replacement */</div>
<div class="line">  /* Precondition */</div>
<div class="line">  __CPROVER_assert(__CPROVER_is_fresh(out, sizeof(*out)), &quot;Check requires clause&quot;);</div>
<div class="line">    </div>
<div class="line">  /* Writable Set */</div>
<div class="line">  *(&amp;out) = nondet_uint32_t();</div>
<div class="line">    </div>
<div class="line">  /* Postconditions */</div>
<div class="line">  int return_value_sum = nondet_int();</div>
<div class="line">  __CPROVER_assume(return_value_sum == SUCCESS || return_value_sum == FAILURE);</div>
<div class="line">  __CPROVER_assume((return_value_sum == SUCCESS) ==&gt; (*out == (a + b)));</div>
<div class="line"> </div>
<div class="line">  int rval = return_value_sum;</div>
<div class="line">  if (rval == SUCCESS) </div>
<div class="line">    return out;</div>
<div class="line">  return rval;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="in-loop-contracts"></a>
In Loop Contracts</h2>
<p>TODO: Document <code>__CPROVER_assigns</code> for loops.</p>
<p>Last modified: 2022-09-26 16:53:31 +0200 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
