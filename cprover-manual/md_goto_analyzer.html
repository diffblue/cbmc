<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: goto-analyzer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">goto-analyzer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="goto-analyzer"></a>
Goto Analyzer</h1>
<p><code>goto-analyzer</code> is an abstract interpreter which uses the same front-end and GOTO binary representation as CBMC. It is built along with CBMC, so <a class="el" href="md_installation.html">the installation instructions</a> are the same.</p>
<p>The key difference is that CBMC under-approximates the behaviour of the program (execution traces that are too long or require too many loop unwindings are not considered) while <code>goto-analyzer</code> over-approximates the behaviour of the program. CBMC can determine if a property is A. true for a bounded number of iterations or B. false and giving an error trace. In contrast <code>goto-analyzer</code> can determine if a property is A. true for all iterations or B. possibly false. In this sense, each tool has its own strengths and weaknesses.</p>
<p>To use <code>goto-analyzer</code> you need to give options for:</p>
<ul>
<li>What <a href="#task">task</a> to perform after the abstract interpreter has run.</li>
<li>How to format the <a href="#output">output</a>.</li>
<li>Which <a href="#abstractinterpreter">abstract interpreter</a> is used.</li>
<li>Which <a href="#domain">domain</a> is used to describe the state of the program at a point during execution.</li>
<li>How the <a href="#history">history</a> of the control flow of the program determines the number of points of execution.</li>
<li>The <a href="#storage">storage</a> that links points of execution and domains.</li>
</ul>
<h2><a class="anchor" id="quick-start"></a>
Quick Start</h2>
<p>As the space of configuration options is quite large and their interactions can sometimes be subtle and complex, here are some possible sets of options for a few common tasks.</p>
<p>I want to see if I can verify anything with <code>goto-analyzer</code>: </p><pre class="fragment">goto-analyzer --verify --recursive-interprocedural --vsd --vsd-values intervals --vsd-structs every-field --vsd-arrays smash --vsd-pointers value-set program.c
</pre><p> I want to make a big effort to verify things: </p><pre class="fragment">goto-analyzer  --verify --three-way-merge --vsd --vsd-values set-of-constants --vsd-structs every-field --vsd-arrays up-to-n-elements --vsd-pointers value-set --loop-unwinding-and-branching 17 --one-domain-per-history program.c
</pre><p> I want to discharge obvious conditions and remove unreachable code: </p><pre class="fragment">goto-analyzer --simplify out.gb --three-way-merge --vsd
</pre><p> I want to build a dependency graph: </p><pre class="fragment">goto-analyzer --show --dot depgraph.dot --dependence-graph-vs
</pre> <h2><a class="anchor" id="task"></a>
Task</h2>
<p><code>goto-analyzer</code> first runs the abstract interpreter until it reaches a fix-point, then it will perform the task the user has chosen.</p>
<p><code>--show</code> : Displays a domain for every instruction in the GOTO binary. The format and information will depend on the <a href="#domain">domain</a> that has been selected. If there are multiple domains corresponding to the same location (see <a href="#history">history</a> below) these will be merged before they are displayed.</p>
<p><code>--show-on-source</code> : The source code of the program is displayed line-by-line with the abstract domains corresponding to each location displayed between them. As the analysis is done at the level of instructions in the GOTO binary, some domains may not be displayed. Also if parts of the GOTO binary have been generated or manipulated by other tools, these may not be displayed as there is no corresponding source. <code>--show-on-source</code> is the more user-friendly output, but <code>--show</code> gives a better picture of exactly what is computed.</p>
<p><code>--verify</code> : Every property in the program is checked to see whether it is true (it always holds), unreachable, false if it is reachable (due to the over-approximate analysis, it is not clear if locations are reachable or if it is an over-approximation, so this is the best that can be achieved) or unknown. If there are multiple points of execution that reach the same location, each will be checked and the answers combined, with unknown taking precedence.</p>
<p><code>--simplify output_file.gb</code> : Produces a new version of the GOTO binary in which the program has been simplified using information from the abstract interpreter. The exact simplification will depend on the domain that is used but typically this might be replacing any expression that has a constant value. If this makes instructions unreachable (for example if <code>GOTO</code> can be shown to never be taken) they will be removed. Removal can be deactivated by passing <code>--no-simplify-slicing</code>. In the ideal world simplify would be idempotent (i.e.&#160;running it a second time would not simplify anything more than the first). However there are edge cases which are difficult or prohibitively expensive to handle in the domain which can result in a second (or more) runs giving simplification. Submitting bug reports for these is helpful but they may not be viable to fix.</p>
<p><code>--unreachable-instructions</code> : Lists which instructions have a domain which is bottom (i.e.&#160;unreachable). If <code>--function</code> has been used to set the program entry point then this can flag things like the <code>main</code> function as unreachable.</p>
<p><code>--unreachable-functions</code> : Similar to the previous option but reports which functions are definitely unreachable rather than just instructions.</p>
<p><code>--reachable-functions</code> : The negation of the previous option, reports which functions may be reachable. Note that because the analysis is over-approximate, it is possible this will mark functions as reachable when a more precise analysis (possibly using CBMC) will show that there are no execution traces that reach them.</p>
<h2><a class="anchor" id="output"></a>
Output</h2>
<p>These options control how the result of the task is output. The default is text to the standard output. In the case of tasks that produce goto-programs (<code>--simplify</code> for example), the output options only affect the logging and not the final form of the program.</p>
<p><code>--text file_name</code> : Writes the output as plain text to <code>file_name</code>.</p>
<p><code>--json file_name</code> : Writes the output as a JSON object to <code>file_name</code>.</p>
<p><code>--xml file_name</code> : Writes the output as XML to <code>file_name</code>. This is similar but not exactly the same as the XML that CBMC generates.</p>
<p><code>--dot file_name</code> : Writes the output in GraphViz’s DOT format to <code>file_name</code>. This is only supported by some domains and tasks (for example <code>--show --dependence-graph</code>).</p>
<h2><a class="anchor" id="abstract-interpreter"></a>
Abstract Interpreter</h2>
<p>These options control which abstract interpreter is used and how the analysis is performed. In principle this can significantly change the accuracy and performance of <code>goto-analyzer</code> but the current options are reasonably similar.</p>
<p>If <code>--verbosity</code> is set above <code>8</code> the abstract interpreter will log what it is doing. This is intended to aid developers in understanding how the algorithms work, where time is being spent, etc. but can be generally quite instructive.</p>
<p><code>--legacy-ait</code> : This is the default option. Abstract interpretation is performed eagerly from the start of the program until fixed-point is reached. Functions are analysed as needed and in the order of that they are reached. This option also fixes the History and Storage options to their defaults.</p>
<p><code>--legacy-concurrent</code> : This extends <code>--legacy-ait</code> with very restricted and special purpose handling of threads. This needs the domain to have certain unusual properties for it to give a correct answer. At the time of writing only <code>--dependence-graph</code> is compatible with it.</p>
<p><code>--recursive-interprocedural</code> : This extends <code>--legacy-ait</code> by allowing the History and Storage to be configured. As the name implies, function calls are handled by recursion within the interpreter. This is a good all-round choice and will likely become the default at some point in the future.</p>
<p><code>--three-way-merge</code> : This extends <code>--recursive-interprocedural</code> by performing a “modification aware” merge after function calls. At the time of writing only <code>--vsd</code> supports the necessary differential reasoning. If you are using <code>--vsd</code> this is recommended as it is more accurate with little extra cost.</p>
<h2><a class="anchor" id="domain"></a>
Domain</h2>
<p>One of the most important options; this controls how the possible states at a given execution point are represented and manipulated.</p>
<p><code>--constants</code> : The default option, this stores one constant value per variable. This means it is fast but will only find things that can be resolved by constant propagation. The domain has some handling of arrays but limited support for pointers which means that in can potentially give unsound behaviour. <code>--vsd --vsd-values constants</code> is probably a better choice for this kind of analysis.</p>
<p><code>--intervals</code> : A domain that stores an interval for each integer and float variable. At the time of writing not all operations are supported so the results can be quite over-approximate at points. It also has limitations in the handling of pointers so can give unsound results. <code>--vsd --vsd-values intervals</code> is probably a better choice for this kind of analysis.</p>
<p><code>--not-null</code> : This domain is intended to find which pointers are not null. Its implementation is very limited and it is not recommended.</p>
<p><code>--dependence-graph</code> : Tracks data flow and information flow dependencies between instructions and produces a graph. This includes doing points-to analysis and tracking reaching definitions (i.e.&#160;use-def chains). This is one of the most extensive, correct and feature complete domains.</p>
<p><code>--vsd</code> : This is the Variable Sensitivity Domain (VSD). It is a non-relational domain that stores an abstract object for each live variable. Which kind of abstract objects are used depends on the type of the variable and the run-time configuration. This means that sensitivity of the domain can be chosen – for example, do you want to track every element of an array independently, or just a few of them or simply ignore arrays all together. A set of options to configure VSD are given below. This domain is extensive and does not have any known architectural limits on correctness. As such it is a good choice for many kinds of analysis.</p>
<p><code>--dependence-graph-vs</code> : This is a variant of the dependence graph domain that uses VSD to do the foundational pointer and reaching definitions analysis. This means it can be configured using the VSD options and give more precise analysis (for example, field aware) of the dependencies.</p>
<h3><a class="anchor" id="configuration-of-the-variable-sensitivity-domain"></a>
Configuration of the Variable Sensitivity Domain</h3>
<p>VSD has a wide range of options that allow you to choose what kind of abstract objects (and thus abstractions) are used to represent variables of each type.</p>
<p><code>--vsd-values</code> : This controls the abstraction used for values, both <code>int</code> and <code>float</code>. The default option is <code>constants</code> which tracks if the variable has a constant value. This is fast but not very precise so it may well be unable to prove very much. <code>intervals</code> uses an interval that contains all of the possible values the variable can take. It is more precise than <code>constants</code> in all cases but a bit slower. It is good for numerical code. <code>set-of-constants</code> uses a set of up to 10 (currently fixed) constants. This is more general than using a single constant but can make analysis up to 10 times (or in rare cases 100 times) slower. It is good for control code with flags and modes.</p>
<p><code>--vsd-structs</code> : This controls how structures are handled. The default is <code>top-bottom</code> which uses an abstract object with just two states (top and bottom). In effect writes to structures are ignored and reads from them will always return top (any value). The other alternative is <code>every-field</code> which stores an abstract object for each field. Depending on how many structures are live at any one time and how many fields they have this may increase the amount of memory used by the analyser by a reasonable amount. But this means that the analysis will be “field-sensitive”.</p>
<p><code>--vsd-arrays</code> : This controls how arrays are handled. As with structures, the default is <code>top-bottom</code> which effectively ignores writes to the array and returns top on a read. More precise than this is <code>smash</code> which stores one abstract element for all of the values. This is relatively cheap but a lot more precise, particularly if used with <code>intervals</code> or <code>set-of-constants</code>. <code>up-to-n-elements</code> generalises <code>smash</code> by storing abstract objects for the first <code>n</code> elements of each array (<code>n</code> defaults to 10 and can be controlled by <code>--vsd-array-max-elements</code>) and then condensing all other elements down to a single abstract object. This allows reasonably fine-grained control over the amount of memory used and can give much more precise results for small arrays. <code>every-element</code> is the most precise, but most expensive option where an abstract element is stored for every entry in the array.</p>
<p><code>--vsd-pointers</code> : This controls the handling of pointers. The default, <code>top-bottom</code> effectively ignores pointers, this is OK if they are just read (all reads return top) but if they are written then there is the problem that we know that a variable is changed but we know don’t which one, so we have to set the whole domain to top. <code>constants</code> is somewhat misleadingly named as it uses an abstract object that tracks a pointer to a single variable. This includes the offset within the variable; a stack of field names for structs and abstract objects for offsets in arrays. Offsets are tracked even if the abstract object for the variable itself does not distinguish different fields or indexes. <code>value-set</code> is the most precise option; it stores a set of pointers to single variables as described above.</p>
<p><code>--vsd-unions</code> : At the time of writing there is only one option for unions which is <code>top-bottom</code>, discarding writes and returning top for all reads from a variable of union type.</p>
<p><code>--vsd-data-dependencies</code> : Wraps each abstract object with a set of locations where the variable was last modified. The set is reset when the variable is written and takes the union of the two sides’ sets on merge. This was originally intended for <code>--dependence-graph-vs</code> but has proved useful for <code>--vsd</code> as well. This is not strictly necessary for <code>--three-way-merge</code> as the mechanism it uses to work out which variables have changed is independent of this option.</p>
<p><code>--vsd-liveness</code> : Wraps each abstract object with the location of the last assignment or merge. This is more basic and limited than <code>--vsd-data-dependencies</code> and is intended to track SSA-like regions of variable liveness.</p>
<p><code>--vsd-flow-insensitive</code> : This does not alter the abstract objects used or their configuration. It disables the reduction of the domain when a branch is taken or an assumption is reached. This normally gives a small saving in time but at the cost of a large amount of precision. This is why the default is to do the reduction. It can be useful for debugging issues with the reduction.</p>
<h2><a class="anchor" id="history"></a>
History</h2>
<p>To over-approximate what a program does, it is necessary to consider all of the paths of execution through the program. As there are a potentially infinite set of traces (and they can be potentially infinitely long) it is necessary to merge some of them. The common approach (the “collecting abstraction”) is to merge all paths that reach the same instruction. The abstract interpretation is then done between instructions without thinking about execution paths. This ensures termination but means that it is not possible to distinguish different call sites, loop iterations or paths through a program.</p>
<p>Note that <code>--legacy-ait</code>, the default abstract interpreter fixes the history to <code>--ahistorical</code> so you will need to choose another abstract interpreter to make use of these options.</p>
<p>The history options select the abstraction of execution traces to use:</p>
<p><code>--ahistorical</code> : This is the default and the coarsest abstraction. No history information is kept, so all traces that reach an instruction are merged. This is the collecting abstraction that is used in most abstract interpreters.</p>
<p><code>--call-stack n</code> : This is an inter-procedural abstraction; it tracks the call stack and only merges traces that reach the same location and have the same call stack. The effect of this is equivalent to inlining all functions and then using <code>--ahistorical</code>. In larger programs this can be very expensive in terms of both time and memory but can give much more accurate results. Recursive functions create a challenge as the call stack will be different each time. To prevent non-termination, the parameter <code>n</code> limits how many times a loop of recursive functions can be called. When <code>n</code> is reached all later ones will be merged. Setting this to <code>0</code> will disable the limit.</p>
<p><code>--loop-unwind n</code> : This tracks the backwards jumps that are taken in the current function. Traces that reach the same location are merged if their history of backjumps is the same. At most <code>n</code> traces are kept for each location, after that they are merged regardless of whether their histories match. This gives a similar effect to unrolling the loops <code>n</code> times and then using <code>--ahistorical</code>. In the case of nested loops, the behaviour can be a little different to unrolling as the limit is the number of times a location is reached, so a loop with <code>x</code> iterations containing a loop with <code>y</code> iterations will require <code>n = x*y</code>. The time and memory taken by this option will rise (at worst) linearly in terms of <code>n</code>. If <code>n</code> is <code>0</code> then there is no limit. Be warned that if there are loops that can execute an unbounded number of iterations or if the domain is not sufficiently precise to identify the termination conditions then the analysis will not terminate.</p>
<p><code>--branching n</code> : This works in a similar way to <code>--loop-unwind</code> but tracking forwards jumps (<code>if</code>, <code>switch</code>, <code>goto</code>, etc.) rather than backwards ones. This gives per-path analysis but limiting the number of times each location is visited. There is not a direct form of program transformation that matches this but it is similar to the per-path analysis that symbolic execution does. The scalability and the risk of non-termination if <code>n</code> is <code>0</code> remain the same. Note that the goto-programs generated by various language front-ends have a conditional forwards jump to exit the loop if the condition fails at the start and an unconditional backwards jump at the end. This means that <code>--branching</code> can wind up distinguishing different loop iterations – “has not exited for the last 3 iterations” rather than “has jumped back to the top 3 times”.</p>
<p><code>--loop-unwind-and-branching n</code> : Again, this is similar to <code>--loop-unwind</code> but tracks both forwards and backwards jumps. This is only a very small amount more expensive than <code>--branching</code> and is probably the best option for detailed analysis of each function.</p>
<h2><a class="anchor" id="storage"></a>
Storage</h2>
<p>The histories described above are used to keep track of where in the computation needs to be explored. The most precise option is to keep one domain for every history but in some cases, to save memory and time, it may be desirable to share domains between histories. The storage options allow this kind of sharing.</p>
<p><code>--one-domain-per-location</code> : This is the default option. All histories that reach the same location will use the same domain. Setting this means that the results of other histories will be similar to setting <code>--ahistorical</code>. One difference is how and when widening occurs. <code>--one-domain-per-location --loop-unwind n</code> will wait until <code>n</code> iterations of a loop have been completed and then will start to widen.</p>
<p><code>--one-domain-per-history</code> : This is the best option to use if you are using a history other than <code>--ahistorical</code>. It stores one domain per history which can result in a significant increase in the amount of memory used.</p>
<h2><a class="anchor" id="other-options"></a>
Other Options</h2>
<p><code>goto-analyzer</code> supports a number of other options for the C/C++ frontend, the platform, displaying program representations and instrumentation. These all function exactly the same as CBMC does.</p>
<p>It also supports specific analyses which do not fit into the configurable scheme above. At the time of writing this is just <code>--taint</code> which performs a configurable taint analysis.</p>
<p>Last modified: 2024-06-18 22:16:32 +0200 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
