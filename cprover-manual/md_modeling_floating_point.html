<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: modeling-floating-point</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">modeling-floating-point </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h2><a class="anchor" id="floating-point"></a>
Floating Point</h2>
<p>The CPROVER tools support bit-accurate reasoning about IEEE-754 floating-point and fixed-point arithmetic. The C standard contains a number of areas of implementation-defined behavior with regard to floating-point arithmetic:</p>
<ul>
<li>CPROVER supports C99 Appendix F, and thus, the <code>__STD_IEC_559__</code> macro is defined. This means that the C <code>float</code> data type maps to IEEE 754 <code>binary32</code> and <code>double</code> maps to <code>binary64</code> and operations on them are as specified in IEEE 754.</li>
<li><code>long double</code> can be configured to be <code>binary64</code>, <code>binary128</code> (quad precision) or a 96 bit type with 15 exponent bits and 80 significant bits. The last is an approximation of Intel’s x87 extended precision double data type. As the C standard allows a implementations a fairly wide set of options for <code>long double</code>, it is best avoided for both portable code and bit-precise analysis. The default is to match the build architecture as closely as possible.</li>
<li>In CPROVER, floating-point expressions are evaluated at the ‘natural precision’ (the greatest of the arguments) and not at a higher precision. This corresponds to <code>FLT_EVAL_METHOD</code> set to <code>0</code>. Note that this is a different policy to some platforms (see below).</li>
<li>Expression contraction (for example, converting <code>x * y + c</code> to <code>fma(x,y,c)</code>) is not performed. In effect, the <code>FP_CONTRACT</code> pragma is always off.</li>
<li>Constant expressions are evaluated at `run’ time wherever possible and so will respect changes in the rounding mode. In effect, the <code>FENV_ACCESS</code> pragma is always off. Note that floating point constants are treated as doubles (unless they are followed by <code>f</code> when they are float) as specified in the C standard. <code>goto-cc</code> supports <code>-fsingle-precision-constant</code>, which allows the (non-standard) treatment of constants as floats.</li>
<li>Casts from int to float and float to float make use of the current rounding mode. Note that the standard requires that casts from float to int use round-to-zero (that is, truncation).</li>
</ul>
<h3><a class="anchor" id="x86-and-other-platform-specific-issues"></a>
x86 and Other Platform-specific Issues</h3>
<p>Not all platforms have the same implementation-defined behavior as CPROVER. This can cause mismatches between the verification environment and the execution environment. If this occurs, check the compiler manual for the choices listed above. There are two common cases that can cause these problems: 32-bit x86 code and the use of unsafe optimisations.</p>
<p>Many compilers that target 32-bit x86 platforms employ a different evaluation method. The extended precision format of the x87 unit is used for all computations regardless of their native precision. Most of the time, this results in more accurate results and avoids edge cases. However, it can result in some obscure and difficult to debug behaviour. Checking if the <code>FLT_EVAL_METHOD</code> macro is non-zero (for these platforms it will typically be 2), should warn of these problems. Changing the compiler flags to use the SSE registers will resolve many of them, give a more standards-compliant platform and will likely perform better. Thus it is <em>highly</em> recommended. Use <code>-msse2 -mfpmath=sse</code> to enable this option for GCC. Visual C++ does not have an option to force the exclusive use of SSE instructions, but <code>/arch:SSE2</code> will pick SSE instructions “when it [the compiler] determines that it is faster to use the SSE/SSE2 instructions” and is thus better than <code>/arch:IA32</code>, which exclusively uses the x87 unit.</p>
<p>The other common cause of discrepancy between CPROVER results and the actual platform are the use of unsafe optimizations. Some higher optimisation levels enable transformations that are unsound with respect to the IEEE-754 standard. Consult the compiler manual and disable any optimizations that are described as unsafe (for example, the GCC options <code>-ffast-math</code>). The options <code>-ffp-contract=off</code> (which replaces <code>-mno-fused-madd</code>), <code>-frounding-math</code> and <code>-fsignaling-nans</code> are needed for GCC to be strictly compliant with IEEE-754.</p>
<h3><a class="anchor" id="rounding-mode"></a>
Rounding Mode</h3>
<p>CPROVER supports the four rounding modes given by IEEE-754 1985; round to nearest (ties to even), round up, round down, and round towards zero. By default, round to nearest is used. However, command line options (<code>--round-to-zero</code>, and so on) can be used to override this. If more control is needed, CPROVER has models of <code>fesetround</code> (for POSIX systems) and <code>_controlfp</code> (for Windows), which can be used to change the rounding mode during program execution. Furthermore, the inline assembly commands fstcw/fnstcw/fldcw (on x86) can be used.</p>
<p>The rounding mode is stored in the (thread local) variable <code>__CPROVER_rounding_mode</code>, but users are strongly advised not to use this directly.</p>
<h3><a class="anchor" id="math-library"></a>
Math Library</h3>
<p>CPROVER implements some of <code>math.h</code>, including <code>fabs</code>, <code>fpclassify</code>, and <code>signbit</code>. It has very limited support for elementary functions. Care must be taken when verifying properties that are dependent on these functions as the accuracy of implementations can vary considerably. The C compilers can (and many do) say that the accuracy of these functions is unknown.</p>
<h3><a class="anchor" id="fixed-point-arithmetic"></a>
Fixed-point Arithmetic</h3>
<p>CPROVER also has support for fixed-point types. The <code>--fixedbv</code> flag switches <code>float</code>, <code>double</code>, and <code>long double</code> to fixed-point types. The length of these types is platform specific. The upper half of each type is the integer component and the lower half is the fractional part.</p>
<p>Last modified: 2024-06-17 13:48:38 +0200 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
