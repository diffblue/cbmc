<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: memory-primitives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">memory-primitives </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<p>This document describes the semantics and usage of memory-related and pointer-related primitives in CBMC.</p>
<h2><a class="anchor" id="background"></a>
Background</h2>
<h3><a class="anchor" id="memory-and-pointers-in-cbmc"></a>
Memory and pointers in CBMC</h3>
<p>When CBMC analyzes a program, by default it uses the architectural parameters of the platform it is running on. That is, on a 64-bit system, CBMC will treat pointers as having 64 bits. This can be changed by various options (see section “C/C++ frontend options” in the output of <code>cbmc --help</code>).</p>
<p>Memory is represented in CBMC as a set of objects. Each object represents a contiguous sequence of bytes and is identified via a numeric object ID. For example, assuming integers of width 4 and chars of width 1, a global integer variable would correspond to an object of size 4, and memory allocated via <code>malloc(10)</code> would correspond to an object of size 10.</p>
<p>A pointer then consists of two parts: the upper n bits form the object ID, and the remaining bits form the offset. The object ID part holds the ID of the object the pointer is pointing to, and the offset part holds the byte offset within that object. The offset is signed.<sup>1</sup> The null pointer is the pointer with object ID 0 and offset 0. CBMC uses 8 bits by default to represent the object ID. This can be changed via the <code>--object-bits &lt;n&gt;</code> option.</p>
<p>There are three primitives which directly operate on the value of a pointer:</p>
<ul>
<li><code>__CPROVER_size_t __CPROVER_POINTER_OBJECT(const void *p)</code></li>
<li><code>__CPROVER_ssize_t __CPROVER_POINTER_OFFSET(const void *p)</code></li>
<li><code>_Bool __CPROVER_same_object(const void *p, const void *q)</code></li>
</ul>
<p>The primitive <code>__CPROVER_POINTER_OBJECT(p)</code> retrieves the object ID part of a pointer, and the primitive <code>__CPROVER_POINTER_OFFSET(p)</code> retrieves the offset part of a pointer. The <code>__CPROVER_same_object(p, q)</code> primitive simply compares the object IDs of the two given pointers. That is, it is true if and only if <code>__CPROVER_POINTER_OBJECT(p) == __CPROVER_POINTER_OBJECT(q)</code>. It is always valid to apply these three primitives to a pointer (i.e., they do not have any special preconditions).</p>
<h3><a class="anchor" id="memory-objects"></a>
Memory Objects</h3>
<p>Seeing that pointers consist of an object ID and an offset, it remains to describe how CBMC assigns object IDs to memory objects (such as local variables or malloced memory). CBMC deterministically assigns consecutive object IDs to memory objects as it encounters them. For example:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">char c;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> *p = &amp;c;         <span class="comment">// object ID n</span></div>
<div class="line"><span class="keywordtype">char</span> *q = malloc(10); <span class="comment">// object ID n + 1</span></div>
</div><!-- fragment --><p>Here the pointers <code>p</code> and <code>q</code> would contain consecutive IDs in their object ID parts (as retrieved by <code>__CPROVER_POINTER_OBJECT()</code>). Due to the deterministic assignment of object IDs, bugs that can only be exposed with specific pointer values cannot be found by CBMC. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *p = malloc(1); <span class="comment">// assume cbmc assigns object ID 0xE to the malloced memory</span></div>
<div class="line">assert(p != (<span class="keywordtype">char</span> *)0x0F00000000000000);</div>
</div><!-- fragment --><p>CBMC will report verification successful for this code snippet (assuming it assigns an object ID other than 0x0F to the malloced memory). However, assuming that <code>malloc()</code> could allocate memory at any address, the assertion could fail.</p>
<p>Moreover, CBMC does not reuse object IDs for malloced memory. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *p = malloc(1);</div>
<div class="line">free(p);</div>
<div class="line"><span class="keywordtype">char</span> *q = malloc(1);</div>
<div class="line">assert(p != q);</div>
</div><!-- fragment --><p>CBMC would report verification successful on this code snippet. However, assuming that <code>malloc()</code> could reuse deallocated addresses, the assertion could fail.</p>
<p>The memory objects in CBMC are independent of each other. That is, for example, when incrementing a pointer past the bounds of an object, the pointer will never point into another memory object (such as could happen when running on a real machine). To verify that pointers stay within the bounds of their pointees, the CBMC option <code>--pointer-overflow-check</code> can be used.</p>
<h4><a class="anchor" id="malloc-modelling"></a>
Malloc modelling</h4>
<p>CBMC ships a model of <code>malloc</code> that seeks to emulate the behaviour of the C standard library. This model is configurable to suit the assumptions the software under scrutiny may be making. One common assumption, matched by CBMC’s default configuration, is that dynamic memory allocation always succeeds and <code>malloc</code> never returns a <code>NULL</code> pointer. Code making such an assumption will look as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *p = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line">*p = 42; <span class="comment">// unconditional dereference, no check for p being NULL</span></div>
</div><!-- fragment --><p>This extends to the case of <code>malloc(0)</code>, and CBMC returns a valid pointer to an object. The size of that object is zero, implying that any attempt to read from or write to this object will result in an out-of-bounds access. The ensuing undefined behaviour can be detected by running CBMC with <code>--pointer-check</code>.</p>
<p>In an actual execution, however, memory allocation may fail for a number of reasons and <code>malloc</code> would return a NULL pointer. CBMC’s model can, therefore, also be configured to fail allocating memory when the requested allocation size is larger than representable under CBMC’s object-offset model (as described in <a href="#memory-and-pointers-in-cbmc">Memory and pointers in CBMC</a>), or even non-deterministically fail (for any size). Any such failure can either result in calls to <code>malloc</code> returning <code>NULL</code>, or reporting such a call as a failed property. The following command line options facilitate the above failure configurations:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flag   </th><th class="markdownTableHeadNone">Check    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--malloc-fail-null</code>   </td><td class="markdownTableBodyNone">return NULL when emulating an allocation failure    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--malloc-may-fail</code>   </td><td class="markdownTableBodyNone">non-deterministically fail to allocate   </td></tr>
</table>
<p>Note that the use of <code>--malloc-may-fail</code> also requires <code>--malloc-fail-null</code>. The following code example demonstrates the effect of these options:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> error = 0;</div>
<div class="line"><span class="keywordtype">int</span> *p = malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div>
<div class="line"><span class="keywordflow">if</span>(p != NULL)</div>
<div class="line">  *p = 42;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  error = 1;</div>
</div><!-- fragment --><p>Under CBMC’s default model of <code>malloc</code>, the <code>else</code> branch is unreachable. When running CBMC with <code>--malloc-fail-null --malloc-may-fail</code>, <code>p</code> would non-deterministically be set to <code>NULL</code>, making all branches in the above code reachable.</p>
<p>These malloc failure options need to be set when the C library model is added to the program. Typically this is upon invoking CBMC, but if the user has chosen to do so via goto-instrument (using <code>goto-instrument --add-library</code>), then the malloc failure mode needs to be specified with that <code>goto-instrument</code> invocation, i.e., as an option to <code>goto-instrument</code>.</p>
<h3><a class="anchor" id="uninitialized-pointers"></a>
Uninitialized pointers</h3>
<p>In verification tools, uninitialized variables are typically treated as having a nondeterministic value. Programs can thus be verified on a set of potential inputs. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line">__CPROVER_assume(i &lt; 0);</div>
<div class="line"><span class="keywordtype">int</span> result = rectify(i);</div>
<div class="line">assert(result == 0);</div>
</div><!-- fragment --><p>Here, the value of <code>i</code> is nondeterministically chosen from all the possible integer values, and then constrained to negative values via the assumption. In CBMC, like uninitialized integers, uninitialized pointers are treated as having a nondeterministic value. That is, the value of the pointer itself is nondeterministically chosen, though <b>no memory is allocated</b>. Therefore, pointers should be explicitely initialized to ensure that they are backed by valid memory.</p>
<h2><a class="anchor" id="memory-primitives"></a>
Memory Primitives</h2>
<p>In this section, we describe further memory primitives of CBMC. Above, we have already encountered the primitives <code>__CPROVER_POINTER_OBJECT(p)</code>, <code>__CPROVER_POINTER_OFFSET(p)</code>, and <code>__CPROVER_same_object(p, q)</code>. These primitives just retrieve the object ID part or offset part of a pointer, or compare the object ID parts of two pointers. It is always valid to apply these primitives to a pointer (i.e., they do not have any special preconditions).</p>
<p>In the following, we need the concept of a valid pointer. A pointer is <em>valid</em> if it points to a live memory object. That is, it points to the start or to somewhere within the sequence of bytes that makes up the memory object.</p>
<p>Conversely, a pointer is invalid if it is null, uninitialized, points to deallocated dynamic memory, points to an out-of-scope local variable, or has a value that does not point to (dynamically, automatically, or statically) allocated memory, or is out of bounds of the memory object it points to (i.e., the memory object identified by <code>__CPROVER_POINTER_OBJECT(p)</code>).</p>
<p>The primitives below have unspecified semantics on pointers that are neither null nor valid. CBMC has an option <code>--pointer-primitive-check</code> (see section <a href="#detecting-potential-misuses-of-memory-primitives">Detecting potential misuses of memory primitives</a> below) to check that pointers used in the primitives are either null or valid.</p>
<h3><a class="anchor" id="retrieving-the-size-of-a-memory-object"></a>
Retrieving the size of a memory object</h3>
<p>The following primitive can be used to retrieve the size of the memory object a pointer points to:</p>
<ul>
<li><code>__CPROVER_size_t __CPROVER_OBJECT_SIZE(const void *p)</code></li>
</ul>
<p>If <code>p</code> is the null pointer, the primitive returns 0. If <code>p</code> is valid, the primitive returns the size of the memory object the pointer points to. Otherwise, the semantics is unspecified. In particular, it is valid to apply this primitive to a pointer that points to within a memory object (i.e., not necessarily to the start). The result is the same as if the pointer would point to the start of the memory object (i.e., would have offset 0).</p>
<h3><a class="anchor" id="checking-if-a-pointer-points-to-dynamic-memory"></a>
Checking if a pointer points to dynamic memory</h3>
<p>The following primitive can be used to check whether a pointer points to dynamic (malloced, heap) memory:</p>
<ul>
<li><code>_Bool __CPROVER_DYNAMIC_OBJECT(const void *p)</code></li>
</ul>
<p>If <code>p</code> is the null pointer, the primitive returns false. If <code>p</code> is valid, the primitive returns true if the pointer points to dynamically allocated memory, and false otherwise. If <code>p</code> is neither null nor valid, the semantics is unspecified. Like <code>__CPROVER_OBJECT_SIZE()</code>, it is valid to apply the primitive to pointers that point to within a memory object.</p>
<h3><a class="anchor" id="checking-if-a-memory-segment-has-at-least-a-given-size"></a>
Checking if a memory segment has at least a given size</h3>
<p>The following two primitives can be used to check whether there is a memory segment starting at the given pointer and extending for at least the given number of bytes:</p>
<ul>
<li><code>_Bool __CPROVER_r_ok(const void *p, size_t size)</code></li>
<li><code>_Bool __CPROVER_w_ok(const void *p, size_t size)</code></li>
</ul>
<p>At present, both primitives are equivalent as all memory in CBMC is considered both readable and writeable. If <code>p</code> is the null pointer, the primitives return false. If <code>p</code> is valid, the primitives return true if the memory segment starting at the pointer has at least the given size, and false otherwise. If <code>p</code> is neither null nor valid, the semantics is unspecified. It is valid to apply the primitive to pointers that point to within a memory object. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> *p = malloc(10);</div>
<div class="line">assert(__CPROVER_r_ok(p, 10)); <span class="comment">// valid</span></div>
<div class="line">p += 5;</div>
<div class="line">assert(__CPROVER_r_ok(p, 3));  <span class="comment">// valid</span></div>
<div class="line">assert(__CPROVER_r_ok(p, 10)); <span class="comment">// fails</span></div>
</div><!-- fragment --><h2><a class="anchor" id="detecting-potential-misuses-of-memory-primitives"></a>
Detecting potential misuses of memory primitives</h2>
<p>As described above, the primitives listed in the Memory Primitives section require a pointer that is either null or valid to have well-defined semantics. CBMC has the option <code>--pointer-primitive-check</code> to detect potential misuses of the memory primitives. It checks that the pointers that appear in the following primitives are either null or valid:</p>
<ul>
<li><code>__CPROVER_OBJECT_SIZE</code></li>
<li><code>__CPROVER_DYNAMIC_OBJECT</code></li>
<li><code>__CPROVER_r_ok</code></li>
<li><code>__CPROVER_w_ok</code></li>
</ul>
<p>The following three primitives have well-defined semantics even on invalid pointers. Thus, they have been excluded from the <code>--pointer-primitive-check</code> option.</p>
<ul>
<li><code>__CPROVER_POINTER_OBJECT</code></li>
<li><code>__CPROVER_POINTER_OFFSET</code></li>
<li><code>__CPROVER_same_object</code></li>
</ul>
<p>Using them on invalid pointers, however, may still be unintended in user programs.</p>
<p><sup>1</sup> Pointers with negative offsets never point to memory objects. Negative values are used internally to detect pointer underflows.</p>
<p>Last modified: 2024-08-20 23:14:56 +0200 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
