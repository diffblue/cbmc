<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: test-suite</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">test-suite </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="test-suite-generation-with-cbmc"></a>
Test Suite Generation with CBMC</h1>
<h2><a class="anchor" id="a-small-tutorial-with-a-case-study"></a>
A Small Tutorial with a Case Study</h2>
<p>We assume that CBMC is installed on your system. If not, follow <a class="el" href="md_installation.html">these instructions</a>.</p>
<p>CBMC can be used to automatically generate test cases that satisfy a certain <a href="https://en.wikipedia.org/wiki/Code_coverage">code coverage</a> criteria. Common coverage criteria include branch coverage, condition coverage and <a href="https://en.wikipedia.org/wiki/Modified_condition/decision_coverage">Modified Condition/Decision Coverage (MC/DC)</a>. Among others, MC/DC is required by several avionics software development guidelines to ensure adequate testing of safety critical software. Briefly, in order to satisfy MC/DC, for every conditional statement containing boolean decisions, each Boolean variable should be evaluated one time to “true” and one time to “false”, in a way that affects the outcome of the decision.</p>
<p>In the following, we are going to demonstrate how to apply the test suite generation functionality in CBMC, by means of a case study. The following program is an excerpt from a real-time embedded benchmark <a href="https://www.irit.fr/recherches/ARCHI/MARCH/rubrique.php3?id_rubrique=97">PapaBench</a>, and implements part of a fly-by-wire autopilot for an Unmanned Aerial Vehicle (UAV). We have adjusted it slightly for our purposes.</p>
<p>The aim of function <code>climb_pid_run</code> is to control the vertical climb of the UAV. Details on the theory behind this operation are documented in the <a href="https://wiki.paparazziuav.org/wiki/Theory_of_Operation">wiki</a> for the Paparazzi UAV project. The behavior of this simple controller, supposing that the desired speed is 0.5 meters per second, is plotted in the figure below.</p>
<p><img src="https://github.com/diffblue/cbmc/raw/develop/doc/assets/pid.png" alt="The pid controller" title="The pid controller" class="inline"/> </p><pre class="fragment">01: // CONSTANTS:
02: #define MAX_CLIMB_SUM_ERR 10
03: #define MAX_CLIMB 1
04:
05: #define CLOCK 16
06: #define MAX_PPRZ (CLOCK*600)
07:
08: #define CLIMB_LEVEL_GAZ 0.31
09: #define CLIMB_GAZ_OF_CLIMB 0.75
10: #define CLIMB_PITCH_OF_VZ_PGAIN 0.05
11: #define CLIMB_PGAIN -0.03
12: #define CLIMB_IGAIN 0.1
13:
14: const float pitch_of_vz_pgain=CLIMB_PITCH_OF_VZ_PGAIN;
15: const float climb_pgain=CLIMB_PGAIN;
16: const float climb_igain=CLIMB_IGAIN;
17: const float nav_pitch=0;
18:
19: /** PID function INPUTS */
20: // The user input: target speed in vertical direction
21: float desired_climb;
22: // Vertical speed of the UAV detected by GPS sensor
23: float estimator_z_dot;
24:
25: /** PID function OUTPUTS */
26: float desired_gaz;
27: float desired_pitch;
28:
29: /** The state variable: accumulated error in the control */
30: float climb_sum_err=0;
31:
32: /** Computes desired_gaz and desired_pitch */
33: void climb_pid_run()
34: {
35:
36:   float err=estimator_z_dot-desired_climb;
37:
38:   float fgaz=climb_pgain*(err+climb_igain*climb_sum_err)+CLIMB_LEVEL_GAZ+CLIMB_GAZ_OF_CLIMB*desired_climb;
39:
40:   float pprz=fgaz*MAX_PPRZ;
41:   desired_gaz=((pprz&gt;=0 &amp;&amp; pprz&lt;=MAX_PPRZ) ? pprz : (pprz&gt;MAX_PPRZ ? MAX_PPRZ : 0));
42:
43:   /** pitch offset for climb */
44:   float pitch_of_vz=(desired_climb&gt;0) ? desired_climb*pitch_of_vz_pgain : 0;
45:   desired_pitch=nav_pitch+pitch_of_vz;
46:
47:   climb_sum_err=err+climb_sum_err;
48:   if (climb_sum_err&gt;MAX_CLIMB_SUM_ERR) climb_sum_err=MAX_CLIMB_SUM_ERR;
49:   if (climb_sum_err&lt;-MAX_CLIMB_SUM_ERR) climb_sum_err=-MAX_CLIMB_SUM_ERR;
50:
51: }
52:
53: int main()
54: {
55:
56:   while(1)
57:   {
58:     /** Non-deterministic input values */
59:     desired_climb=nondet_float();
60:     estimator_z_dot=nondet_float();
61:
62:     /** Range of input values */
63:     __CPROVER_assume(desired_climb&gt;=-MAX_CLIMB &amp;&amp; desired_climb&lt;=MAX_CLIMB);
64:     __CPROVER_assume(estimator_z_dot&gt;=-MAX_CLIMB &amp;&amp; estimator_z_dot&lt;=MAX_CLIMB);
65:
66:     __CPROVER_input("desired_climb", desired_climb);
67:     __CPROVER_input("estimator_z_dot", estimator_z_dot);
68:
69:     climb_pid_run();
70:
71:     __CPROVER_output("desired_gaz", desired_gaz);
72:     __CPROVER_output("desired_pitch", desired_pitch);
73:
74:   }
75:
76:   return 0;
77: }
</pre><p> To test the PID controller, we construct a main control loop, which repeatedly invokes the function <code>climb_pid_run</code> (line 69). This PID function has two input variables: the desired speed <code>desired_climb</code> and the estimated speed <code>estimated_z_dot</code>. In the beginning of each loop iteration, values of the inputs are assigned non-deterministically. Subsequently, the <code>__CPROVER_assume</code> statement in lines 63 and 64 guarantees that both values are bounded within a valid range. The <code>__CPROVER_input</code> and <code>__CPROVER_output</code> will help clarify the inputs and outputs of interest for generating test suites.</p>
<p>To demonstrate the automatic test suite generation in CBMC, we call the following command: </p><pre class="fragment">cbmc pid.c --cover mcdc --show-test-suite --unwind 6 --xml-ui
</pre><p> We’ll describe those command line options one by one. The option <code>--cover mcdc</code> specifies the code coverage criterion, and –show-test-suite requests that a test suite be printed. There are four conditional statements in the PID function: in lines 41, 44, 48, and 49. To satisfy MC/DC, the test suite has to meet multiple requirements. For instance, each conditional statement needs to evaluate to <em>true</em> and <em>false</em>. Consider the condition <code>"pprz&gt;=0 &amp;&amp; pprz&lt;=MAX_PPRZ"</code> in line 41. CBMC instruments three coverage goals to control the respective evaluated results of <code>"pprz&gt;=0"</code> and <code>"pprz&lt;=MAX_PPRZ"</code>. They satisfy the MC/DC rules. </p><pre class="fragment">!(pprz &gt;= (float)0) &amp;&amp; pprz &lt;= (float)(16 * 600)  id="climb_pid_run.coverage.1"
pprz &gt;= (float)0 &amp;&amp; !(pprz &lt;= (float)(16 * 600))  id="climb_pid_run.coverage.2"
pprz &gt;= (float)0 &amp;&amp; pprz &lt;= (float)(16 * 600)     id="climb_pid_run.coverage.3"
</pre><p> Note that <code>MAX_PPRZ</code> is defined as 16 * 600 in line 06 of the program.</p>
<p>The “id” of each coverage goal is automatically assigned by CBMC. For every coverage goal, a test suite (if there exists) that satisfies such a goal is printed out in XML format, as the parameter <code>--xml-ui</code> is given. Multiple coverage goals can share a test suite, when the corresponding execution of the program satisfies all these goals at the same time.</p>
<p>In the end, the following test suites are automatically generated for testing the PID controller. A test suite consists of a sequence of input parameters that are passed to the PID function <code>climb_pid_run</code> at each loop iteration. For example, Test 1 covers the MC/DC goal with id=“climb_pid_run.coverage.1”. The complete output from CBMC is in pid\_test\_suites.xml, where every test suite and the coverage goals it is for are clearly described. </p><pre class="fragment">Test suite:
Test 1.
  (iteration 1) desired_climb=-1.000000f, estimator_z_dot=1.000000f

Test 2.
  (iteration 1) desired_climb=-1.000000f, estimator_z_dot=1.000000f
  (iteration 2) desired_climb=1.000000f, estimator_z_dot=-1.000000f

Test 3.
  (iteration 1) desired_climb=0.000000f, estimator_z_dot=-1.000000f
  (iteration 2) desired_climb=1.000000f, estimator_z_dot=-1.000000f

Test 4.
  (iteration 1) desired_climb=1.000000f, estimator_z_dot=-1.000000f
  (iteration 2) desired_climb=1.000000f, estimator_z_dot=-1.000000f
  (iteration 3) desired_climb=1.000000f, estimator_z_dot=-1.000000f
  (iteration 4) desired_climb=1.000000f, estimator_z_dot=-1.000000f
  (iteration 5) desired_climb=0.000000f, estimator_z_dot=-1.000000f
  (iteration 6) desired_climb=1.000000f, estimator_z_dot=-1.000000f

Test 5.
  (iteration 1) desired_climb=-1.000000f, estimator_z_dot=1.000000f
  (iteration 2) desired_climb=-1.000000f, estimator_z_dot=1.000000f
  (iteration 3) desired_climb=-1.000000f, estimator_z_dot=1.000000f
  (iteration 4) desired_climb=-1.000000f, estimator_z_dot=1.000000f
  (iteration 5) desired_climb=-1.000000f, estimator_z_dot=1.000000f
  (iteration 6) desired_climb=-1.000000f, estimator_z_dot=1.000000f
</pre><p> The option <code>--unwind 6</code> unwinds the loop inside the main function body six times. To achieve complete coverage on all the instrumented goals in the PID function <code>climb_pid_run</code>, the loop must be unwound enough times. For example, <code>climb_pid_run</code> needs to be called at least six times for evaluating the condition <code>climb_sum_err&gt;MAX_CLIMB_SUM_ERR</code> in line 48 to <em>true</em>. This corresponds to Test 5. To learn more about loop unwinding take a look at <a class="el" href="md_cbmc_unwinding.html">Understanding Loop Unwinding</a>.</p>
<p>In this tutorial, we present the automatic test suite generation functionality of CBMC, by applying the MC/DC code coverage criterion to a PID controller case study. In addition to <code>--cover mcdc</code>, other coverage criteria such as <code>branch</code>, <code>decision</code>, and <code>path</code> are also available when calling CBMC.</p>
<h2><a class="anchor" id="coverage-criteria"></a>
Coverage Criteria</h2>
<p>The table below summarizes the coverage criteria that CBMC supports.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Criterion   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">assertion   </td><td class="markdownTableBodyNone">For every assertion, generate a test that reaches it    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">assume   </td><td class="markdownTableBodyNone">For every assume, generate tests before and after the assume statement to indicate coverage before and after it    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">location   </td><td class="markdownTableBodyNone">For every location, generate a test that reaches it    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">branch   </td><td class="markdownTableBodyNone">Generate a test for every branch outcome    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">decision   </td><td class="markdownTableBodyNone">Generate a test for both outcomes of every Boolean expression that is not an operand of a propositional connective    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">condition   </td><td class="markdownTableBodyNone">Generate a test for both outcomes of every Boolean expression    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mcdc   </td><td class="markdownTableBodyNone">Modified Condition/Decision Coverage (MC/DC)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">path   </td><td class="markdownTableBodyNone">Bounded path coverage    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cover   </td><td class="markdownTableBodyNone">Generate a test for every <code>__CPROVER_cover</code> statement   </td></tr>
</table>
<p>Last modified: 2024-08-07 00:46:44 -0700 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
