<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: SATABS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('satabs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SATABS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We document two programs that try to achieve formal guarantees of the absence of specific problems: CBMC and SATABS. The algorithms implemented by CBMC and SATABS are complementary, and often, one tool is able to solve a problem that the other cannot solve.</p>
<p>Both CBMC and SATABS are verification tools for ANSI-C/C++ programs. They verify array bounds (buffer overflows), pointer safety, exceptions and user-specified assertions. Both tools model integer arithmetic accurately, and are able to reason about machine-level artifacts such as integer overflow. CBMC and SATABS are therefore able to detect a class of bugs that has so far gone unnoticed by many other verification tools. This manual also covers some variants of CBMC, which includes HW-CBMC for <a href="http://www.cprover.org/cprover-manual/hwsw.html">hardware/software co-verification</a>.</p>
<h2><a class="anchor" id="autotoc_md209"></a>
Automatic Program Verification with SATABS</h2>
<p>In many cases, lightweight properties such as array bounds do not rely on the entire program. A large fraction of the program is <em>irrelevant</em> to the property. SATABS exploits this observation and computes an <em>abstraction</em> of the program in order to handle large amounts of code.</p>
<p>In order to use SATABS it is not necessary to understand the abstraction refinement process. For the interested reader, a high-level introduction to abstraction refinement is provided <a class="el" href="satabs.html#man_satabs-overview">here</a>. We also provide <a class="el" href="satabs.html#man_satabs-tutorials">tutorials on how to use SATABS</a>.</p>
<p>Just as CBMC, SATABS attempts to build counterexamples that refute the property. If such a counterexample is found, it is presented to the engineer to facilitate localization and repair of the program.</p>
<h2><a class="anchor" id="man_install-satabs"></a>
Installing SATABS</h2>
<h3><a class="anchor" id="autotoc_md210"></a>
Requirements</h3>
<p>SATABS is available for Windows, i86 Linux, and MacOS X. SATABS requires a code pre-processing environment including a suitable preprocessor and a set of header files.</p>
<ol type="1">
<li><b>Linux:</b> the preprocessor and the header files typically come with a package called <em>gcc</em>, which must be installed prior to the installation of SATABS.</li>
<li><b>Windows:</b> The Windows version of SATABS requires the preprocessor <code>cl.exe</code>, which is part of Visual Studio (including the free [Visual Studio Express](<a href="http://msdn.microsoft.com/vstudio/express/visualc/">http://msdn.microsoft.com/vstudio/express/visualc/</a>)).</li>
<li><b>MacOS:</b> Install Xcode command line tools: run <code>xcode-select --install</code> prior to installing SATABS.</li>
</ol>
<p>Important note for Windows users: Visual Studio's <code>cl.exe</code> relies on a complex set of environment variables to identify the target architecture and the directories that contain the header files. You must run SATABS from within the <em>Visual Studio Command Prompt</em>.</p>
<p>Note that the distribution files for the <a href="http://www.cprover.org/eclipse-plugin/">Eclipse plugin</a> include the command-line tools. Therefore, if you intend to run SATABS exclusively within Eclipse, you can skip the installation of the command-line tools. However, you still have to install the compiler environment as described above.</p>
<h3><a class="anchor" id="autotoc_md211"></a>
Choosing and Installing a Model Checker</h3>
<p>You need to install a Model Checker in order to be able to run SATABS. You can choose between following alternatives:</p>
<ul>
<li><b>Cadence SMV</b>. Available from <a href="http://www.kenmcmil.com/smv.html">http://www.kenmcmil.com/smv.html</a>. Cadence SMV is a commercial model checker. The free version that is available on the homepage above must not be used for commercial purposes (read the license agreement thoroughly before you download the tool). The documentation for SMV can be found in the directory where you unzip/untar SMV under ./smv/doc/smv/. Read the installation instructions carefully. The Linux/MacOS versions require setting environment variables. You must add add the directory containing the <code>smv</code> binary (located in ./smv/bin/, relative to the path where you unpacked it) to your <code>PATH</code> environment variable. SATABS uses Cadence SMV by default.</li>
<li><b>NuSMV</b>. Available from <a href="http://nusmv.irst.itc.it/">http://nusmv.irst.itc.it/</a>. NuSMV is the open source alternative to Cadence SMV. Installation instructions and documentation can be found on the NuSMV homepage. The directory containing the NuSMV binary should be added to your <code>PATH</code> environment variable. Use the option <pre class="fragment">--modelchecker nusmv
</pre> to instruct SATABS to use NuSMV.</li>
<li><b>BOPPO</b>. Available from <a href="http://www.cprover.org/boppo/">http://www.cprover.org/boppo/</a>. BOPPO is a model checker which uses SAT-solving algorithms. BOPPO relies on a built-in SAT solver and Quantor, a solver for quantified boolean formulas which is currently bundled with BOPPO, but also available separately from <a href="http://fmv.jku.at/quantor/">http://fmv.jku.at/quantor/</a>. We recommend to add the directories containing both tools to your <code>PATH</code> environment variable. Use the option <pre class="fragment">--modelchecker boppo
</pre> when you call SATABS and want it to use BOPPO instead of SMV.</li>
<li><b>BOOM</b>. Available from <a href="http://www.cprover.org/boom/">http://www.cprover.org/boom/</a>. Boom has a number of unique features, including the verification of programs with unbounded thread creation.</li>
</ul>
<h3><a class="anchor" id="autotoc_md212"></a>
Installing SATABS</h3>
<ol type="1">
<li>Download SATABS for your operating system. The binaries are available from <a href="http://www.cprover.org/satabs/">http://www.cprover.org/satabs/</a>.</li>
<li>Unzip/untar the archive into a directory of your choice. We recommend to add this directory to your <code>PATH</code> environment variable.</li>
</ol>
<p>Now you can execute SATABS. Try running SATABS on the small examples presented in the <a class="el" href="satabs.html#man_satabs-tutorials">SATABS tutorial</a>. If you use the Cadence SMV model checker, the only command line arguments you have to specify are the names of the files that contain your program.</p>
<h3><a class="anchor" id="autotoc_md213"></a>
Requirements</h3>
<p>We provide a graphical user interface to CBMC and SATABS, which is realized as a plugin to the Eclipse framework. Eclipse is available at <a href="http://www.eclipse.org">http://www.eclipse.org</a>. We do not provide installation instructions for Eclipse (basically, you only have to download the current version and extract the files to your hard-disk) and assume that you have already installed the current version.</p>
<p>CBMC and SATABS have their own requirements. As an example, both CBMC and SATABS require a suitable preprocessor and a set of header files. As first step, you should therefore follow the installation instructions for <a href="http://www.cprover.org/cprover-manual/installation-cbmc.html">CBMC</a> and <a href="http://www.cprover.org/cprover-manual/installation-satabs.html">SATABS</a>.</p>
<p>Important note for Windows users: Visual Studio's <code>cl.exe</code> relies on a complex set of environment variables to identify the target architecture and the directories that contain the header files. You must run Eclipse from within the <em>Visual Studio Command Prompt</em>.</p>
<h1><a class="anchor" id="man_satabs"></a>
SATABS—Predicate Abstraction with SAT</h1>
<h2><a class="anchor" id="man_satabs-overview"></a>
Overview</h2>
<p>This section describes SATABS from the point of view of the user. To learn about the technology implemented in SATABS, read <a class="el" href="satabs.html#man_satabs-background">this</a>.</p>
<p>We assume you have already installed SATABS and the necessary support files on your system. If not so, please follow <a class="el" href="satabs.html#man_install-satabs">these instructions</a>.</p>
<p>While users of SATABS almost never have to be concerned about the underlying refinement abstraction algorithms, understanding the classes of properties that can be verified is crucial. Predicate abstraction is most effective when applied to <em>control-flow dominated properties</em>. As an example, reconsider the following program (lock-example-fixed.c):</p>
<div class="fragment"><div class="line">_Bool nondet_bool();</div>
<div class="line">_Bool LOCK = 0;</div>
<div class="line"> </div>
<div class="line">_Bool lock() {</div>
<div class="line">  if(nondet_bool()) {</div>
<div class="line">    assert(!LOCK);</div>
<div class="line">    LOCK=1;</div>
<div class="line">    return 1; }</div>
<div class="line"> </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void unlock() {</div>
<div class="line">  assert(LOCK);</div>
<div class="line">  LOCK=0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  unsigned got_lock = 0;</div>
<div class="line">  int times;</div>
<div class="line"> </div>
<div class="line">  while(times &gt; 0) {</div>
<div class="line">    if(lock()) {</div>
<div class="line">      got_lock++;</div>
<div class="line">      /* critical section */</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if(got_lock!=0) {</div>
<div class="line">      unlock();</div>
<div class="line">      got_lock--;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    times--;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The two assertions in the program model that the functions <code>lock()</code> and <code>unlock()</code> are called in the right order. Note that the value of <code>times</code> is chosen non-deterministically and is not bounded. The program has no run-time bound, and thus, unwinding the code with CBMC will never terminate.</p>
<h3><a class="anchor" id="autotoc_md214"></a>
Working with Claims</h3>
<p>The two assertions will give rise to two <em>properties</em>. Each property is associated to a specific line of code, i.e., a property is violated when some condition can become false at the corresponding program location. SATABS will generate a list of all properties for the programs as follows: </p><pre class="fragment">satabs lock-example-fixed.c --show-properties
</pre><p> SATABS will list two properties; each property corresponds to one of the two assertions. We can use SATABS to verify both properties as follows: </p><pre class="fragment">satabs lock-example-fixed.c
</pre><p> SATABS will conclude the verification successfully, that is, both assertions hold for execution traces of any length.</p>
<p>By default, SATABS attempts to verify all properties at once. A single property can be verified (or refuted) by using the <code>--property id</code> option of SATABS, where <code>id</code> denotes the identifier of the property in the list obtained by calling SATABS with the <code>--show-properties</code> flag. Whenever a property is violated, SATABS reports a feasible path that leads to a state in which the condition that corresponds to the violated property evaluates to false.</p>
<h2><a class="anchor" id="man_satabs-libraries"></a>
Programs that use Libraries</h2>
<p>SATABS cannot check programs that use functions that are only available in binary (compiled) form (this restriction is not imposed by the verification algorithms that are used by SATABS – they also work on assembly code). The reason is simply that so far no assembly language frontend is available for SATABS. At the moment, (library) functions for which no C source code is available have to be replaced by stubs. The usage of stubs and harnesses (as known from unit testing) also allows to check more complicated properties (like, for example, whether function <code>fopen</code> is always called before <code>fclose</code>). This technique is explained in detail in the <a class="el" href="satabs.html#man_satabs-tutorials">SATABS tutorials</a>.</p>
<h2><a class="anchor" id="man_satabs-unit-test"></a>
Unit Testing with SATABS</h2>
<p>The example presented <a class="el" href="satabs.html#man_satabs-tutorial-driver">here</a> is obviously a toy example and can hardly be used to convince your project manager to use static verification in your next project. Even though we recommend to use formal verification and specification already in the early phases of your project, the sad truth is that in most projects verification (of any kind) is still pushed to the very end of the development cycle. Therefore, this section is dedicated to the verification of legacy code. However, the techniques presented here can also be used for <em>unit testing</em>.</p>
<p>Unit testing is used in most software development projects, and static verification with SATABS can be very well combined with this technique. Unit testing relies on a number test cases that yield the desired code coverage. Such test cases are implemented by a software testing engineer in terms of a test harness (aka test driver) and a set of function stubs. Typically, a slight modification to the test harness allows it to be used with SATABS. Replacing the explicit input values with non-deterministic inputs (as explained in <a class="el" href="satabs.html#man_satabs-tutorial-aeon">here</a> and <a class="el" href="satabs.html#man_satabs-tutorial-driver">here</a>)) guarantees that SATABS will try to achieve <b>full</b> path and state coverage (due to the fact that predicate abstraction implicitly detects equivalence classes). However, it is not guaranteed that SATABS terminates in all cases. Keep in mind that you must not make any assumptions about the validity of the properties if SATABS did not run to completion!</p>
<h3><a class="anchor" id="autotoc_md215"></a>
Further Reading</h3>
<ul>
<li><a href="http://www.kroening.com/publications/view-publications-wbwk2007.html">Model Checking Concurrent Linux Device Drivers</a></li>
<li><a href="http://www-2.cs.cmu.edu/~svc/papers/view-publications-cksy2005.html">SATABS: SAT-based Predicate Abstraction for ANSI-C</a></li>
<li><a href="http://www-2.cs.cmu.edu/~svc/papers/view-publications-cksy2004.html">Predicate Abstraction of ANSI-C Programs using SAT</a></li>
</ul>
<h2><a class="anchor" id="man_satabs-background"></a>
Background</h2>
<h3><a class="anchor" id="autotoc_md216"></a>
Sound Abstractions</h3>
<p>This section provides background information on how SATABS operates. Even for very trivial C programs it is impossible to exhaustively examine their state space (which is potentially unbounded). However, not all details in a C program necessarily contribute to a bug, so it may be sufficient to only examine those parts of the program that are somehow related to a bug.</p>
<p>In practice, many static verification tools (such as <code>lint</code>) try to achieve this goal by applying heuristics. This approach comes at a cost: bugs might be overlooked because the heuristics do not cover all relevant aspects of the program. Therefore, the conclusion that a program is correct whenever such a static verification tool is unable to find an error is invalid.</p>
<div class="image">
<img src="cegar-1.png" alt=""/>
<div class="caption">
CEGAR Loop</div></div>
<p>A more sophisticated approach that has been very successful recently is to generate a <em>sound</em> abstraction of the original program. In this context, <em>soundness</em> refers to the fact that the abstract program contains (at least) all relevant behaviors (i.e., bugs) that are present in the original program. In the Figure above, the first component strips details from the original program. The number of possible behaviors increases as the number of details in the abstract program decreases. Intuitively, the reason is that whenever the model checking tool lacks the information that is necessary to make an accurate decision on whether a branch of an control flow statement can be taken or not, both branches have to be considered.</p>
<p>In the resulting <em>abstract program</em>, a set of concrete states is subsumed by means of a single abstract state. Consider the following figure:</p>
<p><img src="states.png" alt="" class="inline"/></p>
<p>The concrete states <em>x</em>~1~ and <em>x</em>~2~ are mapped to an abstract state <em>X</em>, and similarly <em>Y</em> subsumes <em>y</em>~1~ and <em>y</em>~2~. However, all transitions that are possible in the concrete program are also possible in the abstract model. The abstract transition <em>X</em> → <em>Y</em> summarizes the concrete transitions <em>x</em>~1~ → <em>y</em>~1~ and <em>x</em>~1~ → <em>x</em>~1~, and <em>Y</em> → <em>X</em> corresponds to <em>x</em>~1~ → <em>x</em>~2~. The behavior <em>X</em> → <em>Y</em> → <em>X</em> is feasible in the original program, because it maps to <em>x</em>~1~ → <em>x</em>~1~ → <em>x</em>~2~. However, <em>Y</em> → <em>X</em> → <em>Y</em> is feasible only in the abstract model.</p>
<h3><a class="anchor" id="autotoc_md217"></a>
Spurious Counterexamples</h3>
<p>The consequence is that the model checker (component number two in the figure above) possibly reports a <em>spurious</em> counterexample. We call a counterexample spurious whenever it is feasible in the current abstract model but not in the original program. However, whenever the model checker is unable to find an execution trace that violates the given property, we can conclude that there is no such trace in the original program, either.</p>
<p>The feasibility of counterexamples is checked by <em>symbolic simulation</em> (performed by component three in the figure above). If the counterexample is indeed feasible, SATABS found a bug in the original program and reports it to the user.</p>
<h3><a class="anchor" id="autotoc_md218"></a>
Automatic Refinement</h3>
<p>On the other hand, infeasible counterexamples (that originate from abstract behaviors that result from the omission of details and are not present in the original program) are never reported to the user. Instead, the information is used in order to refine the abstraction such that the spurious counterexample is not part of the refined model anymore. For instance, the reason for the infeasibility of <em>Y</em> → <em>X</em> → <em>Y</em> is that neither <em>y</em>~1~ nor <em>x</em>~1~ can be reached from <em>x</em>~2~. Therefore, the abstraction can be refined by partitioning <em>X</em>.</p>
<p>The refinement steps can be illustrated as follows:</p>
<p><img src="refinement.png" alt="" class="inline" title="Iterative refinement"/></p>
<p>The first step (1) is to generate a very coarse abstraction with a very small state space. This abstraction is then successively refined (2, 3, ...) until either a feasible counterexample is found or the abstract program is detailed enough to show that there is no path that leads to a violation of the given property. The problem is that this point is not necessarily reached for every input program, i.e., it is possible that the the abstraction refinement loop never terminates. Therefore, SATABS allows to specify an upper bound for the number of iterations.</p>
<p>When this upper bound is reached and no counterexample was found, this does not necessarily mean that there is none. In this case, you cannot make any conclusions at all with respect to the correctness of the input program.</p>
<h2><a class="anchor" id="man_satabs-tutorials"></a>
Tutorials</h2>
<p>We provide an introduction to model checking "real" C programs with SATABS using two small examples.</p>
<h3><a class="anchor" id="man_satabs-tutorial-driver"></a>
Reference Counting in Linux Device Drivers</h3>
<p>Microsoft's <a href="http://research.microsoft.com/SLAM">SLAM</a> toolkit has been successfully used to find bugs in Windows device drivers. SLAM automatically verifies device driver whether a device driver adheres to a set of specifications. SLAM provides a test harness for device drivers that calls the device driver dispatch routines in a non-deterministic order. Therefore, the Model Checker examines all combinations of calls. Motivated by the success this approach, we provide a toy example based on Linux device drivers. For a more complete approach to the verification of Linux device drivers, consider <a href="http://www.cprover.org/ddverify/">DDVerify</a>.</p>
<p>Dynamically loadable modules enable the Linux Kernel to load device drivers on demand and to release them when they are not needed anymore. When a device driver is registered, the kernel provides a major number that is used to uniquely identify the device driver. The corresponding device can be accessed through special files in the filesystem; by convention, they are located in the <code>/dev</code> directory. If a process accesses a device file the kernel calls the corresponding <code>open</code>, <code>read</code> and <code>write</code> functions of the device driver. Since a driver must not be released by the kernel as long as it is used by at least one process, the device driver must maintain a usage counter (in more recent Linux kernels, this is done automatically, however, drivers that must maintain backward compatibility have to adjust this counter).</p>
<p>We provide a skeleton of such a driver. Download the files assets/spec.c, assets/driver.c, assets/driver.h, assets/kdev_t.h, and assets/modules.h.</p>
<p>The driver contains following functions:</p>
<ol type="1">
<li><code>register_chrdev</code>: (in assets/spec.c) Registers a character device. In our implementation, the function sets the variable <code>usecount</code> to zero and returns a major number for this device (a constant, if the user provides 0 as argument for the major number, and the value specified by the user otherwise). <pre class="fragment">int usecount;

int register_chrdev (unsigned int major, const char* name)
{
  usecount = 0;
  if (major == 0)
    return MAJOR_NUMBER;
  return major;
}
</pre></li>
<li><code>unregister_chrdev</code>: (in assets/spec.c) Unregisters a character device. This function asserts that the device is not used by any process anymore (we use the macro <code>MOD_IN_USE</code> to check this). <pre class="fragment">int unregister_chrdev (unsigned int major, const char* name)
{
  if (MOD_IN_USE)
    {
    ERROR: assert (0);
    }
  else
    return 0;
}
</pre></li>
<li><code>dummy_open</code>: (in assets/driver.c) This function increases the <code>usecount</code>. If the device is locked by some other process <code>dummy_open</code> returns -1. Otherwise it locks the device for the caller.</li>
<li><code>dummy_read</code>: (in assets/driver.c) This function "simulates" a read access to the device. In fact it does nothing, since we are currently not interested in the potential buffer overflow that may result from a call to this function. Note the usage of the function <code>nondet_int</code>: This is an internal SATABS-function that non­determi­nistically returns an arbitrary integer value. The function <code>__CPROVER_assume</code> tells SATABS to ignore all traces that do not adhere to the given assumption. Therefore, whenever the lock is held, <code>dummy_read</code> will return a value between 0 and <code>max</code>. If the lock is not held, then <code>dummy_read</code> returns -1.</li>
<li><code>dummy_release</code>: (in assets/driver.c) If the lock is held, then <code>dummy_release</code> decreases the <code>usecount</code>, releases the lock, and returns 0. Otherwise, the function returns -1.</li>
</ol>
<p>We now want to check if any <em>valid</em> sequence of calls of the dispatch functions (in driver.c) can lead to the violation of the assertion (in assets/spec.c). Obviously, a call to <code>dummy_open</code> that is immediately followed by a call to <code>unregister_chrdev</code> violates the assertion.</p>
<p>The function <code>main</code> in spec.c gives an example of how these functions are called. First, a character device "`dummy`" is registered. The major number is stored in the <code>inode</code> structure of the device. The values for the file structure are assigned non-deterministically. We rule out invalid sequences of calls by ensuring that no device is unregistered while it is still locked. We use the following model checking harness for calling the dispatching functions:</p>
<div class="fragment"><div class="line">random = nondet_uchar ();</div>
<div class="line">__CPROVER_assume (0 &lt;= random &amp;&amp; random &lt;= 3);</div>
<div class="line"> </div>
<div class="line">switch (random)</div>
<div class="line">{</div>
<div class="line">case 1:</div>
<div class="line">  rval = dummy_open (&amp;inode, &amp;my_file);</div>
<div class="line">  if (rval == 0)</div>
<div class="line">    lock_held = TRUE;</div>
<div class="line">  break;</div>
<div class="line">case 2:</div>
<div class="line">  __CPROVER_assume (lock_held);</div>
<div class="line">  count = dummy_read (&amp;my_file, buffer, BUF_SIZE);</div>
<div class="line">  break;</div>
<div class="line">case 3:</div>
<div class="line">  dummy_release (&amp;inode, &amp;my_file);</div>
<div class="line">  lock_held = FALSE;</div>
<div class="line">  break;</div>
<div class="line">default:</div>
<div class="line">  break;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The variable <code>random</code> is assigned non-deterministically. Subsequently, the value of <code>random</code> is restricted to be 0 ≤ <code>random</code> ≤ 3 by a call to <code>__CPROVER_assume</code>. Whenever the value of <code>random</code> is not in this interval, the corresponding execution trace is simply discarded by SATABS. Depending on the value of <code>random</code>, the harness calls either <code>dummy_open</code>, <code>dummy_read</code> or <code>dummy_close</code>. Therefore, if there is a sequence of calls to these three functions that leads to a violation of the assertion in <code>unregister_chrdev</code>, then SATABS will eventually consider it.</p>
<p>If we ask SATABS to show us the properties it verifies with </p><pre class="fragment">satabs driver.c spec.c --show-properties
</pre><p> for our example, we obtain</p>
<ol type="1">
<li>Claim unregister_chrdev.1:\ &#160;&#160;&#160;&#160;file spec.c line 18 function unregister_chrdev\ &#160;&#160;&#160;&#160;MOD_IN_USE in unregister_chrdev\ &#160;&#160;&#160;&#160;FALSE</li>
<li>Claim dummy_open.1:\ &#160;&#160;&#160;&#160;file driver.c line 15 function dummy_open\ &#160;&#160;&#160;&#160;i_rdev mismatch\ &#160;&#160;&#160;&#160;(unsigned int)inode-&gt;i_rdev &gt;&gt; 8 == (unsigned int)dummy_major</li>
</ol>
<p>It seems obvious that the property dummy_open.1 can never be violated. SATABS confirms this assumption: We call </p><pre class="fragment">satabs driver.c spec.c --property dummy_open.1
</pre><p> and SATABS reports <code>VERIFICATION SUCCESSFUL</code> after a few iterations.</p>
<p>If we try to verify property unregister_chrdev.1, SATABS reports that the property in line 18 in file spec.c is violated (i.e., the assertion does not hold, therefore the <code>VERIFICATION FAILED</code>). Furthermore, SATABS provides a detailed description of the problem in the form of a counterexample (i.e., an execution trace that violates the property). On this trace, <code>dummy_open</code> is called <b>twice</b>, leading to a <code>usecount</code> of 2. The second call of course fails with <code>rval=-1</code>, but the counter is increased nevertheless:</p>
<div class="fragment"><div class="line">int dummy_open (struct inode *inode, struct file *filp)</div>
<div class="line">{</div>
<div class="line">  __CPROVER_assert(MAJOR (inode-&gt;i_rdev) == dummy_major,</div>
<div class="line">      &quot;i_rdev mismatch&quot;);</div>
<div class="line">  MOD_INC_USE_COUNT;</div>
<div class="line"> </div>
<div class="line">  if (locked)</div>
<div class="line">    return -1;</div>
<div class="line">  locked = TRUE;</div>
<div class="line"> </div>
<div class="line">  return 0; /* success */</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then, <code>dummy_release</code> is called to release the lock on the device. Finally, the loop is left and the call to <code>unregister_chrdev</code> results in a violation of the assertion (since <code>usecount</code> is still 1, even though <code>locked=0</code>).</p>
<h3><a class="anchor" id="man_satabs-tutorial-aeon"></a>
Buffer Overflow in a Mail Transfer Agent</h3>
<p>We explain how to model check Aeon version 0.2a, a small mail transfer agent written by Piotr Benetkiewicz. The description advertises Aeon as a "*good choice for **hardened** or minimalistic boxes*". The sources are available <a href="http://www.cprover.org/satabs/examples/loop_detection/aeon-0.2a.tar.gz">here</a>.</p>
<p>Our first naive attempt to verify Aeon using </p><pre class="fragment">satabs *.c
</pre><p> produces a positive result, but also warns us that the property holds trivially. It also reveals that a large number library functions are missing: SATABS is unable to find the source code for library functions like <code>send</code>, <code>write</code> and <code>close</code>.</p>
<p>Now, do you have to provide a body for all missing library functions? There is no easy answer to this question, but a viable answer would be "most likely not". It is necessary to understand how SATABS handles functions without bodies: It simply assumes that such a function returns an arbitrary value, but that no other locations than the one on the left hand side of the assignment are changed. Obviously, there are cases in which this assumption is un­sound, since the function potentially modifies all memory locations that it can somehow address.</p>
<p>We now use static analysis to generate array bounds checks for Aeon: </p><pre class="fragment">satabs *.c --pointer-check --bounds-check --show-properties
</pre><p> SATABS will show about 300 properties in various functions (read <a href="http://www.cprover.org/cprover-manual/properties.html">this</a> for more information on the property instrumentation). Now consider the first few lines of the <code>main</code> function of Aeon: </p><pre class="fragment">int main(int argc, char **argv)
{
  char settings[MAX_SETTINGS][MAX_LEN];
  ...
  numSet = getConfig(settings);
  if (numSet == -1) {
    logEntry("Missing config file!");
    exit(1);
  }
  ...
</pre><p> and the function <code>getConfig</code> in <code>lib_aeon.c</code>: </p><pre class="fragment">int getConfig(char settings[MAX_SETTINGS][MAX_LEN])
{
    char home[MAX_LEN];
FILE *fp;   /* .rc file handler */
int numSet = 0;     /* number of settings */

strcpy(home, getenv("HOME"));       /* get home path */
strcat(home, "/.aeonrc");   /* full path to rc file */
fp = fopen(home, "r");
if (fp == NULL) return -1;  /* no cfg - ERROR */
  while (fgets(settings[numSet], MAX_LEN-1, fp)
    &amp;&amp; (numSet &lt; MAX_SETTINGS)) numSet++;
fclose(fp);

return numSet;
}
</pre><p> The function <code>getConfig</code> makes calls to <code>strcpy</code>, <code>strcat</code>, <code>getenv</code>, <code>fopen</code>, <code>fgets</code>, and <code>fclose</code>. It is very easy to provide an implementation for the functions from the string library (string.h), and SATABS comes with meaningful definitions for most of them. The definition of <code>getenv</code> is not so straight-forward. The man-page of <code>getenv</code> (which we obtain by entering <code>man 3 getenv</code> in a Unix or cygwin command prompt) tells us: </p><pre class="fragment">`` `getenv' `` searches the list of en­vi­ron­ment variable names
and values (using the global pointer `char **environ`) for a
variable whose name matches the string at `NAME`. If a variable name
matches, `getenv` returns a pointer to the associated value.
</pre><p> SATABS has no information whatsoever about the content of <code>environ</code>. Even if SATABS could access the environment variables on your computer, a successful verification of <code>Aeon</code> would then only guarantee that the properties for this program hold on your computer with a specific set of en­vi­ron­ment variables. We have to assume that <code>environ</code> contains en­vi­ron­ment variables that have an arbitrary content of arbitrary length. The content of en­vi­ron­ment variables is not only arbitrary but could be malefic, since it can be modified by the user. The approximation of the behavior of <code>getenv</code> that is shipped with SATABS completely ignores the content of the string.</p>
<p>Now let us have another look at the properties that SATABS generates for the models of the string library and for <code>getenv</code>. Most of these properties require that we verify that the upper and lower bounds of buffers or arrays are not violated. Let us look at one of the properties that SATABS generates for the code in function <code>getConfig</code>: </p><pre class="fragment">Claim getConfig.3:   file lib_aeon.c line 19 function getConfig   dereference failure: NULL plus offset pointer   !(SAME-OBJECT(src, NULL))`
</pre><p> The model of the function <code>strcpy</code> dereferences the pointer returned by <code>getenv</code>, which may return a NULL pointer. This possibility is detected by the static analysis, and thus a corresponding property is generated. Let us check this specific property: </p><pre class="fragment">satabs *.c --pointer-check --bounds-check --property getConfig.3
</pre><p> SATABS immediately returns a counterexample path that demonstrates how <code>getenv</code> returns a NULL, which is subsequently dereferenced. We have identified the first bug in this program: it requires that the environment variable HOME is set, and crashes otherwise.</p>
<p>Let us examine one more property in the same function: </p><pre class="fragment">Claim getConfig.7:   file lib_aeon.c line 19 function getConfig   dereference failure: array `home' upper bound   !(POINTER_OFFSET(dst) + (int)i &gt;= 512) || !(SAME-OBJECT(dst, &amp;home[0]))
</pre><p> This property asserts that the upper bound of the array <code>home</code> is not violated. The variable <code>home</code> looks familiar: We encountered it in the function <code>getConfig</code> given above. The function <code>getenv</code> in combination with functions <code>strcpy</code>, <code>strcat</code> or <code>sprintf</code> is indeed often the source for buffer overflows. Therefore, we try to use SATABS to check the upper bound of the array <code>home</code>: </p><pre class="fragment">satabs *.c --pointer-check --bounds-check --property getConfig.7
</pre><p> SATABS runs for quite a while and will eventually give up, telling us that its upper bound for abstraction refinement iterations has been exceeded. This is not exactly the result we were hoping for, and we could now increase the bound for iterations with help of the <code>--iterations</code> command line switch of SATABS.</p>
<p>Before we do this, let us investigate why SATABS has failed to provide a useful result. The function <code>strcpy</code> contains a loop that counts from 1 to the length of the input string. Predicate abstraction, the mechanism SATABS is based on, is unable to detect such loops and will therefore unroll the loop body as often as necessary. The array <code>home</code> has <code>MAX_LEN</code> elements, and <code>MAX_LEN</code> is defined to be 512 in <code>aeon.h</code>. Therefore, SATABS would have to run through at least 512 iterations, only to verify (or reject) one of the more than 300 properties! Does this fact defeat the purpose of static verification?</p>
<p>We can make the job easier: after reducing the value of <code>MAX_LEN</code> in <code>aeon.h</code> to a small value, say to 10, SATABS provides a counterexample trace that demonstrates how the buffer overflow be reproduced. If you use the Eclipse plugin (as described <a href="http://www.cprover.org/cprover-manual/installation-plugin.html">here</a>), you can step through this counterexample. The trace contains the string that is returned by <code>getenv</code>.</p>
<p>Last modified: 2024-07-10 11:45:02 -0700 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Documentation</a></li><li class="navelem"><a class="el" href="cprover_documentation.html">CProver documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
