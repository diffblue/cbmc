<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: Assigns Clauses</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('contracts-assigns.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Assigns Clauses </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md57">Syntax</a><ul><li class="level2"><a href="#autotoc_md58">Lvalue targets</a></li>
<li class="level2"><a href="#autotoc_md59">Object slice targets</a></li>
<li class="level2"><a href="#autotoc_md62">Function parameters</a></li>
<li class="level2"><a href="#autotoc_md63">Inductive data structures</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md64">Semantics</a><ul><li class="level2"><a href="#autotoc_md65">Contract Enforcement</a></li>
<li class="level2"><a href="#autotoc_md66">Contract Replacement</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md67">Additional Resources</a></li>
</ul>
</div>
<div class="textblock"><p>Back to <a class="el" href="contracts-user.html">Code Contracts User Documentation</a></p>
<h1><a class="anchor" id="autotoc_md57"></a>
Syntax</h1>
<p>An <em>assigns</em> clause allows the user to specify a set of locations that may be assigned to by a function or the body of a loop:</p>
<div class="fragment"><div class="line">__CPROVER_assigns(targets)</div>
</div><!-- fragment --><p>Where <code>targets</code> has the following syntax:</p>
<div class="fragment"><div class="line">targets           ::= cond-target-group (&#39;;&#39; cond-target-group)* &#39;;&#39;?</div>
<div class="line">cond-target-group ::= (condition &#39;:&#39;)? target (&#39;,&#39; target)*</div>
<div class="line">target            ::= lvalue-expr</div>
<div class="line">                    | __CPROVER_typed_target(lvalue-expr)</div>
<div class="line">                    | __CPROVER_object_whole(ptr-expr)</div>
<div class="line">                    | __CPROVER_object_from(ptr-expr)</div>
<div class="line">                    | __CPROVER_object_upto(ptr-expr, uint-expr)</div>
</div><!-- fragment --><p>The set of locations writable by a function is the union of the sets of locations specified by its assigns clauses, or the empty set if no <em>assigns</em> clause is specified. While, in general, an <em>assigns</em> clause could be interpreted with either <em>writes</em> or <em>modifies</em> semantics, this design is based on the former. This means that memory not captured by an <em>assigns</em> clause must not be assigned to by the given function, even if the value(s) therein are not modified.</p>
<p>For function contracts, the condition and target expressions in the assigns clause may only involve function parameters, global variables or type identifiers (in <code>sizeof</code> or cast expressions). The target expression must be free of function calls and side-effects. The condition expression may contain calls to side-effect-free functions.</p>
<p>For a loop contract, the condition and target expressions in the assigns clause may involve any identifier that is in scope at loop entry (parameters of the surrounding function, local variables, global variables, type identifiers in <code>sizeof</code> or cast expressions, etc.). The target expression must be free of function calls and side-effects. The condition expression may contain calls to side-effect-free functions.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Lvalue targets</h2>
<p>Roughly speaking, <em>lvalues</em> are expressions that are associated with a memory location, the address of which can be computed using the address-of operator <code>&amp;</code>.</p>
<p>Examples of lvalues are: <code>x</code> if <code>x</code> is either a global or local variable identifier, <code>*ptr</code> if <code>ptr</code> is a pointer expression, <code>ptr[i]</code> or <code>ptr + i</code> if <code>ptr</code> is pointer variable or an array and <code>i</code> is an integer expression, etc.</p>
<p>Examples of non-lvalues: literal constants like <code>0</code>, <code>1</code>, ..., arithmetic expressions like <code>x + y</code> when <code>x</code> and <code>y</code> are both arithmetic variables, function pointer expressions, etc.</p>
<p>An lvalue target <code>expr</code> with a complete type <code>expr_t</code> specifies that the range starting at <code>&amp;expr</code> and of size <code>sizeof(expr_t)</code> bytes is assignable.</p>
<p>Lvalues can also be wrapped in <code>__CPROVER_typed_target</code> with the same meaning: for an lvalue <code>expr</code> with a complete type <code>expr_t</code>, <code>__CPROVER_typed_target(expr)</code> specifies that the range of <code>sizeof(expr_t)</code> bytes starting at <code>&amp;expr</code> is assignable:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> __CPROVER_typed_target(expr_t expr);</div>
</div><!-- fragment --><p>In order to specify that a memory location the contents of which is interpreted as a pointer by the program is assignable, one must use the notation <code>__CPROVER_assigns(ptr)</code> or the equivalent <code>__CPROVER_assigns(__CPROVER_typed_target(ptr))</code>, as opposed to the slice operators <code>__CPROVER_object_whole</code>, <code>__CPROVER_object_from</code>, or <code>__CPROVER_object_upto</code>. This ensures that during call-by-contract replacement the memory location gets turned into a non-deterministic pointer.</p>
<p>For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>circular_buffer_t {</div>
<div class="line">  <span class="keywordtype">int</span> *first;</div>
<div class="line">  <span class="keywordtype">int</span> *last;</div>
<div class="line">  <span class="keywordtype">int</span> *current;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> step(<span class="keyword">struct</span> circular_buffer_t *buf)</div>
<div class="line"><span class="comment">// correct</span></div>
<div class="line">__CPROVER_assigns(__CPROVER_typed_target(buf-&gt;current))</div>
<div class="line"><span class="comment">// not correct</span></div>
<div class="line">__CPROVER_assigns(<a class="code" href="cprover__builtin__headers_8h.html#a2be80782db5f3cfb2a75f18530b2c992">__CPROVER_object_upto</a>(&amp;(buf-&gt;current), sizeof(buf-&gt;current))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(buf-&gt;current == buf-&gt;last)</div>
<div class="line">    buf-&gt;current = buf-&gt;first;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    buf-&gt;current += 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md59"></a>
Object slice targets</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="cprover__builtin__headers_8h.html#a2be80782db5f3cfb2a75f18530b2c992">__CPROVER_object_upto</a>(<span class="keywordtype">void</span> *ptr, __CPROVER_size_t size);</div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object (possibly at some non-zero offset), <code>__CPROVER_object_upto(ptr, size)</code> specifies that the range of <code>size</code> bytes starting at <code>ptr</code> is assignable.</p>
<p>The value of <code>size</code> must such that the range does not exceed the object's boundary, i.e. <code>size &lt;= __CPROVER_OBJECT_SIZE(ptr) - __CPROVER_POINTER_OFFSET(ptr)</code> must hold (otherwise an assertion violation will occur and make the whole analysis fail).</p>
<p>In the example below, the <code>struct vect_t</code>, its <code>data</code> array and an exta hidden byte are packed together in a single object by the <code>vec_alloc</code> function. The <code>vec_clear</code> function can only assign <code>vec-&gt;size</code> bytes starting from <code>vec-&gt;data</code>. As a result the assignments to <code>vec-&gt;size</code> and the hidden byte fail the verification.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MAX_SIZE 10</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>vec_t {</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">char</span> *data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Allocates a vect_t struct together with its data and a hidden byte</span></div>
<div class="line"><span class="comment">// in a same object.</span></div>
<div class="line"><span class="keyword">struct </span>vec_t *vec_alloc(<span class="keywordtype">size_t</span> size) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(size &gt; MAX_SIZE)</div>
<div class="line">    size = MAX_SIZE;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// allocate the struct + data + 1 extra hidden byte</span></div>
<div class="line">  <span class="keyword">struct </span>vec_t *vec = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vec_t) + size + 1);</div>
<div class="line">  <span class="keywordflow">if</span> (vec) {</div>
<div class="line">    vec-&gt;size = size;</div>
<div class="line">    vec-&gt;data = ((<span class="keywordtype">char</span> *)vec) + <span class="keyword">sizeof</span>(<span class="keyword">struct </span>vec_t);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> vec;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clear the vec-&gt;data array</span></div>
<div class="line"><span class="keywordtype">void</span> vec_clear(<span class="keyword">struct</span> vec_t *vec)</div>
<div class="line">  __CPROVER_assigns(</div>
<div class="line">    vec &amp;&amp; vec-&gt;data: <a class="code" href="cprover__builtin__headers_8h.html#a2be80782db5f3cfb2a75f18530b2c992">__CPROVER_object_upto</a>(vec-&gt;data, vec-&gt;size))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!vec)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  vec-&gt;size = vec-&gt;size; <span class="comment">// FAILURE</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec-&gt;size; i++)</div>
<div class="line">    vec-&gt;data[i] = 0; <span class="comment">// SUCCESS</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">char</span> *hidden_byte = ((<span class="keywordtype">char</span> *)vec + <span class="keyword">sizeof</span>(*vec) + vec-&gt;size);</div>
<div class="line">  *hidden_byte = 0; <span class="comment">// FAILURE</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Proof harness</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keyword">struct </span>vec_t *vec = vec_alloc(size);</div>
<div class="line">  vec_clear(vec);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="cprover__builtin__headers_8h.html#abca0337cfd5268f7bce166885ccd74ba">__CPROVER_object_from</a>(<span class="keywordtype">void</span> *ptr);</div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object (possibly at some non-zero offset), <code>__CPROVER_object_from(ptr)</code> specifies that the range of bytes starting at <code>ptr</code> and of size <code>__CPROVER_OBJECT_SIZE(ptr) - __CPROVER_POINTER_OFFSET(ptr)</code> is assignable.</p>
<p>Revisiting our previous example, changing the target to <code>__CPROVER_object_from(vec-&gt;data)</code> still rejects the assignment to <code>vec-&gt;size</code>, but allows the assignment to the hidden byte which is located after the data array in memory.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MAX_SIZE 10</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>vec_t {</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">char</span> *data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Allocates a vect_t struct together with its data and a hidden byte</span></div>
<div class="line"><span class="comment">// in a same object.</span></div>
<div class="line"><span class="keyword">struct </span>vec_t *vec_alloc(<span class="keywordtype">size_t</span> size) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(size &gt; MAX_SIZE)</div>
<div class="line">    size = MAX_SIZE;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// allocate the struct + data + 1 extra hidden byte</span></div>
<div class="line">  <span class="keyword">struct </span>vec_t *vec = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vec_t) + size + 1);</div>
<div class="line">  <span class="keywordflow">if</span> (vec) {</div>
<div class="line">    vec-&gt;size = size;</div>
<div class="line">    vec-&gt;data = ((<span class="keywordtype">char</span> *)vec) + <span class="keyword">sizeof</span>(<span class="keyword">struct </span>vec_t);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> vec;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clear the vec-&gt;data array</span></div>
<div class="line"><span class="keywordtype">void</span> vec_clear(<span class="keyword">struct</span> vec_t *vec)</div>
<div class="line">  __CPROVER_assigns(</div>
<div class="line">    vec &amp;&amp; vec-&gt;data: <a class="code" href="cprover__builtin__headers_8h.html#abca0337cfd5268f7bce166885ccd74ba">__CPROVER_object_from</a>(vec-&gt;data))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!vec)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  vec-&gt;size = vec-&gt;size; <span class="comment">// FAILURE</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec-&gt;size; i++)</div>
<div class="line">    vec-&gt;data[i] = 0; <span class="comment">// SUCCESS</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">char</span> *hidden_byte = ((<span class="keywordtype">char</span> *)vec + <span class="keyword">sizeof</span>(*vec) + vec-&gt;size);</div>
<div class="line">  *hidden_byte = 0; <span class="comment">// SUCCESS</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Proof harness</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keyword">struct </span>vec_t *vec = vec_alloc(size);</div>
<div class="line">  vec_clear(vec);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="cprover__builtin__headers_8h.html#a4fa7fcb05ec9018275a358ae39f80392">__CPROVER_object_whole</a>(<span class="keywordtype">void</span> *ptr);</div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object (possibly at some non-zero offset), <code>__CPROVER_object_whole(ptr)</code> specifies that the range of bytes of size <code>__CPROVER_OBJECT_SIZE(ptr)</code> starting at address <code>ptr - __CPROVER_POINTER_OFFSET(ptr)</code> is assignable:</p>
<p>If the pointer has a positive offset into some object, the range includes bytes that are in the object before the address pointed to by <code>ptr</code>. Revisiting our example one last time, changing the target to <code>__CPROVER_object_whole(vec-&gt;data)</code> allows the function (perhaps mistakenly) to assign to <code>vec-&gt;size</code>, the whole array of size <code>vec-&gt;size</code> pointed to by <code>vec-&gt;data</code> and the hidden byte.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define MAX_SIZE 10</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>vec_t {</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">char</span> *data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Allocates a vect_t struct together with its data and a hidden byte</span></div>
<div class="line"><span class="comment">// in a same object.</span></div>
<div class="line"><span class="keyword">struct </span>vec_t *vec_alloc(<span class="keywordtype">size_t</span> size) {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(size &gt; MAX_SIZE)</div>
<div class="line">    size = MAX_SIZE;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// allocate the struct + data + 1 extra hidden byte</span></div>
<div class="line">  <span class="keyword">struct </span>vec_t *vec = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vec_t) + size + 1);</div>
<div class="line">  <span class="keywordflow">if</span> (vec) {</div>
<div class="line">    vec-&gt;size = size;</div>
<div class="line">    vec-&gt;data = ((<span class="keywordtype">char</span> *)vec) + <span class="keyword">sizeof</span>(<span class="keyword">struct </span>vec_t);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> vec;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clear the vec-&gt;data array</span></div>
<div class="line"><span class="keywordtype">void</span> vec_clear(<span class="keyword">struct</span> vec_t *vec)</div>
<div class="line">  __CPROVER_assigns(</div>
<div class="line">    vec &amp;&amp; vec-&gt;data: <a class="code" href="cprover__builtin__headers_8h.html#a4fa7fcb05ec9018275a358ae39f80392">__CPROVER_object_whole</a>(vec-&gt;data))</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!vec)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">  vec-&gt;size = vec-&gt;size; <span class="comment">// SUCCESS</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec-&gt;size; i++)</div>
<div class="line">    vec-&gt;data[i] = 0; <span class="comment">// SUCCESS</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">char</span> *hidden_byte = ((<span class="keywordtype">char</span> *)vec + <span class="keyword">sizeof</span>(*vec) + vec-&gt;size);</div>
<div class="line">  *hidden_byte = 0; <span class="comment">// SUCCESS</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Proof harness</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>() {</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keyword">struct </span>vec_t *vec = vec_alloc(size);</div>
<div class="line">  vec_clear(vec);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Function parameters</h2>
<p>For a function contract, the memory locations storing function parameters are considered as being local to the function and are hence always assignable.</p>
<p>For a loop contract, the parameters of the enclosing function are not considered local to the loop and must be explicitly added to the loop to become assignable. </p>
<h2><a class="anchor" id="autotoc_md63"></a>
Inductive data structures</h2>
<p>Inductive data structures are not supported yet in assigns clauses.</p>
<h1><a class="anchor" id="autotoc_md64"></a>
Semantics</h1>
<p>Each target listed in an assigns clause defines a <em>conditionally assignable range</em> of bytes represented by the following triple:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>{</div>
<div class="line">  <span class="keywordtype">void</span> *start_address;</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">bool</span> is_writable;</div>
<div class="line">}</div>
</div><!-- fragment --><p>where:</p><ul>
<li><code>start_address</code> is the start address of the range of bytes,</li>
<li><code>size</code> is the size of the range in number of bytes,</li>
<li><code>is_writable</code> is true iff the target's <code>condition</code> holds and <code>__CPROVER_w_ok(start_address, size)</code> holds at the program location where the clause is interpreted: right before function invocation for function contracts and at loop entry for loops;</li>
</ul>
<p>For contract enforcement, assigns clause targets are turned into checks, to verify that the function only assigns locations allowed by the assigns clause.</p>
<p>For contract replacement, assigns clause targets are turned into havoc statements, to model the non-deterministic behaviour specified by the contract. </p>
<h2><a class="anchor" id="autotoc_md65"></a>
Contract Enforcement</h2>
<p>In order to determine whether a function (or loop) complies with the <em>assigns</em> clause of the contract, the body of the function (or loop) is instrumented with assertion statements before each statement which may write to memory (e.g., an assignment). These assertions check that the location about to be assigned to is among the targets specified by the <em>assigns</em> clauses.</p>
<p>For example, consider the following implementation of <code>sum</code> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line"><span class="comment">/* Writable Set */</span></div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  <span class="keywordflow">if</span> (result &gt; UINT32_MAX) <span class="keywordflow">return</span> FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Assignable locations for the <code>sum</code> function are the locations specified with <code>__CPROVER_assigns</code>, together with any location storing a function parameter, or any location that is locally stack- or heap-allocated as part of function (or loop) execution.</p>
<p>In the case of <code>sum</code> that is <code>*out</code> and <code>result</code>. Each assignment will be instrumented with an assertion to check that the target of the assignment is one of those options.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> __CPROVER_contracts_original_sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> uint64_t result;</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>((<a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(&amp;result) == <a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(out)  &amp;&amp;</div>
<div class="line">                    <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(&amp;result) == <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(out)) ||</div>
<div class="line">                   (<a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(&amp;result) == <a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(&amp;result)  &amp;&amp;</div>
<div class="line">                    <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(&amp;result) == <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(&amp;result))</div>
<div class="line">                   , <span class="stringliteral">&quot;Check that result is assignable&quot;</span>);</div>
<div class="line">  result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  <span class="keywordflow">if</span> (result &gt; UINT32_MAX) <span class="keywordflow">return</span> FAILURE;</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>((<a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(out) == <a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(out)  &amp;&amp;</div>
<div class="line">                     <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(out) == <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(out)) ||</div>
<div class="line">                    (<a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(out) == <a class="code" href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a>(&amp;result)  &amp;&amp;</div>
<div class="line">                     <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(out) == <a class="code" href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a>(&amp;result))</div>
<div class="line">                    , <span class="stringliteral">&quot;Check that result is assignable&quot;</span>);</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Function Contract Enforcement */</span></div>
<div class="line"><span class="keywordtype">int</span> sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> return_value_sum = __CPROVER_contracts_original_sum(a, b, out);</div>
<div class="line">  <span class="keywordflow">return</span> return_value_sum;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
Contract Replacement</h2>
<p>Assuming the <em>assigns</em> clause of the contract correctly captures the set of locations assigned to by a function (checked during <em>contract enforcement</em>), CBMC will use the contract's <a href="../../contracts/requires-and-ensures/#replacement">Requires &amp; Ensures Clauses</a>, and its <em>assigns clause</em> to generate a sound abstraction of the function behaviour from the contract.</p>
<p>Given the contract:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> f(params)</div>
<div class="line">__CPROVER_requires(R);</div>
<div class="line">__CPROVER_assigns(A);</div>
<div class="line">__CPROVER_ensures(E);</div>
<div class="line">{ ... }</div>
</div><!-- fragment --><p>Function calls <code>f(args)</code> get replaced with a sequence of instuctions equivalent to:</p>
<div class="fragment"><div class="line"><span class="comment">// check preconditions</span></div>
<div class="line"><a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>(R[args/params], <span class="stringliteral">&quot;Check f preconditions&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// havoc the assignable targets</span></div>
<div class="line"><span class="comment">// for each target t1, t2, ... of A[args/params];</span></div>
<div class="line">t1 = nondet();</div>
<div class="line">t2 = nondet();</div>
<div class="line">...</div>
<div class="line"><span class="comment">// assume post conditions</span></div>
<div class="line">__CPROVER_assume(E[args/params]);</div>
</div><!-- fragment --><p>Where <code>R[args/params]</code>, <code>A[args/params]</code>, <code>E[args/params]</code> denote the contract clause expressions rewritten by substituting function parameters with the argyments passed at the call site.</p>
<p>In our example, consider that a function <code>foo</code> may call <code>sum</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> sum(<span class="keyword">const</span> uint32_t a, <span class="keyword">const</span> uint32_t b, uint32_t* out)</div>
<div class="line"><span class="comment">/* Preconditions */</span></div>
<div class="line">__CPROVER_requires(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <span class="keyword">sizeof</span>(*out)))</div>
<div class="line"><span class="comment">/* Postconditions */</span></div>
<div class="line">__CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE)</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b)))</div>
<div class="line"><span class="comment">/* Writable Set */</span></div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  <span class="keywordflow">if</span> (result &gt; UINT32_MAX) <span class="keywordflow">return</span> FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line">  <span class="keywordtype">int</span> rval = sum(a, b, &amp;out);</div>
<div class="line">  <span class="keywordflow">if</span> (rval == SUCCESS)</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  <span class="keywordflow">return</span> rval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>CBMC will use the function contract in place of the function implementation wherever the function is called.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Function Contract Replacement */</span></div>
<div class="line">  <span class="comment">/* Precondition */</span></div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a>(<a class="code" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <span class="keyword">sizeof</span>(*out)), <span class="stringliteral">&quot;Check requires clause&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Writable Set */</span></div>
<div class="line">  *(&amp;out) = nondet_uint32_t();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Postconditions */</span></div>
<div class="line">  <span class="keywordtype">int</span> return_value_sum = nondet_int();</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#ae5af07e274b573cd0f23ffb9d332bef2">__CPROVER_assume</a>(return_value_sum == SUCCESS || return_value_sum == FAILURE);</div>
<div class="line">  <a class="code" href="cprover__builtin__headers_8h.html#ae5af07e274b573cd0f23ffb9d332bef2">__CPROVER_assume</a>((return_value_sum == SUCCESS) ==&gt; (*out == (a + b)));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> rval = return_value_sum;</div>
<div class="line">  <span class="keywordflow">if</span> (rval == SUCCESS)</div>
<div class="line">    <span class="keywordflow">return</span> out;</div>
<div class="line">  <span class="keywordflow">return</span> rval;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md67"></a>
Additional Resources</h1>
<ul>
<li><a class="el" href="contracts-functions.html">Function Contracts</a><ul>
<li><a class="el" href="contracts-requires-ensures.html">Requires and Ensures Clauses</a></li>
<li><a class="el" href="contracts-assigns.html">Assigns Clauses</a></li>
<li><a class="el" href="contracts-frees.html">Frees Clauses</a></li>
</ul>
</li>
<li><a class="el" href="contracts-loops.html">Loop Contracts</a><ul>
<li><a class="el" href="contracts-loop-invariants.html">Loop Invariant Clauses</a></li>
<li><a class="el" href="contracts-decreases.html">Decreases Clauses</a></li>
<li><a class="el" href="contracts-assigns.html">Assigns Clauses</a></li>
<li><a class="el" href="contracts-frees.html">Frees Clauses</a></li>
</ul>
</li>
<li><a class="el" href="contracts-memory-predicates.html">Memory Predicates</a></li>
<li><a class="el" href="contracts-function-pointer-predicates.html">Function Pointer Predicates</a></li>
<li><a class="el" href="contracts-history-variables.html">History Variables</a></li>
<li><a class="el" href="contracts-quantifiers.html">Quantifiers</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="acprover__builtin__headers_8h_html_a2be80782db5f3cfb2a75f18530b2c992"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a2be80782db5f3cfb2a75f18530b2c992">__CPROVER_object_upto</a></div><div class="ttdeci">void __CPROVER_object_upto(void *ptr, __CPROVER_size_t size)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a4fa7fcb05ec9018275a358ae39f80392"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a4fa7fcb05ec9018275a358ae39f80392">__CPROVER_object_whole</a></div><div class="ttdeci">void __CPROVER_object_whole(void *ptr)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ad4e9673ed79a6d8ff4af6cf12d95c29f"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_is_fresh(const void *mem, __CPROVER_size_t size)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ae5af07e274b573cd0f23ffb9d332bef2"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ae5af07e274b573cd0f23ffb9d332bef2">__CPROVER_assume</a></div><div class="ttdeci">void __CPROVER_assume(__CPROVER_bool assumption)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_abca0337cfd5268f7bce166885ccd74ba"><div class="ttname"><a href="cprover__builtin__headers_8h.html#abca0337cfd5268f7bce166885ccd74ba">__CPROVER_object_from</a></div><div class="ttdeci">void __CPROVER_object_from(void *ptr)</div></div>
<div class="ttc" id="afile__converter_8cpp_html_a0ddf1224851353fc92bfbff6f499fa97"><div class="ttname"><a href="file__converter_8cpp.html#a0ddf1224851353fc92bfbff6f499fa97">main</a></div><div class="ttdeci">int main(int argc, char *argv[])</div><div class="ttdef"><b>Definition:</b> <a href="file__converter_8cpp_source.html#l00041">file_converter.cpp:41</a></div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_af66015ac3e467377c4ad94c0fcc4cb97"><div class="ttname"><a href="cprover__builtin__headers_8h.html#af66015ac3e467377c4ad94c0fcc4cb97">__CPROVER_POINTER_OFFSET</a></div><div class="ttdeci">__CPROVER_ssize_t __CPROVER_POINTER_OFFSET(const void *)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a84fcea3f7109884566cb6e4e934abf13"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a84fcea3f7109884566cb6e4e934abf13">__CPROVER_POINTER_OBJECT</a></div><div class="ttdeci">__CPROVER_size_t __CPROVER_POINTER_OBJECT(const void *)</div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a564e8a5a7bebea04fdd5ee1277832478"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a564e8a5a7bebea04fdd5ee1277832478">__CPROVER_assert</a></div><div class="ttdeci">void __CPROVER_assert(__CPROVER_bool assertion, const char *description)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="contracts-mainpage.html">Code Contracts in CBMC</a></li><li class="navelem"><a class="el" href="contracts-user.html">Code Contracts User Documentation</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
